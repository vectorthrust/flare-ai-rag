file_name,meta_data,content,last_updated
1-intro.mdx,"sidebar_position: 1
slug: intro
title: Introduction
description: Introduction to Flare, the blockchain for data.
keywords:
  [
    flare-network,
    blockchain,
    data,
    smart contracts,
    flare-time-series-oracle,
    flare-data-connector,
  ]","import ThemedImage from ""@theme/ThemedImage"";
import useBaseUrl from ""@docusaurus/useBaseUrl"";

**Flare is the blockchain for data ‚òÄÔ∏è**, offering developers and users secure, decentralized access to high-integrity data from other chains and the internet. Flare's Layer-1 network uniquely supports enshrined data protocols at the network layer, making it the only EVM-compatible smart contract platform optimized for decentralized data acquisition, including price and time-series data, blockchain event and state data, and Web2 API data.

By providing broad data access at scale and minimal cost, Flare delivers a full-stack solution for building the next generation of secure, interoperable, and data-driven decentralized applications.

## Getting started

- [Hello World in your browser](/network/getting-started) ‚Äî Build and deploy your first smart contract on Flare, using only your browser.

- [Learn how to use FTSOv2](/ftso/overview) ‚Äî Leverage the latest upgrades to the Flare Time Series Oracle (FTSO), with feeds now updating every ‚âà1.8 seconds.

- Start building on Flare with programming languages you may already know

  - [JavaScript](/network/guides/flare-for-javascript-developers)
  - [Python](/network/guides/flare-for-python-developers)
  - [Rust](/network/guides/flare-for-rust-developers)
  - [Go](/network/guides/flare-for-go-developers)

## Understand the architecture

Build a strong understanding of the core concepts that set Flare apart from other blockchains. Flare's data protocols, [Flare Time Series Oracle (FTSO)](/ftso/overview) and [Flare Data Connector (FDC)](/fdc/overview), are enshrined into the core protocol of Flare, and inherit the economic security of the entire network.

<ThemedImage
  alt=""Flare Architecture""
  sources={{
    light: useBaseUrl(""img/flare_architecture_light.svg""),
    dark: useBaseUrl(""img/flare_architecture_dark.svg""),
  }}
/>

## Contribute to Flare

- [Contribute to Flare's open-source codebase](https://github.com/flare-foundation) ‚Äî Help build the future of Flare.

- [Become an FTSO data provider](/run-node/ftso-data-provider) ‚Äî Support DeFi applications on Flare with high-integrity, block-latency data feeds.

- [Run a Flare validator](/run-node/validator-node) ‚Äî Secure Flare and earn rewards by running a validator node.",2025-03-08 01:27:14
4-solidity-reference.mdx,"title: FTSOv2 Reference
description: Solidity reference for FTSOv2 smart contracts.
keywords:
  [
    solidity,
    reference,
    ftso,
    flare-time-series-oracle,
    flare-network,
    smart-contracts,
  ]","import Tabs from ""@theme/Tabs"";
import TabItem from ""@theme/TabItem"";
import DocCardList from ""@theme/DocCardList"";
import SolidityReference from ""@site/src/components/DataTables/SolidityReference"";

## Deployed Contracts

export const contracts = [
  ""FtsoV2"",
  ""FeeCalculator"",
  ""FtsoFeedIdConverter"",
  ""FastUpdater"",
  ""FastUpdatesConfiguration"",
  ""FastUpdateIncentiveManager"",
];

<Tabs block>
    <TabItem value=""flare"" label=""Flare Mainnet"" default>

        <SolidityReference
            network=""FlareMainnet""
            contractNames={contracts}
        />

    </TabItem>
    <TabItem value=""coston2"" label=""Flare Testnet Coston2"">

        <SolidityReference
            network=""FlareTestnetCoston2""
            contractNames={contracts}
        />

    </TabItem>
    <TabItem value=""songbird"" label=""Songbird Canary-Network"">

        <SolidityReference
            network=""SongbirdCanaryNetwork""
            contractNames={contracts}
        />

    </TabItem>

    <TabItem value=""coston"" label=""Songbird Testnet Coston"">

        <SolidityReference
            network=""SongbirdTestnetCoston""
            contractNames={contracts}
        />

    </TabItem>

</Tabs>

## Interfaces

<DocCardList />",2025-03-08 01:27:14
1-getting-started.mdx,"slug: getting-started
title: Getting Started
description: Learn how to consume FTSOv2 feeds on Flare using an onchain Solidity contract.
keywords:
  [
    ftso,
    oracle,
    flare-time-series-oracle,
    flare-network,
    smart-contracts,
    solidity,
    remix,
    metamask,
  ]","import Remix from ""@site/src/components/remix"";
import CodeBlock from ""@theme/CodeBlock"";
import YoutubeEmbed from ""@site/src/components/youtube"";
import FtsoV2FeedConsumer from ""!!raw-loader!/examples/developer-hub-solidity/FtsoV2FeedConsumer.sol"";
import OpenSolidityCompiler from ""/static/img/ftso-getting-started/0-open-solidity-compiler-tab.png"";
import SetEvmVersion from ""/static/img/ftso-getting-started/1-set-evm-version.png"";
import SetInjectedProvider from ""/static/img/ftso-getting-started/1-set-injected-provider.png"";
import CompileContract from ""/static/img/ftso-getting-started/2-compile-contract.png"";
import OpenDeploy from ""/static/img/ftso-getting-started/3-open-deploy.png"";
import DeployContract from ""/static/img/ftso-getting-started/4-deploy-contract.png"";
import ConfirmDeployInMetamask from ""/static/img/ftso-getting-started/5-confirm-deploy-in-metamask.png"";
import QueryLatestFeeds from ""/static/img/ftso-getting-started/6-query-latest-feeds.png"";

You can use FTSOv2 to connect your smart contracts with real-world data feeds. FTSOv2 leverages Flare's network of 100 independent data providers to fetch offchain data and deliver it onchain. This section demonstrates how to consume FTSOv2's block-latency feeds on Flare using an onchain Solidity contract.

:::info[New to smart contract development?]

Learn how to [deploy your first smart contract](/network/getting-started) before you start this guide.

:::

## Sample contract

This example smart contract queries the latest feed values for FLR/USD, BTC/USD, and ETH/USD from FTSOv2 on Flare Testnet Coston2.

<CodeBlock language=""solidity"" title=""FtsoV2FeedConsumer.sol"">
  {FtsoV2FeedConsumer}
</CodeBlock>

{/* prettier-ignore */}
<Remix fileName=""FtsoV2FeedConsumer.sol"">Open in Remix</Remix>
<br></br>

:::warning[Don't use test interfaces in production]

The `TestFtsoV2Interface` is for **testing only**, with all methods as `view` to allow rapid development without gas costs or state changes. For production, use [`FtsoV2Interface`](/ftso/solidity-reference/FtsoV2Interface), which includes `payable` methods required for real transactions and state modifications.

Make the following changes to `FtsoV2FeedConsumer.sol`:

```solidity
import {ContractRegistry} from ""@flarenetwork/flare-periphery-contracts/coston2/ContractRegistry.sol""
import {FtsoV2Interface} from ""@flarenetwork/flare-periphery-contracts/coston2/FtsoV2Interface.sol"";

contract FtsoV2FeedConsumer {
   //...
   function getFtsoV2CurrentFeedValues()
      external
      returns (
         uint256[] memory _feedValues,
         int8[] memory _decimals,
         uint64 _timestamp
      )
   {
      ftsoV2 = ContractRegistry.getFtsoV2();
      /* Your custom feed consumption logic. In this example the values are just returned. */
      return ftsoV2.getFeedsById(feedIds);
   }
}
```

:::

<details>
    <summary>Breaking down the contract.</summary>

    - **Purpose**: Interacts with the Flare Network to fetch current feed values for specific cryptocurrency pairs (FLR/USD, BTC/USD, ETH/USD).

    - **Dependencies**:

    - `ContractRegistry.sol`: Used to get the addresses of various contracts on the Flare network.
    - `TestFtsoV2Interface.sol`: This interface allows interaction with the FTSOv2 contract, which provides real-time price feeds for various assets.

    - **State Variables**:

    - `ftsoV2`: This is a state variable of type `TestFtsoV2Interface`. It will hold the address of the FTSO V2 contract once initialized.
    - `feedIndexes`: An array of indexes corresponding to different price feeds. In this example:
    - Index 0 corresponds to FLR/USD
    - Index 2 corresponds to BTC/USD
    - Index 9 corresponds to ETH/USD

    - **Constructor**:

    - The constructor is a special function that runs only once when the contract is deployed. It initializes the `ftsoV2` state variable by fetching the FTSO V2 contract address using the `ContractRegistry`.

    - **Function `getFtsoV2CurrentFeedValues`**:

    - It is marked as `external`, meaning it can be called from outside the contract.
    - It is also marked as `payable`, allowing it to receive Ether when called, though in this example, the Ether is not used.
    - It returns three values:
    - `_feedValues`: The latest price values for the specified feeds.
    - `_decimals`: The decimal precision of each feed value.
    - `_timestamp`: The timestamp when the prices were fetched.

    Inside the function:

    - The `ftsoV2.getFeedsByIndex(feedIndexes)` call retrieves the latest prices for the indexes specified in `feedIndexes`.
    - These values are then returned to the caller.

</details>

## Compile and deploy the contract

:::info[Configure and fund your wallet]

If you have not already configured your MetaMask wallet to support Flare Testnet Coston2 and funded it with testnet C2FLR, learn how to [deploy your first smart contract](/network/getting-started). You can get testnet C2FLR from the [Coston2 Faucet](https://faucet.flare.network/coston2).

:::

{/* prettier-ignore */}
1. <Remix feedName=""FtsoV2FeedConsumer.sol"">Open contract in Remix</Remix>

2. Click on `FtsoV2FeedConsumer.sol` in the file explorer to open the contract in the editor.

2. On the left side of Remix, click the **Solidity Compiler** tab to view the compiler settings.

   <img src={OpenSolidityCompiler} style={{ width: 300 }} />

3. Expand the **Advanced Configurations** section and make sure the **EVM Version** is set to `london`.

   <img src={SetEvmVersion} style={{ width: 300 }} />

3. Click the **Compile FtsoV2FeedConsumer.sol** button to compile the contract.

   <img src={CompileContract} style={{ width: 300 }} />

4. On the left side of Remix, click the **Deploy & Run transactions** tab to view the deployment settings.

   <img src={OpenDeploy} style={{ width: 300 }} />

5. Select the **Injected Provider - MetaMask** environment.

   <img src={SetInjectedProvider} style={{ width: 300 }} />

6. Click **Deploy** to deploy the contract to Flare Testnet Coston2. MetaMask opens and asks you to confirm payment for deploying the contract. Make sure MetaMask is set to Flare Testnet Coston2 before you confirm the transaction.

   <img src={DeployContract} style={{ width: 300 }} />

7. In the MetaMask prompt, click **Confirm** to approve the transaction and spend your testnet C2FLR required to deploy the contract.

   <img src={ConfirmDeployInMetamask} style={{ width: 300 }} />

8. After a few seconds, the transaction completes and your contract appears under the **Deployed/Unpinned Contracts** list in Remix. Click the contract dropdown to view its variables and functions. Click on **getFtsoV2CurrentFeedValues** to show the latest feed values and decimals.

   <img src={QueryLatestFeeds} style={{ width: 300 }} />

#### Function Returns

- `_feedValues`: Current integer values of FLR/USD, BTC/USD, and ETH/USD. The returns are in the same order as the input `feedIndexes` array.
- `_decimals`: Decimal places for FLR/USD, BTC/USD, and ETH/USD.
- `_timestamp`: Timestamp of the last feed update.

The floating point value of a feed can be calculated by dividing the `feedValue` by 10^`decimals`. For example, if the feed value of BTC/USD is `6900420` and the decimal is `2`, the floating point feed value is `69004.20`.

:::tip[What's next?]

[Build your first FTSOv2 app](/ftso/guides/build-first-app) using Foundry, or [read feeds offchain](/ftso/guides/read-feeds-offchain) in languages like JavaScript, Python, Rust, and Go.

:::

## Watch the video

<YoutubeEmbed embedLink=""Lgia7lbTSk0?si=rTkpw5Dh5E6X-DHz""></YoutubeEmbed>",2025-03-08 01:27:14
0-overview.mdx,"slug: overview
title: FTSOv2
description: FTSOv2 is an enshrined oracle that provides decentralized data feeds to the Flare network.
keywords: [ftso, oracle, flare-time-series-oracle, flare-network]","import ThemedImage from ""@theme/ThemedImage"";
import useBaseUrl from ""@docusaurus/useBaseUrl"";

The **F**lare **T**ime **S**eries **O**racle **(FTSO)** is an [enshrined oracle](/support/terminology#enshrined-oracle) that provides decentralized data feeds to the Flare network. Since the release of FTSOv1 two years ago, users and applications on Flare have enjoyed consistent and reliable pricing, with zero downtime or failures. FTSOv2 builds on the robust foundation laid by its predecessor, offering several enhancements:

- **Secure.** Enshrined into Flare's core protocol, every oracle feed in FTSOv2 inherits the economic security of the entire network.

- **Fast.** FTSOv2 features block-latency feeds, updating with each new block on Flare, every ‚âà1.8 seconds.

- **Scalable.** FTSOv2 supports up to 1000 feeds across various asset classes including equities, commodities, and cryptocurrencies, with access to 2 weeks of historical data.

- **Decentralized.** Each FTSOv2 feed is supported by around 100 independent data providers, who are selected by Flare users through their delegated stake, imposing a strict economic cost for misbehavior.

- **Cost-effective.** Block-latency feeds in FTSOv2 are completely free to query. Feeds from Scaling are also free to query and verify locally, with minimal gas costs for onchain verification.

## Architecture

FTSOv2 ensures fast, secure, and manipulation-resistant feeds by using a stake-weighted verifiable randomness function (VRF) to select a sample of data providers for incremental delta updates. These updates maintain long-term accuracy by anchoring to Scaling feeds, which use a full commit-reveal process and update every 90 seconds. During high market volatility, volatility incentives can increase the sample size of data providers for a quicker response to market conditions.

<ThemedImage
  alt=""FTSO Price Comparison""
  sources={{
    light: useBaseUrl(""img/ftso-overview/ref_fast_comparison_social.svg""),
    dark: useBaseUrl(""img/ftso-overview/ref_fast_comparison_social_dark.svg""),
  }}
/>

The FTSOv2 architecture consists of four key components:

1. **Verifiably Random Selection:** Each block on Flare triggers the selection of data providers to deliver the next feed update using a stake-weighted Verifiable Randomness Function. This ensures fairness and resistance to manipulation.

2. **Incremental Delta Update:** Selected data providers submit new feed updates as fixed incremental deltas applied to the previous feed value. This maintains reliable and continuous updates, ensuring integrity and accuracy.

3. **Volatility Incentive Mechanism:** To handle periods of high market volatility, FTSOv2 introduces volatility incentives, temporarily increasing the sample size of selected data providers in exchange for a fee. This permissionless mechanism ensures a faster response to significant price movements.

4. **Anchoring to Scaling Feeds:** Scaling feeds, which employ a full commit-reveal process across all data providers, act as anchors to ensure long-term accuracy.

:::tip[Interested in learning more?]

For a detailed explanation of the FTSOv2 mechanism, read the [FTSOv2 whitepaper](https://flare.network/wp-content/uploads/FTSOv2-White-Paper.pdf).

:::

### Verifiably Random Selection

Every block on Flare, generated approximately every 1.8 seconds, initiates the selection of a sample of data providers to deliver the next feed update. This selection process leverages a stake-weighted verifiable randomness function (VRF), where the likelihood of each data provider being chosen is proportional to their stake. The expected sample size is one, and data providers have no control over, nor knowledge of, when they will be selected.

In detail, each block has a unique seed value, used by FTSOv2 data providers to generate a personal random score. This score, coupled with a cryptographic proof, ensures its authenticity and verifiability, preventing prediction or manipulation by others. Data providers are chosen based on their scores: those with scores below a certain threshold are selected to make updates. The selection probability is proportional to the data provider's stake, allowing for weighted sampling where participants with a higher stake have a greater chance of being selected. This mechanism ensures fairness and resistance to manipulation.

To maintain security, the seed value itself evolves pseudo-randomly. This approach balances security and randomness, preventing adversaries from influencing the selection process. The system is designed to be statistically robust, ensuring a reliable and continuous selection of participants to uphold the integrity and accuracy of updates.

### Incremental Delta Update

The selected data providers submit the new feed update, which is a fixed incremental delta applied to the previous feed value. The base increment size for all updates is `1/2^13 ‚âà 0.0122%`, a value determined through extensive market analysis and approved by Flare governance. The delta can be in one of three directions:

    - **Up (+)**: The new feed value is incrementally increased from the previous value.
    - **Down (‚Äì)**: The new feed value is incrementally decreased from the previous value.
    - **Unchanged (0)**: The new feed value remains the same as the previous value.

<ThemedImage
  alt=""FTSO Update Architecture""
  sources={{
    light: useBaseUrl(""img/ftso-overview/ftso_update_architecture_light.svg""),
    dark: useBaseUrl(""img/ftso-overview/ftso_update_architecture_dark.svg""),
  }}
/>

<details>
<summary>The mathematics of incremental delta updates.</summary>

The FTSOv2 protocol utilizes block-latency feeds, denoted as $P(t)$, which are continuously updated following the formula,

$$
P(t + 1) = (1 + p)^{\delta(t)}P(t)
$$

where,

- $p$ is the protocol parameter named _precision_, and
- $\delta$ is the update provided by a data provider, with $\delta(t)$ being one of the three options $\{-1, 0, 1\}$.

The precision parameter is set to a default value of $p = 1/2^{13} ‚âà  0.0122\%$, which has been rigorously tested against price feeds from centralized exchanges. Another key protocol parameter is the average number of updates submitted per block, with a default value of $e = 1$. The average number of updates submitted per block $e$ can be temporarily increased in exchange for a fee using the volatility incentive mechanism.

</details>

### Volatility Incentive Mechanism

From statistical analysis, FTSOv2's mechanism is capable of capturing over 99% of all price movements under normal market conditions. However, during periods of high market volatility, the small size of each increment may be slower to reflect large price movements. To address this, FTSOv2 introduces volatility incentives, which allows for a temporary increase in the sample size of data providers in exchange for a fee. The volatility incentive mechanism is permissionless, enabling anyone on Flare to trigger it by paying the required fee.

Typically, the expected sample size is one. With volatility incentives, this sample size is temporarily increased, allowing for more updates and quicker responses to large price movements. Importantly, only the expected sample size increases, not the actual sample size, which further helps protect the protocol against various statistical attacks.

### Anchoring to Scaling

FTSOv2's block-latency feeds are designed to be statistically self-correcting. To further ensure their long-term accuracy, FTSOv2 uses the anchor feeds from [Scaling](/ftso/scaling/overview). Anchor feeds utilize a full commit-reveal process across all data providers with an inter-quartile range (IQR) band calculation, and update once every voting epoch (i.e. 90 seconds). Data providers are only rewarded if the block-latency feeds converge to within `¬±0.25%` of the anchor feeds every voting epoch.",2025-03-08 01:27:14
5-migration.mdx,"title: Migrating from v1
slug: migration
description: Migration guide for dApps moving from FTSOv1 to FTSOv2.
keywords:
  [solidity, ftso, flare-time-series-oracle, flare-network, smart-contracts]","import CodeBlock from ""@theme/CodeBlock"";
import FtsoV2MigrationExample from ""!!raw-loader!/examples/developer-hub-solidity/FtsoV2MigrationExample.sol"";

This guide is for applications moving from FTSOv1 to FTSOv2. Briefly, FTSOv2 comprises of:

- **[Block-Latency Feeds](/ftso/feeds)**: These feeds are updated with each new block, approximately every 1.8 seconds. They can be accessed through [FtsoV2Interface](/ftso/solidity-reference/FtsoV2Interface) and are available directly on-chain.
- **[Anchor Feeds](/ftso/scaling/anchor-feeds)**: These feeds are provided through [Scaling](/ftso/scaling/overview) with a latency of 90 seconds. Feeds can be verified using [FtsoV2Interface](/ftso/solidity-reference/FtsoV2Interface) but are not immediately available on-chain.

A key difference between the two is the introduction of a payment mechanism for data access. This system helps prevent unnecessary data requests and ensures sustainable funding. For more details, refer to the [`IFeeCalculator`](/ftso/solidity-reference/IFeeCalculator) contract, which calculates fees for data access using the [`calculateFeeByIds`](/ftso/solidity-reference/IFeeCalculator#calculatefeebyids) method.

Additionally, a new Long Term Support (LTS) system has been launched to ensure continued access to essential data and metadata within the Flare ecosystem. A series of [LTS interfaces](#lts-interfaces) have been introduced, each aligned with a specific product in the Flare ecosystem. It is strongly recommended to use these LTS contracts for data access instead of querying individual contracts or interfaces, as they are designed for long-term stability, even as underlying protocols evolve or migrate.

## Deprecated contracts (v1)

### PriceSubmitter

The `PriceSubmitter` contract (`IPriceSubmitter`) is being deprecated as part of the transition to the new version of the FTSO system.

If you were using `PriceSubmitter` for the following purposes, here are the recommended alternatives:

- **Accessing other important contracts**: Use the [`FlareContractRegistry`](/network/solidity-reference/IFlareContractRegistry) instead.
- **Voting-related functionalities**: These are now integrated into the new FTSO system.

- **Random number generation** (`getCurrentRandom` or `getRandom`, applicable to Flare only): Switch to the new [`RandomNumberV2Interface`](#lts-interfaces). The new protocol updates random numbers every 90 seconds (aligned with the voting epoch duration, as returned by `votingEpochDurationSeconds`). This setting is immutable but could change if the protocol configuration is updated. In contrast, the old protocol updated random numbers every 180 seconds.

#### Required Changes:

- Use `RandomNumberV2` instead of `PriceSubmitter` (ensure you update to the new contract address and interface).
- **Method updates**:
  - `getCurrentRandom` ‚Üí `getRandomNumber`
  - `getRandom(epochId)` ‚Üí `getRandomNumberHistorical(epochId)`

### FTSO

The legacy `FTSO` contract is being deprecated and replaced. A minimal proxy will be deployed at the same address to provide basic backward compatibility. The replacement will be [`FtsoProxy`](#ftsoproxy), which will respond to a limited subset of calls that the old `FTSO` contract handled. Although the addresses will change, the `FTSORegistry` will be updated to point to the new contract addresses.

#### Recommended Changes:

- **Random number retrieval**: Switch to the new [`RandomNumberV2Interface`](#lts-interfaces). The proxy contract will still return current and historical random numbers, but they will be uniform across all `FTSO` contracts, and randomness will be sourced from the new provider.

- **Fetching the current price**: For methods like `getCurrentPrice`, `getCurrentPriceDetails`, or `getCurrentPriceWithDecimals`, switch to the [`FTSOv2Interface`](#lts-interfaces). While the proxy interface will continue to function temporarily, it will not receive future updates.

- **Fetching historical prices**: For methods such as `getEpochPrice`, or retrieving prices for specific voters or trusted data providers, the proxy contract **WILL REVERT**. It is essential to migrate to the new `FTSOv2Interface` for these functionalities.

### FTSORegistry

The `FTSORegistry` (`IFTSORegistry`) is being deprecated. While you can continue to use it temporarily with its backward-compatible methods, it is strongly recommended to transition to the new interfaces as soon as possible, as `FTSORegistry` will no longer be maintained in the future.

#### Recommended Changes:

- **Getting FTSOs**: The methods `getFtso`, `getFtsoBySymbol`, `getFtsoIndex`, `getFtsoSymbol`, and `getSupportedIndices/Symbols/Ftsos` are now deprecated. They will still return the proxy implementation of FTSO, but these proxies will not be maintained moving forward. It is recommended to update your code to use the [FTSOv2Interface](#lts-interfaces) for price retrieval. Additional details like decimals and timestamps for individual FTSOs are now considered deprecated and can be obtained by querying prices directly through `FTSOv2`.

- **Reading prices** using methods such as `getCurrentPrice(_ftso_index/_symbol)` or their array and decimal implementations is also deprecated. Although these methods will still return correct values, they will not be updated in the future. Use the [FTSOv2Interface](#lts-interfaces) instead to ensure future compatibility.

- **Getting supported FTSOs**: This function will return correct results for legacy price pairs but will not be updated for new pairs introduced in the FTSOv2 system. To retrieve information about available pairs in the new system, you should transition to the [FTSOv2Interface](#lts-interfaces) interface.

- **Read prices directly from `FtsoV2Interface`**: This will give you up-to-date prices and more detailed information. Additionally, the `FtsoV2Interface` is part of the Long Term Support (LTS) system, ensuring it will be maintained for an extended period.

- **New system indexing and ID scheme**:
  - The indexing and ID scheme has changed. Old indices are now invalid, so do not use the previous `getFeedByIndex` method with the old indices.
  - IDs in the new system are 21-byte values, formatted as `""${OLD_FEED_NAME}/USD""` and zero-padded.
  - Use the `getFeedById` method in the new interface to retrieve old prices with this format: `getFeedById(bytes21(bytes.concat(bytes1(1), bytes(string.concat(OLD_FEED_NAME, ""/USD"")))))`.

### FTSORewardManager

The reward system is undergoing significant changes. While an implementation of the old `FTSORewardManager` contract is provided, it will only support the most basic claim types and require pre-provided reward proofs.

#### Recommended Changes:

- **Claiming rewards**: Switch to the new [`RewardsV2Interface`](#lts-interfaces). The proxy contract will still allow you to claim rewards from the FTSO system, but it will not support claiming fees for data providers.

- **Claiming rewards when delegating by amount**: This feature is no longer supported in the new system.

## LTS interfaces

The primary goal of the Long Term Support (LTS) interfaces is to offer a stable and reliable way to access essential data and metadata within the Flare ecosystem. These interfaces are designed for long-term maintenance, ensuring continuity even as underlying contracts evolve or protocols migrate to new versions. Each LTS interface is aligned with a specific product within the Flare ecosystem, providing consistency and ease of use over time.

| **Interface**                                                                  | **Contract registry name** | **Notes**                                                 |
| ------------------------------------------------------------------------------ | -------------------------- | --------------------------------------------------------- |
| [ProtocolsV2Interface](/network/solidity-reference/ProtocolsV2Interface)       | `ProtocolsV2`              | Primary interface for managing protocol related metadata. |
| [RewardsV2Interface](/network/solidity-reference/RewardsV2Interface)           | `RewardsV2`                | Primary interface for managing all protocol rewards.      |
| [RandomNumberV2Interface](/network/solidity-reference/RandomNumberV2Interface) | `RandomNumberV2`           | Primary interface for random number generation.           |
| [FtsoV2Interface](/ftso/solidity-reference/FtsoV2Interface)                    | `FtsoV2`                   | Primary interface for interacting with FTSOv2.            |

:::warning

- **RandomNumberV2Interface:** In addition to providing random numbers, the new methods also return a `_isSecureRandom` flag. Learn more about this flag in the guide on [Secure Random Numbers](/network/guides/secure-random-numbers).
- **FtsoV2Interface:** Provides access to fetching block-latency feeds onchain, and verifying anchor feeds onchain. You can retrieve feeds using the [`getFeedById`](/ftso/solidity-reference/FtsoV2Interface#getfeedbyid) or [`getFeedsById`](/ftso/solidity-reference/FtsoV2Interface#getfeedsbyid) methods. These methods are now payable, and while the current fee is set to `0`, it is advisable to use [`FeeCalculator`](/ftso/solidity-reference/IFeeCalculator) to calculate the fee and be prepared for potential future changes.

:::

## Migration proxies

For the time being, a set of proxy contracts is provided to allow access to the old data and reward systems.

:::danger[Do not use for new developments]

These proxies offer a temporary solution to ensure that previously deployed contracts can continue functioning until they are fully updated.

:::

### FtsoProxy

The `FtsoProxy` contract is designed to maintain backward compatibility with the old FTSO contract. While it will be deployed at different addresses from the original FTSO contract, the `FTSORegistry` will be updated to point to these new addresses.

<details>
<summary>Methods in `FtsoProxy`</summary>

```solidity title=""FtsoProxy.sol""
   /**
     * Always return true, as the proxy is always active.
     */
    function active() external pure returns (bool) {
        return true;
    }

    /**
     * Will return the current epoch id correctly as defined by FSP
     */
    function getCurrentEpochId() external view returns (uint256) {
    }

    /**
     * Will return the epoch id correctly as defined by FSP.
     * Beware, the function will produce different results than the old FTSO contract.
     */
    function getEpochId(uint256 _timestamp) external view returns (uint256) {
    }

    /**
     * Will return the current random correctly
     */
    function getRandom(uint256 _votingRoundId) external view returns (uint256 _randomNumber) {
    }

    /**
     * @dev Deprecated - reverts
     */
    function getEpochPrice(uint256) external pure returns (uint256) {
        revert(""not supported"");
    }

    /**
     * Will return current price epoch data as defined by FSP
     */
    function getPriceEpochData() external view
        returns (
            uint256 _epochId,
            uint256 _epochSubmitEndTime,
            uint256 _epochRevealEndTime,
            uint256 _votePowerBlock,
            bool _fallbackMode
        )
    {
    }

    /**
     * Will return the price epoch configuration as defined by FSP
     */
    function getPriceEpochConfiguration() external view
        returns (
            uint256 _firstEpochStartTs,
            uint256 _submitPeriodSeconds,
            uint256 _revealPeriodSeconds
        )
    {
    }

    /**
     * @dev Deprecated - reverts
     */
    function getEpochPriceForVoter(uint256, address) external pure returns (uint256) {
        revert(""not supported"");
    }

    /**
     * Will return the current price correctly
     */
    function getCurrentPrice() external view returns (uint256, uint256) {
    }

    /**
     * Will return the current price with decimals correctly
     */
    function getCurrentPriceWithDecimals()
        external view
        returns (
            uint256 _value,
            uint256 _timestamp,
            uint256 _decimals
        )
    {
    }


    /**
     * Will return the current price with details correctly
     */
    function getCurrentPriceDetails()
        external view
        returns (
            uint256,
            uint256,
            PriceFinalizationType,
            uint256,
            PriceFinalizationType
        )
    {
    }

    /**
     * @dev Deprecated - reverts
     */
    function getCurrentPriceFromTrustedProviders() external pure returns (uint256, uint256) {
        revert(""not supported"");
    }

    /**
     * @dev Deprecated - reverts
     */
    function getCurrentPriceWithDecimalsFromTrustedProviders() external pure returns (uint256, uint256, uint256) {
        revert(""not supported"");
    }

    /**
     * Will return the current random correctly
     */
    function getCurrentRandom() external view returns (uint256 _currentRandom) {
    }

```

</details>

### FtsoRewardManagerProxy

The `FtsoRewardManagerProxy` contract is designed to maintain backward compatibility with the old `FTSORewardManager` contract. It will be deployed at a different address than the original contract.

This proxy only supports the most basic reward claim types and requires that reward proofs be provided in advance.

<details>
<summary>Methods in `FtsoRewardManagerProxy`</summary>

```solidity title=""FtsoRewardManagerProxy.sol""
    /**
     * @dev Claims rewards correctly for delegation fees, assuming the proofs were already provided.
     */
    function claimReward(
        address payable _recipient,
        uint256[] calldata _rewardEpochs
    )
        external
        returns (uint256 _rewardAmount)
    {
    }

    /**
     * @dev Claims rewards correctly for delegation fees, assuming the proofs were already provided.
     */
    function claim(
        address _rewardOwner,
        address payable _recipient,
        uint256 _rewardEpoch,
        bool _wrap
    )
        external
        returns (uint256 _rewardAmount)
    {
    }


    /**
     * @dev Returns the current fee percentage for the data provider.
     */
    function getDataProviderCurrentFeePercentage(address _dataProvider)
        external view
        returns (uint256 _feePercentageBIPS)
    {
    }

    /**
     * @dev Returns the fee percentage for the data provider for the given reward epoch.
     */
    function getDataProviderFeePercentage(
        address _dataProvider,
        uint256 _rewardEpoch
    )
        external view
        returns (uint256 _feePercentageBIPS)
    {
    }

    /**
     * @dev Returns the fee percentage changes for the data provider.
     */
    function getDataProviderScheduledFeePercentageChanges(address _dataProvider) external view
        returns (
            uint256[] memory _feePercentageBIPS,
            uint256[] memory _validFromEpoch,
            bool[] memory _fixed
        )
    {
    }

    /**
     * @dev Returns the epoch reward correctly
     */
    function getEpochReward(uint256 _rewardEpoch) external view
        returns (uint256 _totalReward, uint256 _claimedReward)
    {
    }

    /**
     * @dev Returns the reward state correctly
     */
    function getStateOfRewards(
        address _beneficiary,
        uint256 _rewardEpoch
    )
        external view
        returns (
            address[] memory _dataProviders,
            uint256[] memory _rewardAmounts,
            bool[] memory _claimed,
            bool _claimable
        )
    {
    }

    /**
     * @dev Returns the epochs with claimable rewards correctly
     */
    function getEpochsWithClaimableRewards() external view
        returns (uint256 _startEpochId, uint256 _endEpochId)
    {
    }

    /**
     * @dev Returns the next claimable reward epoch correctly
     */
    function nextClaimableRewardEpoch(address _rewardOwner) external view returns (uint256) {
    }

    /**
     * @dev Returns the epochs with unclaimed rewards correctly
     */
    function getEpochsWithUnclaimedRewards(address _beneficiary) external view
        returns (uint256[] memory _epochIds)
    {
    }

    /**
     * @dev Returns the claimed rewardr correctly
     */
    function getClaimedReward(
        uint256 _rewardEpoch,
        address _dataProvider,
        address _claimer
    )
        external view
        returns (
            bool _claimed,
            uint256 _amount
        )
    {
    }

    /**
     * @dev Returns the reward epoch to expire next correctly
     */
    function getRewardEpochToExpireNext() external view returns (uint256) {
    }

    /**
     * @dev Returns the reward epoch vote power block correctly
     */
    function getRewardEpochVotePowerBlock(uint256 _rewardEpoch) external view returns (uint256) {
    }

    /**
     * @inheritdoc IFtsoRewardManager
     */
    function getCurrentRewardEpoch() external view returns (uint256) {
        return rewardManager.getCurrentRewardEpochId();
    }

    /**
     * @inheritdoc IFtsoRewardManager
     */
    function getInitialRewardEpoch() external view returns (uint256 _initialRewardEpoch) {
        return rewardManager.getInitialRewardEpochId();
    }

    /**
     * @inheritdoc IFtsoRewardManager
     * @dev Deprecated
     */
    function claimRewardFromDataProviders(
        address payable,
        uint256[] calldata,
        address[] calldata
    )
        external pure returns (uint256)
    {
        // return 0
    }

    /**
     * @inheritdoc IFtsoRewardManager
     * @dev Deprecated
     */
    function claimFromDataProviders(
        address,
        address payable,
        uint256[] calldata,
        address[] calldata,
        bool
    )
        external pure returns (uint256)
    {
        // return 0
    }

    /**
     * @inheritdoc IFtsoRewardManager
     * @dev Deprecated - reverts
     */
    function autoClaim(address[] calldata, uint256) external pure {
        revert(""not supported, use RewardManager"");
    }

    /**
     * @inheritdoc IFtsoRewardManager
     * @dev Deprecated - reverts
     */
    function setDataProviderFeePercentage(uint256)
        external pure
        returns (uint256)
    {
        revert(""not supported, use WNatDelegationFee"");
    }

    /**
     * @dev Deprecated - returns empty array, empty array, false
     */
    function getStateOfRewardsFromDataProviders(
        address,
        uint256,
        address[] calldata
    )
        external pure
        returns (
            uint256[] memory,
            bool[] memory,
            bool
        )
    {
    }

    /**
     * Deprecated - returns 0, 0
     */
    function getDataProviderPerformanceInfo(
        uint256,
        address
    )
        external pure
        returns (
            uint256,
            uint256
        )
    {
    }

```

</details>

## Usable existing interfaces

| **Interface**                                                                 | **Description**                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| ----------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| [`FlareContractRegistry`](/network/solidity-reference/IFlareContractRegistry) | Provides access to the addresses of all essential contracts within the Flare ecosystem. It is deployed at a fixed address across all networks, with updates to addresses managed through governance. This registry is the recommended entry point for contract interactions on all Flare networks. For easier use, consider utilizing the `ContractLibrary` from the [flare-periphery-contracts](https://www.npmjs.com/package/@flarenetwork/flare-periphery-contracts?activeTab=readme) package, which wraps the IFlareContractRegistry and simplifies interactions with Flare's smart contracts. |
| [`FeeCalculator`](/ftso/solidity-reference/IFeeCalculator)                    | On-chain prices are now subject to potential fees, though initial fees are set to `0`. The `FeeCalculator` contract is designed to be flexible, allowing for the introduction of fees in future use cases. It calculates fees for accessing data using the `calculateFeeByIds` and `calculateFeeByIndices` methods. To stay prepared for future updates to the fee structure, it is advisable to use the FeeCalculator contract in relevant applications.                                                                                                                                          |

## Example migration contract

<CodeBlock language=""solidity"" title=""FtsoV2MigrationExample.sol"">
  {FtsoV2MigrationExample}
</CodeBlock>",2025-03-08 01:27:14
2-feeds.mdx,"slug: feeds
title: Block-Latency Feeds
description: FTSOv2's block-latency feeds update incrementally with each new block on Flare, approximately every 1.8 seconds.
keywords:
  [ftso, oracle, flare-time-series-oracle, flare-network, feeds, block-latency]","import FeedExplanation from ""./_feed_explanation.mdx"";
import NewGithubIssue from ""@site/src/components/newGithubIssue"";
import TabItem from ""@theme/TabItem"";
import Tabs from ""@theme/Tabs"";
import CodeBlock from ""@theme/CodeBlock"";
import BlockLatencyFeeds from ""@site/src/components/DataTables/BlockLatencyFeeds"";

FTSOv2's block-latency feeds update incrementally with each new block on Flare, approximately every 1.8 seconds. Every feed leverages Flare's network of 100 independent data providers. These feeds primarily support cryptocurrency price data and are free to query on Flare, enabling decentralized applications to access up-to-date information without incurring additional costs.

Each block-latency feed is uniquely identified by an ID composed of three components in a structured encoding process:

1. **Category:** Indicates the type of asset - Crypto: `01`, Forex: `02`, Commodity: `03`, Stock: `04`

2. **Hex-Encoded Feed Name:** The name of the feed is converted to a hexadecimal format.

3. **Zero Padding:** The combined category and hex-encoded feed name are padded with zeros to a length of 21 bytes.

The resulting string is then prefixed with `0x`.

<FeedExplanation />

:::warning

- Feed IDs are **not** addresses. They are `bytes21` structured encodings that combine the category and feed name to ensure each feed has a unique identifier.
- **Do not** hardcode the number of decimals for a feed in your smart contract, as these can change as the feed value changes. You can use either of the following solutions:
  - Check the number of decimal places every query ([`getFeedById`](/ftso/solidity-reference/FtsoV2Interface#getfeedbyid)).
  - Use the feed value in Wei ([`getFeedByIdInWei`](/ftso/solidity-reference/FtsoV2Interface#getfeedbyidinwei)).

:::

<BlockLatencyFeeds />

## Need more feeds?

FTSOv2 can scale up to 1000 feeds. If you need additional FTSOv2 feeds beyond what is currently available, you can raise a New Feed Request Issue on GitHub. When a feed request is submitted, it is reviewed by the FTSO Management Group, which is comprised of the FTSO data providers as outlined in [FIP.08](https://proposals.flare.network/FIP/FIP_8.html#222-through-the-ftso-management-group).

{/* prettier-ignore */}
<NewGithubIssue issueType=""feed_request"">Request New Feed</NewGithubIssue>
<br></br>

:::tip[What's next?]

[Build your first FTSOv2 app](/ftso/guides/build-first-app) using Foundry, or [read feeds offchain](/ftso/guides/read-feeds-offchain) in languages like JavaScript, Python, Rust, and Go.

:::",2025-03-08 01:27:14
_feed_explanation.mdx,,"import CodeBlock from ""@theme/CodeBlock"";
import TabItem from ""@theme/TabItem"";
import Tabs from ""@theme/Tabs"";
import GetFeedIdSol from ""!!raw-loader!/examples/developer-hub-solidity/GetFeedId.sol"";
import GetFeedIdPy from ""!!raw-loader!/examples/developer-hub-python/get_feed_id.py"";
import GetFeedIdJS from ""!!raw-loader!/examples/developer-hub-javascript/get_feed_id.js"";
import GetFeedIdRs from ""!!raw-loader!/examples/developer-hub-rust/src/bin/get_feed_id.rs"";
import GetFeedIdGo from ""!!raw-loader!/examples/developer-hub-go/get_feed_id.go"";

<details>
    <summary>Example of the structured encoding process.</summary>

    Taking the feed name `FLR/USD`:

    - **Category**: `01` (Crypto)
    - **Hex-Encoded Feed Name**: `464c522f555344` (hexadecimal representation of `FLR/USD`)
    - **Zero Padding**: The category and hex-encoded feed name combined and padded: `01464c522f55534400000000000000000000000000`
    - **Final ID**: Adding the `0x` prefix results in `0x01464c522f55534400000000000000000000000000`

    <Tabs block>
        <TabItem value=""Solidity"" label=""Solidity"" default>

            <CodeBlock language=""solidity"" title=""GetFeedId.sol"">
                {GetFeedIdSol}
            </CodeBlock>

        </TabItem>
        <TabItem value=""Javascript"" label=""Javascript"">

            <CodeBlock language=""javascript"" title=""get_feed_id.js"">
                {GetFeedIdJS}
            </CodeBlock>

        </TabItem>
        <TabItem value=""Python"" label=""Python"">

            <CodeBlock language=""python"" title=""get_feed_id.py"">
                {GetFeedIdPy}
            </CodeBlock>

        </TabItem>
        <TabItem value=""Rust"" label=""Rust"">

            <CodeBlock language=""rust"" title=""get_feed_id.rs"">
                {GetFeedIdRs}
            </CodeBlock>

        </TabItem>
        <TabItem value=""Go"" label=""Go"">

            <CodeBlock language=""go"" title=""get_feed_id.go"">
                {GetFeedIdGo}
            </CodeBlock>

        </TabItem>
    </Tabs>

</details>

<details>
<summary>üö¶ Understanding feed risks.</summary>

When building applications, developers must carefully evaluate the quality of the data they use. As a developer, you are responsible for identifying and assessing the accuracy, availability, and overall quality of the data you choose to integrate. It is important to understand that all data feeds carry inherent risks.

The table below categorizes feeds into three risk levels based on their market integrity, ranging from lowest to highest, a feed is assigned a higher risk level if it fails to meet **all** the criteria required for classification within a lower risk level:

| **Aspect**                  | üü¢ **Low Risk**                           | üü° **Medium Risk**                          | üî¥ **High Risk**                                       |
| --------------------------- | ----------------------------------------- | ------------------------------------------- | ------------------------------------------------------ |
| **Intrinsic Volatility**    | Low, stable price trends                  | Moderate price fluctuations                 | High, frequent price swings                            |
| **Liquidity Variation**     | Abundant and consistent                   | Sufficient but variable                     | Limited and inconsistent                               |
| **Liquidity Concentration** | Broad and well-distributed across venues  | Somewhat concentrated                       | Highly concentrated in a few sources                   |
| **Asset Spread Risk**       | Tight spreads, minimal bid-ask gaps       | Moderate spreads, acceptable bid-ask gaps   | Wide spreads, significant bid-ask gaps                 |
| **Cross Rate Risk**         | Low correlation, direct pricing available | Moderate correlation, indirect pricing used | High correlation, dependent on multiple intermediaries |

**Other risk categories:**

- ‚ö´ **New Feed**
  New tokens lack historical data for proper risk assessment and stable price discovery.
  Users must recognize these assets carry higher volatility risks and verify feed reliability independently.
  After a monitoring period, feeds will be assigned risk levels or potentially discontinued.

Each feed undergoes a rigorous assessment process prior to deployment. The evaluation criteria may vary depending on the specific type of feed being implemented and can evolve over time as our understanding of market integrity risks improves.

</details>
",2025-03-08 01:27:14
IFeeCalculator.md,"title: IFeeCalculator
description: Interface for calculating block-latency feed fees.
sidebar_position: 2","Interface for calculating block-latency feed fees.

Sourced from `IFeeCalculator.sol` on [GitHub](https://github.com/flare-foundation/flare-smart-contracts-v2/blob/main/contracts/userInterfaces/IFeeCalculator.sol).

## Functions

### calculateFeeByIds

Calculates a fee that needs to be paid to fetch feeds' data.

```solidity
function calculateFeeByIds(
    bytes21[] _feedIds
) external view returns (
    uint256 _fee
);
```

#### Parameters

- `_feedIds`: List of feed ids.",2025-03-08 01:27:14
IFastUpdatesConfiguration.md,"title: IFastUpdatesConfiguration
sidebar_position: 5
description: Interface for the block-latency feed configuration.","Interface for the block-latency feed configuration.

Sourced from `IFastUpdatesConfiguration.sol` on [GitHub](https://github.com/flare-foundation/flare-smart-contracts-v2/blob/main/contracts/userInterfaces/IFastUpdatesConfiguration.sol).

## Functions

### getFeedConfigurations

Returns the feed configurations, including removed ones.

```solidity
function getFeedConfigurations(
) external view returns (
    struct IFastUpdatesConfiguration.FeedConfiguration[]
);
```

### getFeedId

Returns the feed id at a given index. Removed (unused) feed index will return bytes21(0).

```solidity
function getFeedId(
    uint256 _index
) external view returns (
    bytes21 _feedId
);
```

#### Parameters

- `_index`: The index.

#### Returns

- `_feedId`: The feed id.

### getFeedIds

Returns all feed ids. For removed (unused) feed indices, the feed id will be bytes21(0).

```solidity
function getFeedIds(
) external view returns (
    bytes21[]
);
```

### getFeedIndex

Returns the index of a feed.

```solidity
function getFeedIndex(
    bytes21 _feedId
) external view returns (
    uint256 _index
);
```

#### Parameters

- `_feedId`: The feed id.

#### Returns

- `_index`: The index of the feed.

### getNumberOfFeeds

Returns the number of feeds, including removed ones.

```solidity
function getNumberOfFeeds(
) external view returns (
    uint256
);
```

### getUnusedIndices

Returns the unused indices - indices of removed feeds.

```solidity
function getUnusedIndices(
) external view returns (
    uint256[]
);
```

## Events

### FeedAdded

Event emitted when a feed is added.

```solidity
event FeedAdded(
    bytes21 feedId,
    uint32 rewardBandValue,
    uint24 inflationShare,
    uint256 index
)
```

### FeedRemoved

Event emitted when a feed is removed.

```solidity
event FeedRemoved(
    bytes21 feedId,
    uint256 index
)
```

### FeedUpdated

Event emitted when a feed is updated.

```solidity
event FeedUpdated(
    bytes21 feedId,
    uint32 rewardBandValue,
    uint24 inflationShare,
    uint256 index
)
```

## Structures

### FeedConfiguration

The feed configuration struct.

```solidity
struct FeedConfiguration {
  bytes21 feedId;
  uint32 rewardBandValue;
  uint24 inflationShare;
}
```",2025-03-08 01:27:14
IFtsoFeedIdConverter.md,"title: IFtsoFeedIdConverter
description: Interface for converting feed names to feed ids.
sidebar_position: 3","Interface for converting feed names to feed ids.

Sourced from `IFtsoFeedIdConverter.sol` on [GitHub](https://github.com/flare-foundation/flare-smart-contracts-v2/blob/main/contracts/userInterfaces/IFtsoFeedIdConverter.sol).

## Functions

### getFeedCategoryAndName

Returns the feed category and name for given feed id.

```solidity
function getFeedCategoryAndName(
    bytes21 _feedId
) external pure returns (
    uint8 _category,
    string _name
);
```

#### Parameters

- `_feedId`: Feed id.

#### Returns

- `_category`: Feed category.
- `_name`: Feed name.

### getFeedId

Returns the feed id for given category and name.

```solidity
function getFeedId(
    uint8 _category,
    string _name
) external view returns (
    bytes21
);
```

#### Parameters

- `_category`: Feed category.
- `_name`: Feed name.

#### Returns

- ``: Feed id.",2025-03-08 01:27:14
IFastUpdateIncentiveManager.md,"title: IFastUpdateIncentiveManager
sidebar_position: 6
description: Interface for making volatility incentive offers.","Interface for making volatility incentive offers.

Sourced from `IFastUpdateIncentiveManager.sol` on [GitHub](https://github.com/flare-foundation/flare-smart-contracts-v2/blob/main/contracts/userInterfaces/IFastUpdateIncentiveManager.sol).

## Functions

### getBaseScale

Viewer for the base value of the scale itself.

```solidity
function getBaseScale(
) external view returns (
    Scale
);
```

### getCurrentSampleSizeIncreasePrice

Viewer for the current value of sample size increase price.

```solidity
function getCurrentSampleSizeIncreasePrice(
) external view returns (
    Fee
);
```

### getExpectedSampleSize

Viewer for the current value of the expected sample size.

```solidity
function getExpectedSampleSize(
) external view returns (
    SampleSize
);
```

### getIncentiveDuration

```solidity
function getIncentiveDuration(
) external view returns (
    uint256
);
```

### getPrecision

Viewer for the current value of the unit delta's precision (the fractional part of the scale).

```solidity
function getPrecision(
) external view returns (
    Precision
);
```

### getRange

Viewer for the current value of the per-block variation range.

```solidity
function getRange(
) external view returns (
    Range
);
```

### getScale

Viewer for the current value of the scale itself.

```solidity
function getScale(
) external view returns (
    Scale
);
```

### offerIncentive

The entry point for third parties to make incentive offers. It accepts a payment and, using the contents of
`_offer`, computes how much the expected sample size will be increased to apply the requested (but capped) range
increase. If the ultimate value of the range exceeds the cap, funds are returned to the sender in proportion to
the amount by which the increase is adjusted to reach the cap.

```solidity
function offerIncentive(
    struct IFastUpdateIncentiveManager.IncentiveOffer _offer
) external payable;
```

#### Parameters

- `_offer`: The requested amount of per-block variation range increase, along with a cap for the ultimate range.

### rangeIncreaseLimit

The maximum value that the range can be increased to by an incentive offer.

```solidity
function rangeIncreaseLimit(
) external view returns (
    Range
);
```

### rangeIncreasePrice

The price for increasing the per-block range of variation by 1, prorated for the actual amount of increase.

```solidity
function rangeIncreasePrice(
) external view returns (
    Fee
);
```

### sampleIncreaseLimit

The maximum amount by which the expected sample size can be increased by an incentive offer.
This is controlled by governance and forces a minimum cost to increasing the sample size greatly,
which would otherwise be an attack on the protocol.

```solidity
function sampleIncreaseLimit(
) external view returns (
    SampleSize
);
```

## Events

### IncentiveOffered

Event emitted when an incentive is offered.

```solidity
event IncentiveOffered(
    uint24 rewardEpochId,
    Range rangeIncrease,
    SampleSize sampleSizeIncrease,
    Fee offerAmount
)
```

### InflationRewardsOffered

Event emitted when inflation rewards are offered.

```solidity
event InflationRewardsOffered(
    uint24 rewardEpochId,
    struct IFastUpdatesConfiguration.FeedConfiguration[] feedConfigurations,
    uint256 amount
)
```

## Structures

### IncentiveOffer

Incentive offer structure.

```solidity
struct IncentiveOffer {
  Range rangeIncrease;
  Range rangeLimit;
}
```",2025-03-08 01:27:14
IFastUpdater.md,"title: IFastUpdater
sidebar_position: 4
description: Interface for updating block-latency feeds.","Interface for updating block-latency feeds.

Sourced from `IFastUpdater.sol` on [GitHub](https://github.com/flare-foundation/flare-smart-contracts-v2/blob/main/contracts/userInterfaces/IFastUpdater.sol).

## Functions

### blockScoreCutoff

Informational getter concerning the eligibility criterion for being chosen by sortition in a given block.

```solidity
function blockScoreCutoff(
    uint256 _blockNum
) external view returns (
    uint256 _cutoff
);
```

#### Parameters

- `_blockNum`: The block for which the cutoff is requested.

#### Returns

- `_cutoff`: The upper endpoint of the acceptable range of ""scores"" that providers generate for sortition. A score below the cutoff indicates eligibility to submit updates in the present sortition round.

### currentRewardEpochId

Id of the current reward epoch.

```solidity
function currentRewardEpochId(
) external view returns (
    uint24
);
```

### currentScoreCutoff

Informational getter concerning the eligibility criterion for being chosen by sortition.

```solidity
function currentScoreCutoff(
) external view returns (
    uint256 _cutoff
);
```

#### Returns

- `_cutoff`: The upper endpoint of the acceptable range of ""scores"" that providers generate for sortition. A score below the cutoff indicates eligibility to submit updates in the present sortition round.

### currentSortitionWeight

Informational getter concerning a provider's likelihood of being chosen by sortition.

```solidity
function currentSortitionWeight(
    address _signingPolicyAddress
) external view returns (
    uint256 _weight
);
```

#### Parameters

- `_signingPolicyAddress`: The signing policy address of the specified provider. This is different from the sender of an update transaction, due to the signature included in the `FastUpdates` type.

#### Returns

- `_weight`: The specified provider's weight for sortition purposes. This is derived from the provider's delegation weight for the FTSO, but rescaled against a fixed number of ""virtual providers"", indicating how many potential updates a single provider may make in a sortition round.

### fetchAllCurrentFeeds

Public access to the stored data of all feeds.

```solidity
function fetchAllCurrentFeeds(
) external view returns (
    bytes21[] _feedIds,
    uint256[] _feeds,
    int8[] _decimals,
    uint64 _timestamp
);
```

#### Returns

- `_feedIds`: The list of feed ids.
- `_feeds`: The list of feeds.
- `_decimals`: The list of decimal places for feeds.
- `_timestamp`: The timestamp of the last update.

### fetchCurrentFeeds

Public access to the stored data of each feed, allowing controlled batch access to the lengthy complete data.
Feeds should be sorted for better performance.

```solidity
function fetchCurrentFeeds(
    uint256[] _indices
) external view returns (
    uint256[] _feeds,
    int8[] _decimals,
    uint64 _timestamp
);
```

#### Parameters

- `_indices`: Index numbers of the feeds for which data should be returned, corresponding to `feedIds` in the `FastUpdatesConfiguration` contract.

#### Returns

- `_feeds`: The list of data for the requested feeds, in the same order as the feed indices were given (which may not be their sorted order).
- `_decimals`: The list of decimal places for the requested feeds, in the same order as the feed indices were given (which may not be their sorted order).
- `_timestamp`: The timestamp of the last update.

### numberOfUpdates

The number of updates submitted in each block for the last `_historySize` blocks (up to `MAX_BLOCKS_HISTORY`).

```solidity
function numberOfUpdates(
    uint256 _historySize
) external view returns (
    uint256[] _noOfUpdates
);
```

#### Parameters

- `_historySize`: The number of blocks for which the number of updates should be returned.

#### Returns

- `_noOfUpdates`: The number of updates submitted in each block for the last `_historySize` blocks. The array is ordered from the current block to the oldest block.

### numberOfUpdatesInBlock

The number of updates submitted in a block - available only for the last `MAX_BLOCKS_HISTORY` blocks.

```solidity
function numberOfUpdatesInBlock(
    uint256 _blockNumber
) external view returns (
    uint256 _noOfUpdates
);
```

#### Parameters

- `_blockNumber`: The block number for which the number of updates should be returned.

#### Returns

- `_noOfUpdates`: The number of updates submitted in the specified block.

### submissionWindow

The submission window is a number of blocks forming a ""grace period"" after a round of sortition starts,
during which providers may submit updates for that round. In other words, each block starts a new round of
sortition and that round lasts `submissionWindow` blocks.

```solidity
function submissionWindow(
) external view returns (
    uint8
);
```

### submitUpdates

The entry point for providers to submit an update transaction.

```solidity
function submitUpdates(
    struct IFastUpdater.FastUpdates _updates
) external;
```

#### Parameters

- `_updates`: Data of an update transaction, which in addition to the actual list of updates, includes the sortition credential proving the provider's eligibility to make updates in the also-included sortition round, as well as a signature allowing a single registered provider to submit from multiple EVM accounts.

## Events

### FastUpdateFeedRemoved

Event emitted when a feed is removed.

```solidity
event FastUpdateFeedRemoved(
    uint256 index
)
```

### FastUpdateFeedReset

Event emitted when a feed is added or reset.

```solidity
event FastUpdateFeedReset(
    uint256 votingRoundId,
    uint256 index,
    bytes21 id,
    uint256 value,
    int8 decimals
)
```

### FastUpdateFeeds

Event emitted at the start of a new voting epoch - current feeds' values and decimals.

```solidity
event FastUpdateFeeds(
    uint256 votingEpochId,
    uint256[] feeds,
    int8[] decimals
)
```

### FastUpdateFeedsSubmitted

Event emitted when a new set of updates is submitted.

```solidity
event FastUpdateFeedsSubmitted(
    uint32 votingRoundId,
    address signingPolicyAddress
)
```

## Structures

### FastUpdates

Fast update structure

```solidity
struct FastUpdates {
  uint256 sortitionBlock;
  struct SortitionCredential sortitionCredential;
  bytes deltas;
  struct IFastUpdater.Signature signature;
}
```

### Signature

Signature structure

```solidity
struct Signature {
  uint8 v;
  bytes32 r;
  bytes32 s;
}
```",2025-03-08 01:27:14
FtsoV2Interface.md,"title: FtsoV2Interface
sidebar_position: 1
description: Primary interface for interacting with FTSOv2.","import Remix from ""@site/src/components/remix"";
import CodeBlock from ""@theme/CodeBlock"";
import FTSOV2FeedById from ""!!raw-loader!/examples/developer-hub-solidity/FTSOV2FeedById.sol"";
import FTSOV2FeedByIdWei from ""!!raw-loader!/examples/developer-hub-solidity/FTSOV2FeedByIdWei.sol"";
import FTSOV2FeedsById from ""!!raw-loader!/examples/developer-hub-solidity/FTSOV2FeedsById.sol"";
import FTSOV2FeedsByIdWei from ""!!raw-loader!/examples/developer-hub-solidity/FTSOV2FeedsByIdWei.sol"";
import FTSOV2VerifyProof from ""!!raw-loader!/examples/developer-hub-solidity/FTSOV2VerifyProof.sol"";

Primary interface for interacting with FTSOv2. This is a long-term support (LTS) interface, designed to ensure continuity even as underlying contracts evolve or protocols migrate to new versions.

Sourced from `FtsoV2Interface.sol` on [GitHub](https://github.com/flare-foundation/flare-smart-contracts-v2/blob/main/contracts/userInterfaces/LTS/FtsoV2Interface.sol).

## Functions

### getFeedById

Returns stored data of a feed.
A fee (calculated by the FeeCalculator contract) may need to be paid.

```solidity
function getFeedById(
    bytes21 _feedId
) external payable returns (
    uint256 _value,
    int8 _decimals,
    uint64 _timestamp
);
```

#### Parameters

- `_feedId`: The id of the feed.

#### Returns

- `_value`: The value for the requested feed.
- `_decimals`: The decimal places for the requested feed.
- `_timestamp`: The timestamp of the last update.

<details>
<summary>Sample contract usage</summary>

<CodeBlock language=""solidity"" title=""FTSOV2FeedById.sol"">
  {FTSOV2FeedById}
</CodeBlock>

</details>

<Remix fileName=""FTSOV2FeedById.sol"">Open sample in Remix</Remix>

### getFeedByIdInWei

Returns value in wei and timestamp of a feed.
A fee (calculated by the FeeCalculator contract) may need to be paid.

```solidity
function getFeedByIdInWei(
    bytes21 _feedId
) external payable returns (
    uint256 _value,
    uint64 _timestamp
);
```

#### Parameters

- `_feedId`: The id of the feed.

#### Returns

- `_value`: The value for the requested feed in wei (i.e. with 18 decimal places).
- `_timestamp`: The timestamp of the last update.

<details>
<summary>Sample contract usage</summary>

<CodeBlock language=""solidity"" title=""FTSOV2FeedByIdWei.sol"">
  {FTSOV2FeedByIdWei}
</CodeBlock>

</details>

<Remix fileName=""FTSOV2FeedByIdWei.sol"">Open sample in Remix</Remix>

### getFeedsById

Returns stored data of each feed.
A fee (calculated by the FeeCalculator contract) may need to be paid.

```solidity
function getFeedsById(
    bytes21[] _feedIds
) external payable returns (
    uint256[] _values,
    int8[] _decimals,
    uint64 _timestamp
);
```

#### Parameters

- `_feedIds`: The list of feed ids.

#### Returns

- `_values`: The list of values for the requested feeds.
- `_decimals`: The list of decimal places for the requested feeds.
- `_timestamp`: The timestamp of the last update.

<details>
<summary>Sample contract usage</summary>

<CodeBlock language=""solidity"" title=""FTSOV2FeedsById.sol"">
  {FTSOV2FeedsById}
</CodeBlock>

</details>

<Remix fileName=""FTSOV2FeedsById.sol"">Open sample in Remix</Remix>

### getFeedsByIdInWei

Returns value of each feed and a timestamp.
For some feeds, a fee (calculated by the FeeCalculator contract) may need to be paid.

```solidity
function getFeedsByIdInWei(
    bytes21[] _feedIds
) external payable returns (
    uint256[] _values,
    uint64 _timestamp
);
```

#### Parameters

- `_feedIds`: Ids of the feeds.

#### Returns

- `_values`: The list of values for the requested feeds in wei (i.e. with 18 decimal places).
- `_timestamp`: The timestamp of the last update.

<details>
<summary>Sample contract usage</summary>

<CodeBlock language=""solidity"" title=""FTSOV2FeedsByIdWei.sol"">
  {FTSOV2FeedsByIdWei}
</CodeBlock>

</details>

<Remix fileName=""FTSOV2FeedsByIdWei.sol"">Open sample in Remix</Remix>

### verifyFeedData

Checks if the feed data is valid (i.e. is part of the confirmed Merkle tree).

```solidity
function verifyFeedData(
    struct FtsoV2Interface.FeedDataWithProof _feedData
) external view returns (
    bool
);
```

#### Parameters

- `_feedData`: Structure containing data about the feed (FeedData structure) and Merkle proof.

#### Returns

- `_0`: true if the feed data is valid.

<details>
<summary>Sample contract usage</summary>

<CodeBlock language=""solidity"" title=""FTSOV2VerifyProof.sol"">
  {FTSOV2VerifyProof}
</CodeBlock>

</details>

<Remix fileName=""FTSOV2VerifyProof.sol"">Open sample in Remix</Remix>

## Structures

### FeedData

Feed data structure

```solidity
struct FeedData {
  uint32 votingRoundId;
  bytes21 id;
  int32 value;
  uint16 turnoutBIPS;
  int8 decimals;
}
```

### FeedDataWithProof

Feed data with proof structure

```solidity
struct FeedDataWithProof {
    bytes32[] proof;
    struct FtsoV2Interface.FeedData body;
}
```",2025-03-08 01:27:14
4-solidity-reference.mdx,"title: Scaling Reference
description: Solidity reference for Scaling smart contracts.
keywords:
  [
    solidity,
    reference,
    ftso,
    flare-time-series-oracle,
    flare-network,
    smart-contracts,
  ]","import Tabs from ""@theme/Tabs"";
import TabItem from ""@theme/TabItem"";
import DocCardList from ""@theme/DocCardList"";

## Deployed Contracts

<Tabs block>
  <TabItem value=""flare"" label=""Flare Mainnet"" default>
  
    | **Contract**                | **Address**                                                                                                              | **ABI**                                                                                                                                                             |
    | --------------------------- | ------------------------------------------------------------------------------------------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
    | FtsoFeedPublisher           | [`0x91fe21970754FAf858B976DC93c3Aa2cE7848571`](https://flarescan.com/address/0x91fe21970754FAf858B976DC93c3Aa2cE7848571) | [ABI](https://api.routescan.io/v2/network/mainnet/evm/14/etherscan/api?module=contract&action=getabi&address=0x91fe21970754FAf858B976DC93c3Aa2cE7848571&format=raw) |
    | FtsoInflationConfigurations | [`0xc8f3BBFbAb36838a80789CF116B8cF827430E6c7`](https://flarescan.com/address/0xc8f3BBFbAb36838a80789CF116B8cF827430E6c7) | [ABI](https://api.routescan.io/v2/network/mainnet/evm/14/etherscan/api?module=contract&action=getabi&address=0xc8f3BBFbAb36838a80789CF116B8cF827430E6c7&format=raw) |
    | FtsoRewardOffersManager     | [`0x244EA7f173895968128D5847Df2C75B1460ac685`](https://flarescan.com/address/0x244EA7f173895968128D5847Df2C75B1460ac685) | [ABI](https://api.routescan.io/v2/network/mainnet/evm/14/etherscan/api?module=contract&action=getabi&address=0x244EA7f173895968128D5847Df2C75B1460ac685&format=raw) |

  </TabItem>
  <TabItem value=""coston2"" label=""Flare Testnet Coston2"">

    | **Contract**                | **Address**                                                                                                                              | **ABI**                                                                                                                                                              |
    | --------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
    | FtsoFeedPublisher           | [`0x4fEcE851632C2A88519bE4C92eA238bbE71D882D`](https://coston2.testnet.flarescan.com/address/0x4fEcE851632C2A88519bE4C92eA238bbE71D882D) | [ABI](https://api.routescan.io/v2/network/testnet/evm/114/etherscan/api?module=contract&action=getabi&address=0x4fEcE851632C2A88519bE4C92eA238bbE71D882D&format=raw) |
    | FtsoInflationConfigurations | [`0x14Cf71e1a73e22B1ef9b47d85eC492259D8C3C81`](https://coston2.testnet.flarescan.com/address/0x14Cf71e1a73e22B1ef9b47d85eC492259D8C3C81) | [ABI](https://api.routescan.io/v2/network/testnet/evm/114/etherscan/api?module=contract&action=getabi&address=0x14Cf71e1a73e22B1ef9b47d85eC492259D8C3C81&format=raw) |
    | FtsoRewardOffersManager     | [`0x1b7ffab226b66b5eCBdC79a42287BC09C05bCb33`](https://coston2.testnet.flarescan.com/address/0x1b7ffab226b66b5eCBdC79a42287BC09C05bCb33) | [ABI](https://api.routescan.io/v2/network/testnet/evm/114/etherscan/api?module=contract&action=getabi&address=0x1b7ffab226b66b5eCBdC79a42287BC09C05bCb33&format=raw) |

  </TabItem>
  <TabItem value=""songbird"" label=""Songbird Canary-Network"">

    | **Contract**                | **Address**                                                                                                                       | **ABI**                                                                                                                                                             |
    | --------------------------- | --------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
    | FtsoFeedPublisher           | [`0xD29D1AE96c5D505Bcf886d38C9DC0358b326E458`](https://songbird.flarescan.com/address/0xD29D1AE96c5D505Bcf886d38C9DC0358b326E458) | [ABI](https://api.routescan.io/v2/network/mainnet/evm/19/etherscan/api?module=contract&action=getabi&address=0xD29D1AE96c5D505Bcf886d38C9DC0358b326E458&format=raw) |
    | FtsoInflationConfigurations | [`0xedCC74C6Dac98abB2F658D8cF6112D6B53B0E78D`](https://songbird.flarescan.com/address/0xedCC74C6Dac98abB2F658D8cF6112D6B53B0E78D) | [ABI](https://api.routescan.io/v2/network/mainnet/evm/19/etherscan/api?module=contract&action=getabi&address=0xedCC74C6Dac98abB2F658D8cF6112D6B53B0E78D&format=raw) |
    | FtsoRewardOffersManager     | [`0x5aB9cB258a342001C4663D9526A1c54cCcF8C545`](https://songbird.flarescan.com/address/0x5aB9cB258a342001C4663D9526A1c54cCcF8C545) | [ABI](https://api.routescan.io/v2/network/mainnet/evm/19/etherscan/api?module=contract&action=getabi&address=0x5aB9cB258a342001C4663D9526A1c54cCcF8C545&format=raw) |

  </TabItem>
  <TabItem value=""coston"" label=""Songbird Testnet Coston"">

    | **Contract**                | **Address**                                                                                                                             | **ABI**                                                                                                                                                             |
    | --------------------------- | --------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
    | FtsoFeedPublisher           | [`0x595AbCc4f9330b30ca31966dFfF71EBE0Af2b820`](https://coston.testnet.flarescan.com/address/0x595AbCc4f9330b30ca31966dFfF71EBE0Af2b820) | [ABI](https://api.routescan.io/v2/network/testnet/evm/16/etherscan/api?module=contract&action=getabi&address=0x595AbCc4f9330b30ca31966dFfF71EBE0Af2b820&format=raw) |
    | FtsoInflationConfigurations | [`0x4f634084483dE74cd4b69007fdF1DaeCC7354991`](https://coston.testnet.flarescan.com/address/0x4f634084483dE74cd4b69007fdF1DaeCC7354991) | [ABI](https://api.routescan.io/v2/network/testnet/evm/16/etherscan/api?module=contract&action=getabi&address=0x4f634084483dE74cd4b69007fdF1DaeCC7354991&format=raw) |
    | FtsoRewardOffersManager     | [`0xC9534cB913150aD3e98D792857689B55e2404212`](https://coston.testnet.flarescan.com/address/0xC9534cB913150aD3e98D792857689B55e2404212) | [ABI](https://api.routescan.io/v2/network/testnet/evm/16/etherscan/api?module=contract&action=getabi&address=0xC9534cB913150aD3e98D792857689B55e2404212&format=raw) |

  </TabItem>

</Tabs>

## Interfaces

<DocCardList />",2025-03-08 01:27:14
2-getting-started.mdx,"sidebar_position: 2
title: Getting Started
description: Learn how to consume Scaling feeds on Flare.
keywords:
  [
    ftso,
    oracle,
    flare-time-series-oracle,
    flare-network,
    smart-contracts,
    solidity,
  ]","import CodeBlock from ""@theme/CodeBlock"";
import TabItem from ""@theme/TabItem"";
import Tabs from ""@theme/Tabs"";
import Remix from ""@site/src/components/remix"";
import FetchAnchorFeedsJs from ""!!raw-loader!/examples/developer-hub-javascript/fetch_anchor_feeds.js"";
import FetchAnchorFeedsPy from ""!!raw-loader!/examples/developer-hub-python/fetch_anchor_feeds.py"";
import FetchAnchorFeedsGo from ""!!raw-loader!/examples/developer-hub-go/flare/fetch_anchor_feeds.go"";
import FetchAnchorFeedsRs from ""!!raw-loader!/examples/developer-hub-rust/src/bin/fetch_anchor_feeds.rs"";
import FetchAndVerifyAnchorOnchainJs from ""!!raw-loader!/examples/developer-hub-javascript/fetch_and_verify_anchor_onchain.js"";
import FetchAndVerifyAnchorOnchainPy from ""!!raw-loader!/examples/developer-hub-python/fetch_and_verify_anchor_onchain.py"";
import FetchAndVerifyAnchorOnchainRs from ""!!raw-loader!/examples/developer-hub-rust/src/bin/fetch_and_verify_anchor_onchain.rs"";
import FetchAndVerifyAnchorOnchainGo from ""!!raw-loader!/examples/developer-hub-go/flare/fetch_and_verify_anchor_onchain.go"";
import FtsoV2AnchorFeedConsumer from ""!!raw-loader!/examples/developer-hub-solidity/FtsoV2AnchorFeedConsumer.sol"";

Scaling enables offchain access to anchor feeds by leveraging Flare's network of 100 independent data providers and a robust commit-reveal process every 90 seconds.

To read anchor feeds on Flare, follow these key steps:

1. **Fetch anchor feed data offchain:**

   Use the Data Availability (DA) Layer API to retrieve anchor feeds and their associated cryptographic proofs.

2. **Verify the proof onchain:**

   Validate the provided proof onchain to ensure the data matches the finalized version committed by [Scaling](/ftso/scaling/overview).

3. **Use the feed data onchain:**

   After verification, integrate the feed data into your onchain application logic.

Scaling only stores **commitments to feed data** onchain. Complete feed data resides offchain but can be verified against an onchain Merkle root, ensuring data integrity and tamper resistance.

## DA Layer API URLs

:::warning[Rate limits]

The public DA Layer endpoints are rate-limited. To request an API key for higher limits, create an [API Key Request Issue](https://github.com/flare-foundation/developer-hub/issues/new/choose).

:::

The DA Layer provides API endpoints for querying offchain data from Flare protocols.

| Network                 | Base URL                                       |
| ----------------------- | ---------------------------------------------- |
| Flare Mainnet           | `https://flr-data-availability.flare.network/` |
| Songbird Canary-Network | `https://sgb-data-availability.flare.network/` |

All networks have the same API structure. For a full list of endpoints see [Data Availability API Reference](/fdc/reference/data-availability-api).

## Fetching anchor feed data

The DA Layer API allows querying values and proofs for multiple feeds from the same voting epoch in a single request. Use the `anchor-feeds-with-proof` POST endpoint to retrieve pricing data.

To fetch the feed values for FLR/USD, BTC/USD, and ETH/USD at the latest voting round, use the following command:

<Tabs>
  <TabItem value=""curl"" label=""curl"" default>

    ```bash
    curl -X 'POST' \
      'https://flr-data-availability.flare.network/api/v0/ftso/anchor-feeds-with-proof' \
      -H 'accept: application/json' \
      -H 'Content-Type: application/json' \
      -d '{
      ""feed_ids"": [
        ""0x01464c522f55534400000000000000000000000000"",
        ""0x014254432f55534400000000000000000000000000"",
        ""0x014554482f55534400000000000000000000000000""
      ]
    }'
    ```

  </TabItem>
  <TabItem value=""javascript"" label=""Javascript"">

    <CodeBlock language=""javascript"" title=""fetch_anchor_feeds.js"">
      {FetchAnchorFeedsJs}
    </CodeBlock>

  </TabItem>
  <TabItem value=""python"" label=""Python"">

    <CodeBlock language=""python"" title=""fetch_anchor_feeds.py"">
      {FetchAnchorFeedsPy}
    </CodeBlock>

  </TabItem>
  <TabItem value=""go"" label=""Go"">

    <CodeBlock language=""go"" title=""fetch_anchor_feeds.go"">
      {FetchAnchorFeedsGo}
    </CodeBlock>

  </TabItem>
  <TabItem value=""rust"" label=""Rust"">

    <CodeBlock language=""Rust"" title=""fetch_anchor_feeds.rs"">
      {FetchAnchorFeedsRs}
    </CodeBlock>

  </TabItem>
</Tabs>

#### API response structure

The response contains JSON objects for each feed, with the following fields:

- `votingRoundId`: The voting round ID (each round lasts 90 seconds; see the [Flare Systems Explorer](https://flare-systems-explorer.flare.network/voting-epoch)).
- `id`: The feed ID (refer to the [list of anchor feeds](/ftso/scaling/anchor-feeds)).
- `value`: The integer value of the feed.
- `turnoutBIPS`: The percentage of voting weight (in basis points) that contributed to the finalized value.
- `decimals`: The number of decimal places for the feed.
- `proof`: The Merkle proof array for data verification.

#### Example Response (for BTC/USD)

```json
[
  {
    ""body"": {
      ""votingRoundId"": 823386,
      ""id"": ""0x014254432f55534400000000000000000000000000"",
      ""value"": 9837867,
      ""turnoutBIPS"": 9442,
      ""decimals"": 2
    },
    ""proof"": [
      ""0x79b8a56bf66ae571ed4c0e3e1317825277c43f5ca3b5a85b834fb6407de03b63"",
      ""...additional proof hashes...""
    ]
  }
]
```

The floating point value of a feed can be calculated by dividing the `value` by 10^`decimals`. For example, if the feed value of BTC/USD is `6900420` and the decimal is `2`, the floating point feed value is `69004.20`.

### Fetching Timestamps

The `ftso/anchor-feeds-with-proof` endpoint returns a `votingRoundId`. Each voting round lasts for a fixed duration of **90 seconds**. To determine the **starting timestamp**, use the `fsp/status` GET endpoint:

```bash
curl -X 'GET' \
  'https://flr-data-availability.flare.network/api/v0/fsp/status' \
  -H 'accept: application/json'
```

:::warning

- The timestamps returned correspond to the **start** of the voting round, which lasts for **90 seconds**.
- Prices for a given voting round are finalized at the **end** of the round, calculated as `start_timestamp + 90s`.
  :::

#### Example Response

```json
{
  ""active"": {
    ""voting_round_id"": 839641,
    ""start_timestamp"": 1733997690
  },
  ""latest_fdc"": {
    ""voting_round_id"": -1,
    ""start_timestamp"": -1
  },
  ""latest_ftso"": {
    ""voting_round_id"": 839640,
    ""start_timestamp"": 1733997600
  }
}
```

The response indicates that:

- The **currently active voting round** has `voting_round_id` [839641](https://flare-systems-explorer.flare.network/voting-epoch/839641), which **started at** `1733997690`.
- The **most recently finalized FTSO voting round** has `voting_round_id` [839640](https://flare-systems-explorer.flare.network/voting-epoch/839640), which **started at** `1733997600`.

## Verifying proof onchain

To verify feed data onchain, use the [`FtsoV2Interface`](/ftso/solidity-reference/FtsoV2Interface). This interface offers the [`verifyFeedData`](/ftso/solidity-reference/FtsoV2Interface#verifyfeeddata) method to validate feed data and proof against the onchain Merkle root.
The function requires a single input struct [`FeedDataWithProof`](/ftso/solidity-reference/FtsoV2Interface#feeddatawithproof), which includes the feed data and voting round ID within the [`FeedData`](/ftso/solidity-reference/FtsoV2Interface#feeddata) struct, and a Merkle proof.

An example contract verifying and consuming anchor feeds onchain

<CodeBlock language=""solidity"" title=""FtsoV2AnchorFeedConsumer.sol"">
  {FtsoV2AnchorFeedConsumer}
</CodeBlock>

{/* prettier-ignore */}
<Remix fileName=""FtsoV2AnchorFeedConsumer.sol"">Open in Remix</Remix>

## Fetching and verifying feeds

The following example shows how to query feed and proof data from DA Layer and submit it to the onchain consumer:

<Tabs>
  <TabItem value=""javascript"" label=""Javascript"" default>

    <CodeBlock language=""javascript"" title=""fetch_and_verify_anchor_onchain.js"">
      {FetchAndVerifyAnchorOnchainJs}
    </CodeBlock>

  </TabItem>
  <TabItem value=""python"" label=""Python"">

    <CodeBlock language=""python"" title=""fetch_and_verify_anchor_onchain.py"">
      {FetchAndVerifyAnchorOnchainPy}
    </CodeBlock>

  </TabItem>
  <TabItem value=""go"" label=""Go"">

    <CodeBlock language=""go"" title=""fetch_and_verify_anchor_onchain.go"">
      {FetchAndVerifyAnchorOnchainGo}
    </CodeBlock>

  </TabItem>
  <TabItem value=""rust"" label=""Rust"">

    <CodeBlock language=""rust"" title=""fetch_and_verify_anchor_onchain.rs"">
      {FetchAndVerifyAnchorOnchainRs}
    </CodeBlock>

  </TabItem>
</Tabs>",2025-03-08 01:27:14
1-overview.mdx,"sidebar_position: 1
slug: overview
title: Scaling
description: Scaling is an advanced framework designed to optimize the functionality and efficiency of FTSOv2.
keywords: [ftso, oracle, flare-time-series-oracle, flare-network]","import ThemedImage from ""@theme/ThemedImage"";
import useBaseUrl from ""@docusaurus/useBaseUrl"";

**Scaling** is an advanced framework designed to optimize the functionality and efficiency of FTSOv2. It operates through data providers who submit feed estimates weighted by their stake in the network. These estimates are processed using a weighted median algorithm to determine consensus feed values. Scaling offers several enhancements:

- Supports up to 1000 data feeds across various asset classes, including equities, commodities, and cryptocurrencies, and offers access to 2 weeks of historical data.

- Uses a commit-reveal process across approximately 100 independent data providers every 90 seconds to ensure data integrity and accuracy.

- Optimizes median value computation and data storage to consume less than 5% of network bandwidth at peak usage.

## Architecture

<ThemedImage
  alt=""Phases of FTSOv2 protocol""
  sources={{
    light: useBaseUrl(""img/ftso-overview/voting_epoch_light.svg""),
    dark: useBaseUrl(""img/ftso-overview/voting_epoch_dark.svg""),
  }}
/>

Each phase of Scaling is designed to ensure a secure, efficient, and fair consensus process. The protocol is structured into four phases:

- **Commit**: Data providers compute and submit data proposals encoded in a commit hash. To maintain security, the actual feed values are not disclosed at this stage.

- **Reveal**: Data providers reveal their data to one another, alongside the random numbers used to generate their commit hash.

- **Sign**: Valid data reveals are used to calculate median values, which are aggregated into an efficient Merkle tree structure and published onchain.

- **Finalization**: Once a sufficient weight of signatures for the same Merkle root is collected, a randomly chosen provider (or any other entity in case of a failure), can collect and submit them onchain for verification.

Once the finalization phase is complete, the Merkle root is published onchain, making it available to all other smart contracts for verification of calculation results. This structured approach not only maintains data integrity and accuracy but also incentivizes active participation from data providers, contributing to the overall efficiency and reliability of Scaling.

:::tip[Interested in learning more?]

For a detailed explanation of the FTSOv2 mechanism, read the [FTSOv2 whitepaper](https://flare.network/wp-content/uploads/FTSOv2-White-Paper.pdf).

:::

### Weighted Median Calculation

The calculation of the weighted median in Scaling is a crucial process for ensuring accurate consensus on feed values from various data providers. This calculation begins once all valid data estimates are collected, which are then sorted in increasing order based on their feed values. Each data estimate is associated with a weight that corresponds to the voting power of the data provider, which is determined by the amount of stake each provider has. This weighted approach ensures that providers with a higher stake have a proportional impact on the final median calculation, alongside facing a stricter economic cost for misbehavior.

The next step involves calculating the total weight, which is the sum of the weights of all valid data submissions. The median threshold is then determined as half of the total weight. This threshold helps identify the point at which the cumulative weight of the sorted data meets or exceeds half of the total weight, indicating the weighted median.

Starting from the smallest data estimate, the weights are accumulated in the order of the sorted estimates. The weighted median is identified as the data estimate at which the cumulative weight first meets or exceeds the median threshold.

<details> 
<summary>An illustrative example clarifying the process</summary>

Suppose we have the following data estimates from five providers with their corresponding weights:

| **Estimate (Feed Value)** | **Weight** |
| ------------------------- | ---------- |
| 250                       | 4          |
| 200                       | 2          |
| 100                       | 1          |
| 150                       | 3          |
| 300                       | 1          |

First, sort these estimates:

| **Estimate (Feed Value)** | **Weight** |
| ------------------------- | ---------- |
| 100                       | 1          |
| 150                       | 3          |
| 200                       | 2          |
| 250                       | 4          |
| 300                       | 1          |

Calculate the total weight: $W = 1 + 3 + 2 + 4 + 1 = 11$.

The median threshold $ M $ is $ \frac{W}{2} = 5.5 $.

Accumulate the weights:

- For 100: Cumulative weight = 1
- For 150: Cumulative weight = 1 + 3 = 4
- For 200: Cumulative weight = 4 + 2 = 6

At this point, the cumulative weight (6) exceeds the median threshold (5.5). Therefore, the weighted median is 200.

</details>

This weighted median calculation ensures that the consensus feed value reflects the most influential estimates, balancing the data based on the providers' voting power. This method is designed to be robust against outliers and manipulation, ensuring a fair and reliable consensus process.

### Incentivization Mechanism

The incentivization mechanism in Scaling is designed to ensure active and accurate participation from data providers while maintaining the integrity of the data submission process. The protocol divides the total reward pool for each voting epoch into three main categories: median closeness rewards, signature rewards, and finalization rewards.

Rewards are calculated by comparing data submissions to the median value. Providers whose submissions fall within the interquartile range (IQR) band are eligible for median closeness rewards. If a submission is on the boundary of the IQR band, a pseudo-random selection process determines inclusion. Additional reward bands, which are defined by Flare governance and have a fixed percentage around the finalized value, further refine the distribution, ensuring fair and accurate reward allocation.

Penalties are imposed for non-matching or omitted reveals to maintain data integrity. Providers with mismatched or missing reveals face reduced rewards or even negative cumulative rewards, making them non-claimable. The protocol also evaluates the quality of random numbers generated during reveals, penalizing omissions to prevent manipulation.

Inflation reward offers, triggered automatically for certain supported feeds, and community reward offers, submitted by any entity before a reward epoch, provide continuous and flexible incentivization. These mechanisms, managed by specific smart contracts, ensure that both common and less frequent feeds are adequately rewarded, promoting a balanced and effective participation from data providers. This comprehensive incentivization scheme encourages honest and active participation, ensuring Scaling's efficiency and reliability.",2025-03-08 01:27:14
3-anchor-feeds.mdx,"sidebar_position: 3
slug: anchor-feeds
title: Anchor Feeds
description: Scaling anchor feeds update every voting epoch on Flare, approximately every 90s.
keywords: [ftso, oracle, flare-time-series-oracle, flare-network, feeds]","import AnchorFeeds from ""@site/src/components/DataTables/AnchorFeeds"";
import FeedExplanation from ""../_feed_explanation.mdx"";

Scaling's anchor feeds update every 90 seconds with each new voting epoch on Flare. These feeds, accessible offchain, support various asset classes including equities, commodities, and cryptocurrencies.

Each anchor feed is uniquely identified by an ID composed of three components in a structured encoding process:

1. **Category:** Indicates the type of asset:

   - Crypto: `01`
   - Forex: `02`
   - Commodity: `03`
   - Stock: `04`

2. **Hex-Encoded Feed Name:** The name of the feed is converted to a hexadecimal format.

3. **Zero Padding:** The combined category and hex-encoded feed name are padded with zeros to a length of 21 bytes.

The resulting string is then prefixed with `0x`.

<FeedExplanation />

:::warning

Feed IDs are not addresses. They are `bytes21` structured encodings that combine the category and feed name to ensure each feed has a unique identifier.

:::

<AnchorFeeds />",2025-03-08 01:27:14
IFtsoFeedPublisher.md,title: IFtsoFeedPublisher,"FtsoFeedPublisher interface.
Sourced from `IFtsoFeedPublisher.sol` on [GitHub](https://github.com/flare-foundation/flare-smart-contracts-v2/blob/main/contracts/userInterfaces/IFtsoFeedPublisher.sol).

## Functions

### feedsHistorySize

The size of the feeds history.

```solidity
function feedsHistorySize(
) external view returns (
    uint256
);
```

### ftsoProtocolId

The FTSO protocol id.

```solidity
function ftsoProtocolId(
) external view returns (
    uint8
);
```

### getCurrentFeed

Returns the current feed.

```solidity
function getCurrentFeed(
    bytes21 _feedId
) external view returns (
    struct IFtsoFeedPublisher.Feed
);
```

#### Parameters

- `_feedId`: Feed id.

### getFeed

Returns the feed for given voting round id.

```solidity
function getFeed(
    bytes21 _feedId,
    uint256 _votingRoundId
) external view returns (
    struct IFtsoFeedPublisher.Feed
);
```

#### Parameters

- `_feedId`: Feed id.
- `_votingRoundId`: Voting round id.

### publish

Publishes feeds.

```solidity
function publish(
    struct IFtsoFeedPublisher.FeedWithProof[] _proofs
) external;
```

#### Parameters

- `_proofs`: The FTSO feeds with proofs to publish.

## Events

### FtsoFeedPublished

Event emitted when a new feed is published.

```solidity
event FtsoFeedPublished(
    uint32 votingRoundId,
    bytes21 id,
    int32 value,
    uint16 turnoutBIPS,
    int8 decimals
)
```

## Structures

### Feed

The FTSO feed struct.

```solidity
struct Feed {
  uint32 votingRoundId;
  bytes21 id;
  int32 value;
  uint16 turnoutBIPS;
  int8 decimals;
}
```

### FeedWithProof

The FTSO feed with proof struct.

```solidity
struct FeedWithProof {
  bytes32[] merkleProof;
  struct IFtsoFeedPublisher.Feed body;
}
```

### Random

The FTSO random struct.

```solidity
struct Random {
  uint32 votingRoundId;
  uint256 value;
  bool isSecure;
}
```",2025-03-08 01:27:14
IFtsoInflationConfigurations.md,title: IFtsoInflationConfigurations,"FtsoInflationConfigurations interface.
Sourced from `IFtsoInflationConfigurations.sol` on [GitHub](https://github.com/flare-foundation/flare-smart-contracts-v2/blob/main/contracts/userInterfaces/IFtsoInflationConfigurations.sol).

## Functions

### getFtsoConfiguration

Returns the FTSO configuration at `_index`.

```solidity
function getFtsoConfiguration(
    uint256 _index
) external view returns (
    struct IFtsoInflationConfigurations.FtsoConfiguration
);
```

#### Parameters

- `_index`: The index of the FTSO configuration.

### getFtsoConfigurations

Returns the FTSO configurations.

```solidity
function getFtsoConfigurations(
) external view returns (
    struct IFtsoInflationConfigurations.FtsoConfiguration[]
);
```

## Structures

### FtsoConfiguration

The FTSO configuration struct.

```solidity
struct FtsoConfiguration {
  bytes feedIds;
  uint24 inflationShare;
  uint16 minRewardedTurnoutBIPS;
  uint24 primaryBandRewardSharePPM;
  bytes secondaryBandWidthPPMs;
  uint16 mode;
}
```",2025-03-08 01:27:14
IFtsoRewardOffersManager.md,title: IFtsoRewardOffersManager,"FtsoRewardOffersManager interface.
Sourced from `IFtsoRewardOffersManager.sol` on [GitHub](https://github.com/flare-foundation/flare-smart-contracts-v2/blob/main/contracts/userInterfaces/IFtsoRewardOffersManager.sol).

## Functions

### minimalRewardsOfferValueWei

Minimal rewards offer value (in wei).

```solidity
function minimalRewardsOfferValueWei(
) external view returns (
    uint256
);
```

### offerRewards

Allows community to offer rewards.

```solidity
function offerRewards(
    uint24 _nextRewardEpochId,
    struct IFtsoRewardOffersManager.Offer[] _offers
) external payable;
```

#### Parameters

- `_nextRewardEpochId`: The next reward epoch id.
- `_offers`: The list of offers.

## Events

### InflationRewardsOffered

Event emitted when inflation rewards are offered.

```solidity
event InflationRewardsOffered(
    uint24 rewardEpochId,
    bytes feedIds,
    bytes decimals,
    uint256 amount,
    uint16 minRewardedTurnoutBIPS,
    uint24 primaryBandRewardSharePPM,
    bytes secondaryBandWidthPPMs,
    uint16 mode
)
```

### MinimalRewardsOfferValueSet

Event emitted when the minimal rewards offer value is set.

```solidity
event MinimalRewardsOfferValueSet(
    uint256 valueWei
)
```

### RewardsOffered

Event emitted when a reward offer is received.

```solidity
event RewardsOffered(
    uint24 rewardEpochId,
    bytes21 feedId,
    int8 decimals,
    uint256 amount,
    uint16 minRewardedTurnoutBIPS,
    uint24 primaryBandRewardSharePPM,
    uint24 secondaryBandWidthPPM,
    address claimBackAddress
)
```

## Structures

### Offer

Defines a reward offer.

```solidity
struct Offer {
  uint120 amount;
  bytes21 feedId;
  uint16 minRewardedTurnoutBIPS;
  uint24 primaryBandRewardSharePPM;
  uint24 secondaryBandWidthPPM;
  address claimBackAddress;
}
```",2025-03-08 01:27:14
basic-integration.mdx,"title: Basic integration
tags: [ftso]
slug: basic-integration
description: A simple example on how to integrate the core infrastructure of FTSOv2 into your application
sidebar_position: 1
unlisted: true",,2025-03-08 01:27:14
build-first-app.mdx,"title: Build your first FTSOv2 app
tags: [intermediate, ftso, solidity]
slug: build-first-app
description: Use FTSOv2 in your Foundry project.
keywords:
  [
    ftso,
    oracle,
    flare-time-series-oracle,
    flare-network,
    smart-contracts,
    solidity,
    remix,
  ]
sidebar_position: 1","import CodeBlock from ""@theme/CodeBlock"";
import FtsoV2FeedConsumer from ""!!raw-loader!/examples/developer-hub-solidity/FtsoV2FeedConsumer_foundry.sol"";
import FtsoV2FeedConsumerTest from ""!!raw-loader!/examples/developer-hub-solidity/FtsoV2FeedConsumer_foundry.t.sol"";

This guide is for developers who want to build an FTSOv2 application using Foundry. In this guide, you will learn how to:

- Create a contract to read the price of FLR/USD from FTSOv2 using [flare-periphery-contracts](https://www.npmjs.com/package/@flarenetwork/flare-periphery-contracts).

- Compile your contract using Foundry [forge](https://book.getfoundry.sh/reference/forge/).

- Deploy your contract to Flare Testnet Coston2, and interact with it using Foundry [cast](https://book.getfoundry.sh/reference/cast/).

## Prerequisites

Ensure you have the following tools installed:

- [Foundry](https://book.getfoundry.sh/getting-started/installation)
- [Node.js](https://nodejs.org/en/download/)

## Clone the Foundry template

1. Clone the [flare-foundry-starter](https://github.com/flare-foundation/flare-foundry-starter) and navigate into the project directory:

   ```bash
   git clone https://github.com/flare-foundation/flare-foundry-starter.git
   cd flare-foundry-starter
   ```

2. Install the project dependencies:

   ```bash
   forge soldeer install
   ```

3. You might need to modify `remappings.txt` so `/src` paths are read correctly, e.g.:

   ```plaintext title=""remappings.txt""
   @openzeppelin-contracts/=dependencies/@openzeppelin-contracts-5.2.0-rc.1/
   flare-periphery/=dependencies/flare-periphery-0.0.1/
   forge-std/=dependencies/forge-std-1.9.5/src/
   forge-std/=dependencies/forge-std-1.9.5/
   surl/=dependencies/surl-0.0.0/src/
   surl/=dependencies/surl-0.0.0/
   ```

## Create and compile a contract

Now, you can create a contract that consumes data from FTSOv2.

1. Create a contract file `src/FtsoV2FeedConsumer.sol`, and add the following code to it:

   <CodeBlock language=""solidity"" title=""src/FtsoV2FeedConsumer.sol"">
     {FtsoV2FeedConsumer}
   </CodeBlock>

2. Set EVM version to `london` in `foundry.toml`:

   ```toml title=""foundry.toml""
   [profile.default]
   ...
   evm_version = ""london""
   ```

3. To ensure everything is set up correctly, compile the contract by running:

   ```bash
   forge build
   ```

   The output should indicate that the compilation was successful.

   ```plaintext
   [‚†ä] Compiling...
   [‚†É] Compiling 27 files with Solc 0.8.27
   [‚†ä] Solc 0.8.27 finished in 853.78ms
   Compiler run successful!
   ```

## Write tests

Before deploying, it's important to write tests for your contract.

1. Create a test file `test/FtsoV2FeedConsumer.t.sol`, and add the following code:

   <CodeBlock language=""solidity"" title=""test/FtsoV2FeedConsumer.t.sol"">
     {FtsoV2FeedConsumerTest}
   </CodeBlock>

2. Run the tests:

   ```bash
   forge test
   ```

   You should see a successful test result like this:

   ```plaintext
   [‚†ä] Compiling...
   [‚†ò] Compiling 27 files with Solc 0.8.27
   [‚†É] Solc 0.8.27 finished in 797.51ms
   Compiler run successful!

   Ran 2 tests for test/FtsoV2FeedConsumer.t.sol:FtsoV2FeedConsumerTest
   [PASS] testCheckFees() (gas: 21085)
   [PASS] testGetFlrUsdPrice() (gas: 25610)
   Logs:
     msg.value matches fee
     feedValue 150000
     decimals 7
     timestamp 1

   Suite result: ok. 2 passed; 0 failed; 0 skipped; finished in 7.72ms (2.91ms CPU time)

   Ran 1 test suite in 122.65ms (7.72ms CPU time): 2 tests passed, 0 failed, 0 skipped (2 total tests)
   ```

## Deploy and interact with the contract

You can now deploy your contract to Flare Testnet Coston2.

1.  Generate a new wallet using the [cast](https://book.getfoundry.sh/reference/cast/):

    ```bash
    cast wallet new
    ```

    The output will look something like:

    ```plaintext
    Successfully created new keypair.
    Address:     0x3f6BdD26f2AE4e77AcDfA1FA24B2774ed93984B4
    Private key: 0x84cf77b009a92777f75b49864e4166ddcaf8f3f5f119a19b226ab362a0cf7bf5
    ```

2.  Store your wallet details and the RPC URL as environment variables:

    :::danger

    - Never share your private keys.
    - Never put your private keys in source code.
    - Never commit private keys to a Git repository.

    :::

    ```bash
    export ACCOUNT=<address above>
    export ACCOUNT_PRIVATE_KEY=<private key above>
    export RPC_URL=""https://coston2-api.flare.network/ext/C/rpc""
    ```

3.  Use the [Coston2 Faucet](https://faucet.flare.network/coston2) to get some testnet C2FLR tokens. You can verify that the 100 C2FLR has arrived in your wallet:

    ```bash
    cast balance $ACCOUNT -r $RPC_URL -e
    ```

4.  The final step before deploying is to set the constructor arguments with the address of [`FtsoV2`](/ftso/solidity-reference) and [`FeeCalculator`](/ftso/solidity-reference) on Flare Testnet Coston2 and the [feed ID](/ftso/feeds) of FLR/USD:

    ```bash
    export FTSOV2_COSTON2=0x3d893C53D9e8056135C26C8c638B76C8b60Df726
    export FEECALCULATOR_COSTON2=0x88A9315f96c9b5518BBeC58dC6a914e13fAb13e2
    export FLRUSD_FEED_ID=0x01464c522f55534400000000000000000000000000
    ```

    You can now deploy the contract:

    ```bash
    forge create src/FtsoV2FeedConsumer.sol:FtsoV2FeedConsumer --private-key $ACCOUNT_PRIVATE_KEY --rpc-url $RPC_URL --constructor-args $FTSOV2_COSTON2 $FEECALCULATOR_COSTON2 $FLRUSD_FEED_ID
    ```

    If the deployment is successful, the output will display the contract address, save that for later use:

    ```plaintext
    [‚†ä] Compiling...
    [‚†ò] Compiling 24 files with Solc 0.8.27
    [‚†É] Solc 0.8.27 finished in 733.41ms
    Compiler run successful!
    Deployer: 0x3f6BdD26f2AE4e77AcDfA1FA24B2774ed93984B4
    Deployed to: 0x80Ee4091348d9fA4B4A84Eb525c25049EbDa6152
    Transaction hash: 0x38604a643695959dd9fa5547d95610fb0b7393c7e8358079f47ed4bdb53c9a8f
    ```

    ```bash
    export DEPLOYMENT_ADDRESS=<deployed to address above>
    ```

5.  Use `cast` to interact with the contract, note that this command uses the environment variables defined in the sections above.:

    ```bash
    cast send --private-key $ACCOUNT_PRIVATE_KEY --rpc-url $RPC_URL -j --value 0 $DEPLOYMENT_ADDRESS ""getFlrUsdPrice()""
    ```

    <details>

    <summary>Expected output of the command above.</summary>

    ```json
    {
      ""status"": ""0x1"",
      ""cumulativeGasUsed"": ""0x1cbab"",
      ""logs"": [
        {
          ""address"": ""0x1000000000000000000000000000000000000002"",
          ""topics"": [
            ""0xe7aa66356adbd5e839ef210626f6d8f6f72109c17fadf4c4f9ca82b315ae79b4""
          ],
          ""data"": ""0x00000000000000000000000098b8e9b5830f04fe3b8d56a2f8455e337037ba280000000000000000000000000000000000000000000000000000000000004231"",
          ""blockHash"": ""0x94f50404f8205caff551ef2b08d20afc4c080bd7b8231cd3941f1a7a6b1b80dd"",
          ""blockNumber"": ""0xb2b972"",
          ""transactionHash"": ""0x3fdc9cf00456a7878476877b6f8ae5c994dd3c224ca792f965f718340fd98402"",
          ""transactionIndex"": ""0x0"",
          ""logIndex"": ""0x0"",
          ""removed"": false
        },
        {
          ""address"": ""0x1000000000000000000000000000000000000002"",
          ""topics"": [
            ""0xe7aa66356adbd5e839ef210626f6d8f6f72109c17fadf4c4f9ca82b315ae79b4""
          ],
          ""data"": ""0x0000000000000000000000004f52e61907b0ed9f26b88f16b2510a4ca524d6d00000000000000000000000000000000000000000000000000000000000003099"",
          ""blockHash"": ""0x94f50404f8205caff551ef2b08d20afc4c080bd7b8231cd3941f1a7a6b1b80dd"",
          ""blockNumber"": ""0xb2b972"",
          ""transactionHash"": ""0x3fdc9cf00456a7878476877b6f8ae5c994dd3c224ca792f965f718340fd98402"",
          ""transactionIndex"": ""0x0"",
          ""logIndex"": ""0x1"",
          ""removed"": false
        },
        {
          ""address"": ""0x1000000000000000000000000000000000000002"",
          ""topics"": [
            ""0xe7aa66356adbd5e839ef210626f6d8f6f72109c17fadf4c4f9ca82b315ae79b4""
          ],
          ""data"": ""0x000000000000000000000000d2a1bb23eb350814a30dd6f9de78bb2c8fdd9f1d0000000000000000000000000000000000000000000000000000000000003b68"",
          ""blockHash"": ""0x94f50404f8205caff551ef2b08d20afc4c080bd7b8231cd3941f1a7a6b1b80dd"",
          ""blockNumber"": ""0xb2b972"",
          ""transactionHash"": ""0x3fdc9cf00456a7878476877b6f8ae5c994dd3c224ca792f965f718340fd98402"",
          ""transactionIndex"": ""0x0"",
          ""logIndex"": ""0x2"",
          ""removed"": false
        },
        {
          ""address"": ""0x1000000000000000000000000000000000000002"",
          ""topics"": [
            ""0xe7aa66356adbd5e839ef210626f6d8f6f72109c17fadf4c4f9ca82b315ae79b4""
          ],
          ""data"": ""0x0000000000000000000000006892bdbbb14e1c9bd46bf31e7bac94d038fc82a6000000000000000000000000000000000000000000000000000000000000422d"",
          ""blockHash"": ""0x94f50404f8205caff551ef2b08d20afc4c080bd7b8231cd3941f1a7a6b1b80dd"",
          ""blockNumber"": ""0xb2b972"",
          ""transactionHash"": ""0x3fdc9cf00456a7878476877b6f8ae5c994dd3c224ca792f965f718340fd98402"",
          ""transactionIndex"": ""0x0"",
          ""logIndex"": ""0x3"",
          ""removed"": false
        },
        {
          ""address"": ""0x1000000000000000000000000000000000000002"",
          ""topics"": [
            ""0xe7aa66356adbd5e839ef210626f6d8f6f72109c17fadf4c4f9ca82b315ae79b4""
          ],
          ""data"": ""0x000000000000000000000000bd33bdff04c357f7fc019e72d0504c24cf4aa0100000000000000000000000000000000000000000000000000000000000008f11"",
          ""blockHash"": ""0x94f50404f8205caff551ef2b08d20afc4c080bd7b8231cd3941f1a7a6b1b80dd"",
          ""blockNumber"": ""0xb2b972"",
          ""transactionHash"": ""0x3fdc9cf00456a7878476877b6f8ae5c994dd3c224ca792f965f718340fd98402"",
          ""transactionIndex"": ""0x0"",
          ""logIndex"": ""0x4"",
          ""removed"": false
        },
        {
          ""address"": ""0x1000000000000000000000000000000000000002"",
          ""topics"": [
            ""0xe7aa66356adbd5e839ef210626f6d8f6f72109c17fadf4c4f9ca82b315ae79b4""
          ],
          ""data"": ""0x000000000000000000000000a90db6d10f856799b10ef2a77ebcbf460ac71e520000000000000000000000000000000000000000000000000000000000004e9c"",
          ""blockHash"": ""0x94f50404f8205caff551ef2b08d20afc4c080bd7b8231cd3941f1a7a6b1b80dd"",
          ""blockNumber"": ""0xb2b972"",
          ""transactionHash"": ""0x3fdc9cf00456a7878476877b6f8ae5c994dd3c224ca792f965f718340fd98402"",
          ""transactionIndex"": ""0x0"",
          ""logIndex"": ""0x5"",
          ""removed"": false
        },
        {
          ""address"": ""0x1000000000000000000000000000000000000002"",
          ""topics"": [
            ""0xe7aa66356adbd5e839ef210626f6d8f6f72109c17fadf4c4f9ca82b315ae79b4""
          ],
          ""data"": ""0x0000000000000000000000000b162ca3acf3482d3357972e12d794434085d839000000000000000000000000000000000000000000000000000000000000e5a6"",
          ""blockHash"": ""0x94f50404f8205caff551ef2b08d20afc4c080bd7b8231cd3941f1a7a6b1b80dd"",
          ""blockNumber"": ""0xb2b972"",
          ""transactionHash"": ""0x3fdc9cf00456a7878476877b6f8ae5c994dd3c224ca792f965f718340fd98402"",
          ""transactionIndex"": ""0x0"",
          ""logIndex"": ""0x6"",
          ""removed"": false
        }
      ],
      ""logsBloom"": ""0x00020000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000400000000080000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"",
      ""type"": ""0x2"",
      ""transactionHash"": ""0x3fdc9cf00456a7878476877b6f8ae5c994dd3c224ca792f965f718340fd98402"",
      ""transactionIndex"": ""0x0"",
      ""blockHash"": ""0x94f50404f8205caff551ef2b08d20afc4c080bd7b8231cd3941f1a7a6b1b80dd"",
      ""blockNumber"": ""0xb2b972"",
      ""gasUsed"": ""0x1cbab"",
      ""effectiveGasPrice"": ""0x6fc23ac00"",
      ""from"": ""0x3f6bdd26f2ae4e77acdfa1fa24b2774ed93984b4"",
      ""to"": ""0x80ee4091348d9fa4b4a84eb525c25049ebda6152"",
      ""contractAddress"": null
    }
    ```

    </details>

You can see the transaction using the [Coston2 Explorer](https://coston2.testnet.flarescan.com/) by searching for its `transactionHash`.

Congratulations! You've built your first app using FTSOv2.

:::tip[What's next]

Learn how to [read feeds offchain](read-feeds-offchain) using JavaScript, Python, Rust and Go, or learn how to [change quote feed](change-quote-feed) with an onchain Solidity contract.

:::",2025-03-08 01:27:14
make-volatility-incentive.mdx,"title: Make a volatility incentive
tags: [intermediate, ftso, javascript, python, rust, go]
slug: make-volatility-incentive
description: Make a volatility incentive using JS, Python, Rust, or Go.
keywords:
  [
    javascript,
    python,
    rust,
    go,
    ftso,
    oracle,
    flare-time-series-oracle,
    flare-network,
  ]
sidebar_position: 5","import TabItem from ""@theme/TabItem"";
import Tabs from ""@theme/Tabs"";
import CodeBlock from ""@theme/CodeBlock"";
import VolIncentiveWeb3Js from ""!!raw-loader!/examples/developer-hub-javascript/volatility_incentive_coston2_web3.js"";
import VolIncentiveEthersJs from ""!!raw-loader!/examples/developer-hub-javascript/volatility_incentive_coston2_ethers.js"";
import VolIncentiveWeb3Py from ""!!raw-loader!/examples/developer-hub-python/volatility_incentive_coston2.py"";
import VolIncentiveRust from ""!!raw-loader!/examples/developer-hub-rust/src/bin/volatility_incentive_coston2.rs"";
import VolIncentiveGo from ""!!raw-loader!/examples/developer-hub-go/coston2/volatility_incentive.go"";

:::info

Before reading this guide, make sure you understand [FTSOv2's Volatility Incentive Mechanism](/ftso/overview#volatility-incentive-mechanism).

:::

This guide provides code examples demonstrating how to make an FTSOv2 volatility incentive offer using various programming languages. To make a volatility incentive offer, you need three key pieces of information:

1. **RPC Endpoint URL:** The RPC Endpoint URL determines which network your code will interact with. You can use a node provider service or point to your [own RPC node](/run-node/rpc-node). A comprehensive list of public and private RPC endpoints for all Flare networks is available on the [Network Configuration](/network/overview#configuration) page.

2. **Contract Address:** The address for the `FastUpdateIncentiveManager` contract varies by network. You can obtain this address in two ways:

   - **From the Solidity Reference page:** Find the `FastUpdateIncentiveManager` address for each network on the [Solidity Reference](/ftso/solidity-reference) page.

   **OR**

   - **Query the FlareContractRegistry Contract:** The `FlareContractRegistry` contract has the same address across all networks. You can query it to get the `FastUpdateIncentiveManager` contract address. Refer to the specific language guides for examples:
     - [JavaScript](/network/guides/flare-for-javascript-developers#make-query)
     - [Python](/network/guides/flare-for-python-developers#make-query)
     - [Rust](/network/guides/flare-for-rust-developers#make-query)
     - [Go](/network/guides/flare-for-go-developers#make-query)

3. **Cost of Increasing the Sample Size:** FTSOv2 allows you to increase the sample size, i.e., the expected number of providers who can submit a block-latency feed update. The cost for this increases dynamically with the expected sample size. A single volatility incentive lasts for a period of 8 blocks.

:::tip

All examples in this guide are available at [developer-hub/examples](https://github.com/flare-foundation/developer-hub/tree/main/examples).

:::

<Tabs block>
  <TabItem value=""web3js"" label=""web3.js"" default>

    This example uses [web3.js](https://github.com/web3/web3.js) to make an FTSOv2 volatility incentive offer on Flare Testnet Coston2.

    <CodeBlock language=""javascript"" title=""volatility_incentive.js"">
        {VolIncentiveWeb3Js}
    </CodeBlock>

  </TabItem>
  <TabItem value=""ethersjs"" label=""ethers.js"">

    This example uses [ethers.js](https://github.com/ethers-io/ethers.js/) to make an FTSOv2 volatility incentive offer on Flare Testnet Coston2.

    <CodeBlock language=""javascript"" title=""volatility_incentive.js"">
        {VolIncentiveEthersJs}
    </CodeBlock>

  </TabItem>
  <TabItem value=""web3py"" label=""web3.py"">

    This example uses [web3.py](https://github.com/ethereum/web3.py) to make an FTSOv2 volatility incentive offer on Flare Testnet Coston2.

    <CodeBlock language=""python"" title=""volatility_incentive.py"">
        {VolIncentiveWeb3Py}
    </CodeBlock>

  </TabItem>
  <TabItem value=""alloyrs"" label=""alloy-rs"">

    This example uses [alloy-rs](https://github.com/ethereum/web3.py) to make an FTSOv2 volatility incentive offer on Flare Testnet Coston2.

    ```bash
    cargo add alloy eyre tokio --features alloy/full,tokio/rt,tokio/rt-multi-thread,tokio/macros
    ```

    <CodeBlock language=""rust"" title=""volatility_incentive.rs"">
        {VolIncentiveRust}
    </CodeBlock>

  </TabItem>
  <TabItem value=""goethereum"" label=""go-ethereum"">

    This example uses the Go API from [Geth](https://geth.ethereum.org) to make an FTSOv2 volatility incentive offer on Flare Testnet Coston2.

    ```bash
    go get github.com/ethereum/go-ethereum/ethclient
    go get github.com/ethereum/go-ethereum/accounts
    ```

    The project structure should look like:

    ```plaintext
    developer-hub-go/
    ‚îú‚îÄ‚îÄ coston2/
    ‚îÇ   ‚îî‚îÄ‚îÄ *.go
    ‚îú‚îÄ‚îÄ flare/
    ‚îÇ   ‚îî‚îÄ‚îÄ *.go
    ‚îú‚îÄ‚îÄ main.go
    ‚îú‚îÄ‚îÄ go.mod
    ‚îî‚îÄ‚îÄ go.sum
    ```

    With Go, you need to manually fetch the contract's ABI and generate the Go bindings. Copy the [FastUpdatesIncentiveManager ABI](https://api.routescan.io/v2/network/testnet/evm/114/etherscan/api?module=contract&action=getabi&address=0x003e9bD18f73e0B25BED0DC8382Bde6aa999525c&format=raw) and paste it into a file named `FastUpdatesIncentiveManager.abi`, located in the root of your project, i.e. same level as `go.mod`. Then using [abigen](https://geth.ethereum.org/docs/tools/abigen), generate the Go bindings.

    ```bash
    abigen --abi FastUpdatesIncentiveManager.abi --pkg coston2 --type FastUpdatesIncentiveManager --out coston2/FastUpdatesIncentiveManager.go
    ```

    <CodeBlock language=""go"" title=""coston2/volatility_incentive.go"">
        {VolIncentiveGo}
    </CodeBlock>

  </TabItem>
</Tabs>",2025-03-08 01:27:14
read-feeds-offchain.mdx,"title: Read feeds offchain
tags: [intermediate, ftso, python, rust, javascript, go]
slug: read-feeds-offchain
description: Read block-latency feeds using JS, Python, Rust, or Go.
keywords:
  [
    javascript,
    python,
    rust,
    go,
    ftso,
    oracle,
    flare-time-series-oracle,
    flare-network,
  ]
sidebar_position: 2","import TabItem from ""@theme/TabItem"";
import Tabs from ""@theme/Tabs"";
import CodeBlock from ""@theme/CodeBlock"";
import ReadOffhainEthersJs from ""!!raw-loader!/examples/developer-hub-javascript/ftsov2_consumer_coston2_ethers.js"";
import ReadOffhainWeb3Js from ""!!raw-loader!/examples/developer-hub-javascript/ftsov2_consumer_coston2_web3.js"";
import ReadOffhainWeb3Py from ""!!raw-loader!/examples/developer-hub-python/ftsov2_consumer_coston2.py"";
import ReadOffhainRust from ""!!raw-loader!/examples/developer-hub-rust/src/bin/ftsov2_consumer_coston2.rs"";
import ReadOffhainGo from ""!!raw-loader!/examples/developer-hub-go/ftsov2_consumer_coston2.go"";

This guide provides code examples demonstrating how to read FTSOv2 feeds offchain using various programming languages. To read a block-latency feed offchain, you need three key pieces of information:

1. **RPC Endpoint URL:** The RPC Endpoint URL determines which network your code will interact with. You can use a node provider service or point to your [own RPC node](/run-node/rpc-node). A comprehensive list of public and private RPC endpoints for all Flare networks is available on the [Network Configuration](/network/overview#configuration) page.

2. **Contract Address:** Feeds are served on the `FtsoV2` contract, whose address varies by network. You can obtain this address in two ways:

   - **From the Solidity Reference page:** Find the `FtsoV2` address for each network on the [Solidity Reference](/ftso/solidity-reference) page.

     **OR**

   - **Query the FlareContractRegistry Contract:** The `FlareContractRegistry` contract has the same address across all networks. You can query it to get the `FtsoV2` contract address. Refer to the specific language guides for examples:
     - [JavaScript](/network/guides/flare-for-javascript-developers#make-query)
     - [Python](/network/guides/flare-for-python-developers#make-query)
     - [Rust](/network/guides/flare-for-rust-developers#make-query)
     - [Go](/network/guides/flare-for-go-developers#make-query)

3. **Feed IDs:** The feeds you want to read are uniquely identified by their ID. A list of feed IDs is provided on the [Block-Latency Feeds](/ftso/feeds) page.

:::tip

All examples in this guide are available at [developer-hub/examples](https://github.com/flare-foundation/developer-hub/tree/main/examples).

:::

<Tabs block>
  <TabItem value=""web3js"" label=""web3.js"" default>

    This example uses [web3.js](https://github.com/web3/web3.js) to retrieve FTSOv2 feed data for FLR/USD, BTC/USD, and ETH/USD on Flare Testnet Coston2.

    ```bash
    npm install web3
    ```

    <CodeBlock language=""javascript"" title=""ftsov2_consumer.js"">
      {ReadOffhainWeb3Js}
    </CodeBlock>

  </TabItem>
  <TabItem value=""ethersjs"" label=""ethers.js"">
    This example uses [ethers.js](https://github.com/ethers-io/ethers.js/) to retrieve FTSOv2 feed data for FLR/USD, BTC/USD, and ETH/USD on Flare Testnet Coston2.

    ```bash
    npm install ethers
    ```

    <CodeBlock language=""javascript"" title=""ftsov2_consumer.js"">
      {ReadOffhainEthersJs}
    </CodeBlock>

  </TabItem>
  <TabItem value=""web3py"" label=""web3.py"">

    This example uses [web3.py](https://github.com/ethereum/web3.py) to retrieve FTSOv2 feed values for FLR/USD, BTC/USD, and ETH/USD on Flare Testnet Coston2.

    <Tabs groupId=""python"">
      <TabItem value=""uv"" label=""uv"" default>
        ```bash
        uv add web3
        ```

      </TabItem>
      <TabItem value=""pip"" label=""pip"">
        ```bash
        pip install web3
        ```

      </TabItem>
    </Tabs>

    <CodeBlock language=""python"" title=""ftsov2_consumer.py"">
      {ReadOffhainWeb3Py}
    </CodeBlock>

  </TabItem>
  <TabItem value=""alloyrs"" label=""alloy-rs"">

    This example uses [alloy-rs](https://github.com/alloy-rs) to retrieve FTSOv2 feed data for FLR/USD, BTC/USD, and ETH/USD on Flare Testnet Coston2.

    ```bash
    cargo add alloy eyre tokio --features alloy/full,tokio/rt,tokio/rt-multi-thread,tokio/macros
    ```

    <CodeBlock language=""rust"" title=""ftsov2_consumer.rs"">
      {ReadOffhainRust}
    </CodeBlock>

  </TabItem>
  <TabItem value=""goethereum"" label=""go-ethereum"">

    This example uses the Go API from [Geth](https://geth.ethereum.org) to retrieve FTSOv2 feed data for FLR/USD, BTC/USD, and ETH/USD from Flare Testnet Coston2.

    ```bash
    go get github.com/ethereum/go-ethereum/ethclient
    ```

    With Go, you need to manually fetch the contract's ABI and generate the Go bindings. Copy the [FtsoV2 ABI](/ftso/solidity-reference) and paste it into a file named `FtsoV2.abi`, located in the root of your project, i.e. same level as `go.mod`. Then using [abigen](https://geth.ethereum.org/docs/tools/abigen), generate the Go bindings.

    ```bash
    abigen --abi FtsoV2.abi --pkg main --type FtsoV2 --out FtsoV2.go
    ```

    <CodeBlock language=""go"" title=""ftsov2_consumer.go"">
      {ReadOffhainGo}
    </CodeBlock>

  </TabItem>
</Tabs>",2025-03-08 01:27:14
change-quote-feed.mdx,"title: Change quote feed
tags: [intermediate, ftso, solidity]
slug: change-quote-feed
description: Change block-latency quote feeds using Solidity.
keywords:
  [
    ftso,
    oracle,
    flare-time-series-oracle,
    flare-network,
    smart-contracts,
    solidity,
    remix,
  ]
sidebar_position: 3","import Remix from ""@site/src/components/remix"";
import CodeBlock from ""@theme/CodeBlock"";
import FtsoV2ChangeQuoteFeed from ""!!raw-loader!/examples/developer-hub-solidity/FtsoV2ChangeQuoteFeed.sol"";
import SetEvmVersionRemix from ""/static/img/set-evm-version-remix.png"";

This guide will show you how to fetch the latest feed values for two feeds and convert them to a new quote feed while retaining the number of decimals. For example, if you need the price of `BTC/ETH`, you can fetch the latest feed values for `BTC/USD` and `ETH/USD` and calculate the price of `BTC/ETH = (BTC/USD) / (ETH/USD)`.

<CodeBlock language=""solidity"" title=""FtsoV2ChangeQuoteFeed.sol"">
  {FtsoV2ChangeQuoteFeed}
</CodeBlock>

{/* prettier-ignore */}
<Remix fileName=""FtsoV2ChangeQuoteFeed.sol"">Open in Remix</Remix>
<br></br>

:::warning[Don't use test interfaces in production]

The `TestFtsoV2Interface` is for **testing only**, with all methods as `view` to allow rapid development without gas costs or state changes. For production, use [`FtsoV2Interface`](/ftso/solidity-reference/FtsoV2Interface), which includes `payable` methods required for real transactions and state modifications.
Make the following changes to `FtsoV2ChangeQuoteFeed.sol`:

```solidity
import {ContractRegistry} from ""@flarenetwork/flare-periphery-contracts/coston2/ContractRegistry.sol"";
import {FtsoV2Interface} from ""@flarenetwork/flare-periphery-contracts/coston2/FtsoV2Interface.sol"";

contract FtsoV2ChangeQuoteFeed {
  FtsoV2Interface internal ftsoV2;
  constructor() {
    ftsoV2 = ContractRegistry.getFtsoV2();
  }
  //...
}
```

:::

:::warning[Set EVM Version to London]

- **Using Remix:** Set EVM version to `london` in the **Advanced Configurations** section of the **Solidity Compiler** tab:

  {"" ""}

  <img src={SetEvmVersionRemix} style={{ width: 300 }} />

- **Using Hardhat or Foundry:** Set EVM version to `london` in [hardhat.config.ts](https://github.com/flare-foundation/flare-hardhat-starter/blob/master/hardhat.config.ts#L34) or [foundry.toml](https://github.com/flare-foundation/flare-foundry-starter/blob/master/foundry.toml).

- **Using Standard Solidity JSON:** Set `evmVersion` to `london`:

  ```json
  {
    ""settings"": {
      ""optimizer"": {
        /* ... */
      },
      ""evmVersion"": ""london""
    }
  }
  ```

- **Using `solc` CLI:** Set `--evm-version` to `london`:

  ```bash
  solc --evm-version london <args>
  ```

:::",2025-03-08 01:27:14
query-feed-configuration.mdx,"title: Query feed configuration
tags: [intermediate, ftso, python, rust, javascript, go]
slug: query-feed-configuration
description: Query feed configuration using JS, Python, Rust, or Go.
keywords:
  [
    ftso,
    oracle,
    flare-time-series-oracle,
    flare-network,
    smart-contracts,
    solidity,
    remix,
    metamask,
  ]
sidebar_position: 4","import TabItem from ""@theme/TabItem"";
import Tabs from ""@theme/Tabs"";
import CodeBlock from ""@theme/CodeBlock"";
import FtsoConfigEthersJs from ""!!raw-loader!/examples/developer-hub-javascript/ftsov2_config_coston2_ethers.js"";
import FtsoConfigWeb3Js from ""!!raw-loader!/examples/developer-hub-javascript/ftsov2_config_coston2_web3.js"";
import FtsoConfigWeb3Py from ""!!raw-loader!/examples/developer-hub-python/ftsov2_config_coston2.py"";
import FtsoConfigRust from ""!!raw-loader!/examples/developer-hub-rust/src/bin/ftsov2_config_coston2.rs"";
import FtsoConfigGo from ""!!raw-loader!/examples/developer-hub-go/ftsov2_config_coston2.go"";

This guide provides code examples demonstrating how to read FTSOv2 feed configurations offchain using various programming languages. To achieve this, you need two key pieces of information:

1. **RPC Endpoint URL:** The RPC Endpoint URL determines which network your code will interact with. You can either use a node provider service or point to your [own RPC node](/run-node/rpc-node). A list of public and private RPC endpoints for all Flare networks is available on the [Network Configuration](/network/overview#configuration) page.

2. **Contract Address:** The address for the `FastUpdatesConfiguration` contract varies by network. You can obtain this address in two ways:

   - **From the Solidity Reference page:** Find the `FastUpdatesConfiguration` address for each network on the [Solidity Reference](/ftso/solidity-reference) page.

     **OR**

   - **Query the FlareContractRegistry Contract:** The `FlareContractRegistry` contract has the same address across all networks. You can query it to get the `FastUpdatesConfiguration` contract address. Refer to the specific language guides for examples:
     - [JavaScript](/network/guides/flare-for-javascript-developers#make-query)
     - [Python](/network/guides/flare-for-python-developers#make-query)
     - [Rust](/network/guides/flare-for-rust-developers#make-query)
     - [Go](/network/guides/flare-for-go-developers#make-query)

:::tip

All examples in this guide are available at [developer-hub/examples](https://github.com/flare-foundation/developer-hub/tree/main/examples).

:::

<Tabs block>
  <TabItem value=""web3js"" label=""web3.js"" default>
    This example user [web3.js](https://github.com/web3/web3.js) to retrieve FTSOv2 feed configurations on Flare Testnet Coston2.
    
    ```bash
    npm install web3
    ```

    <CodeBlock language=""javascript"" title=""ftsov2_config.js"">
      {FtsoConfigWeb3Js}
    </CodeBlock>

  </TabItem>
  <TabItem value=""ethersjs"" label=""ethers.js"">
    This example uses [ethers.js](https://github.com/ethers-io/ethers.js/) to retrieve FTSOv2 feed configurations on Flare Testnet Coston2.
    
    ```bash
    npm install ethers
    ```
    
    <CodeBlock language=""javascript"" title=""ftsov2_config.js"">
      {FtsoConfigEthersJs}
    </CodeBlock>

  </TabItem>
  <TabItem value=""web3py"" label=""web3.py"">

    This example uses [web3.py](https://github.com/ethereum/web3.py) to retrieve FTSOv2 feed configurations on Flare Testnet Coston2.

    <Tabs groupId=""python"">
      <TabItem value=""uv"" label=""uv"" default>

        ```bash
        uv add web3
        ```

      </TabItem>
      <TabItem value=""pip"" label=""pip"">

        ```bash
        pip install web3
        ```

      </TabItem>
    </Tabs>

    <CodeBlock language=""python"" title=""ftsov2_config.py"">
      {FtsoConfigWeb3Py}
    </CodeBlock>

  </TabItem>
  <TabItem value=""alloyrs"" label=""alloy-rs"">

    This example uses [alloy-rs](https://github.com/alloy-rs) to retrieve FTSOv2 feed configurations on Flare Testnet Coston2.

    ```bash
    cargo add alloy eyre tokio --features alloy/full,tokio/rt,tokio/rt-multi-thread,tokio/macros
    ```
    <CodeBlock language=""rust"" title=""src/bin/ftsov2_config.rs"">
      {FtsoConfigRust}
    </CodeBlock>

  </TabItem>
  <TabItem value=""goethereum"" label=""go-ethereum"">

    This example uses the Go API from [Geth](https://geth.ethereum.org) to retrieve FTSOv2 feed configurations on Flare Testnet Coston2.

    ```bash
    go get github.com/ethereum/go-ethereum/ethclient
    ```

    With Go, you need to manually fetch the contract's ABI and generate the Go bindings. Copy the [FastUpdatesConfiguration ABI](https://api.routescan.io/v2/network/testnet/evm/114/etherscan/api?module=contract&action=getabi&address=0xE7d1D5D58cAE01a82b84989A931999Cb34A86B14&format=raw) and paste it into a file named `FastUpdatesConfiguration.abi`, located in the root of your project, i.e. same level as `go.mod`. Then using [abigen](https://geth.ethereum.org/docs/tools/abigen), generate the Go bindings.

    ```bash
    abigen --abi FastUpdatesConfiguration.abi --pkg main --type FastUpdatesConfiguration --out FastUpdatesConfiguration.go
    ```

    <CodeBlock language=""go"" title=""ftsov2_config.go"">
      {FtsoConfigGo}
    </CodeBlock>

  </TabItem>
</Tabs>",2025-03-08 01:27:14
2-collateral.mdx,"title: Collateral
description: Understand how collateral works in FAssets.
keywords: [fassets, xrp, bitcoin, dogecoin, flare-network]","import ThemedImage from ""@theme/ThemedImage"";
import useBaseUrl from ""@docusaurus/useBaseUrl"";

FAssets collateral is locked in contracts that ensure the minted FAssets can always be redeemed for the underlying assets they represent or compensated by collateral.
Along with Flare's native token, FLR, any governance approved ERC-20 token on the Flare blockchain can be used as collateral.

FAssets collateral ensures the security and redemption of minted FAssets by locking collateral in smart contracts. This guarantees that FAssets can either be redeemed for their underlying assets or compensated by collateral. Collateral can include Flare's native token (FLR) and any governance-approved ERC-20 tokens on the Flare blockchain.

## Collateral Types

Two primary types of collateral secure FAssets: **Vault Collateral** and **Pool Collateral**.

Vault collateral is provided exclusively by agents and ensures they perform their duties.
Pool collateral is provided by agents and FLR holders who choose to contribute to the pool.
It is a safeguard when a sudden drop in the price of the vault collateral makes it insufficient to back the underlying assets.

### Vault Collateral

Vault collateral consists of the types of collateral chosen by agents to store in their vault.
Flare governance approves the valid types, which are generally stablecoins, such as USDC, USDT, or other highly liquid tokens on the Flare network.

Agents choose one of the types defined by FAssets governance and use it as collateral in their vaults.
Agents cannot switch to a different type after a vault is created, but they can create any number of vaults, with different types.

Each collateral type defines an ERC-20 token to use as collateral, a series of [collateral ratios](#collateral-ratio), and information to retrieve the asset's price from the FTSO system.
Governance reserves the right to add new types or deprecate existing types.
If governance deprecates a type, agents must switch to a supported type.

Each vault is associated with a single, unique address on the underlying chain called the agent's underlying address.
It receives underlying assets when they are minted into FAssets and sends underlying assets to the redeemer's address when they are redeemed.

When an agent creates a vault, the underlying address is checked for validity using the Data Connector.
Otherwise, malicious agents could provide an address that systematically blocks payments and exploit the [minting process](/fassets/minting) to their advantage.

### Pool Collateral

When the price of the vault collateral changes in such a way that the vault collateral cannot fully back all the minted FAssets, a [liquidation](/fassets/liquidation) mechanism ensures enough FAssets are burned to restore balance.
The pool collateral provides an additional source of backing for situations when the price fluctuates too rapidly for liquidations to correct the imbalance.

Pool collateral is always native FLR tokens or SGB tokens on the Songbird network and can be used as an additional source of collateral for [liquidations](/fassets/liquidation) and [failed redemptions](/fassets/redemption#redemption-payment-failure).

Anyone can participate in the FAssets system by providing native tokens to this pool.
In return, providers receive **collateral pool tokens** (CPTs) as proof of the share of native tokens they provided to a specific pool from a specific agent.
CPTs are ERC-20 tokens specific to both an agent and a pool.

Providers can redeem their CPTs for FLR, or even transfer or trade them, after a governance-defined time period has elapsed since they entered the pool.
This **time lock** is necessary to reduce sandwiching attacks.

Additionally, CPT holders are entitled to a share of any fee the agent earns from minting FAssets using this pool as explained in the next section.

<details>
<summary>CPT conversion formulae and examples.</summary>

The amount of collateral pool tokens a provider $p$ receives upon entering a pool is calculated as:

$$
CPT_{p, rec} = \frac{C_{p}}{C_{total}}  \times CPT_{iss}
$$

where:

- $C_{p}$ is the amount of FLR tokens that provider $p$ is adding to the pool.
- $C_{total}$ is the amount of FLR tokens in the pool before adding the new tokens.
- $CPT_{iss}$ is the circulating amount of collateral pool tokens.

When a pool is first created, $CPT_{p, rec} = C_{p}$.

The amount of FLR collateral a provider receives when they redeem their CPT is calculated using the opposite formula:

$$
CPT_{p, rec} = C_{total} \times { CPT_{p, red} \over CPT_{iss} }
$$

where:

- $CPT_{p, red}$ is the amount of CPT the provider is returning to the pool.

---

The following example shows conversion of CPTs.

|                                                                                       | FLR in pool | Issued CPTs |
| ------------------------------------------------------------------------------------- | ----------: | ----------: |
| An agent creates a new vault. The collateral pool is initially empty of FLR and fees. |           0 |           0 |
| Alice deposits 100 FLR and gets 100 CPTs in return.                                   |         100 |         100 |
| Bob deposits 200 FLR and gets 200 CPTs in return.                                     |         300 |         300 |
| Alice redeems 50 CPTs and receives 50 FLR in return.                                  |         250 |         250 |

Note that in general 1 FLR does not always correspond to 1 CPT, because of mechanisms like the [top-up](#top-up), for example.

</details>

## Collateral Ratio

The collateral ratio (CR) is the ratio between the value of all the tokens used as collateral and the total value of the underlying assets held by an agent at any given time.
The agent's vault and the collateral pool each has its own unique collateral ratio, which is constantly changing as the value of the underlying assets and the collateral change.
These values are obtained using the [FTSO](/ftso/overview).

The following example shows vault and pool CR:

:::info[Vault and pool CR]

Assume an amount of FAssets currently valued at \$1000 USD, backed by \$1500 worth of USDC in vault collateral and \$2000 worth of FLR in pool collateral.

The resulting vault CR is: $$ \frac{\text{\$1500}}{\text{\$1000}} = 1.5 $$

The resulting pool CR is: $$ \frac{\text{\$2000}}{\text{\$1000}} = 2 $$

:::

Several thresholds are defined for the collateral ratio, and they are used at different times during the FAsset operations.
Some are set by the system, and others are set by the agent:

### System-Wide Thresholds

The following thresholds are set by the FAssets system's governance and are the same for all agents.

#### Minimal CR

The lowest collateral ratio the agent vault and the collateral pool must maintain so that enough collateral exists to insure the minted FAssets and to compensate for redemption payments that fail. The minimal CR can be different for each type of collateral.

If an agent's CR remains below the minimal CR for longer than a governance-set amount of time, [liquidations](/fassets/liquidation) can start.

#### Liquidation CR

**Liquidation CR**: An agent's position is unhealthy when the agent's vault CR or pool CR fall below their minimal CR.
However, as long as the CR remains above liquidation CR, the CR can briefly fall below the minimal CR.

During this time, the agent can either deposit more collateral or self-close some backed FAssets to improve the position.

However, if the CR falls below the liquidation CR, liquidations can start immediately.

The value of each liquidation CR is approximately 10% less than the minimal CR.

:::info[Example liquidation CR]

Assume the **minimal CR** is 1.4 and the **liquidation CR** is 1.3.

If the agent's vault CR drops below 1.3, the agent's position can be liquidated immediately.
If the agent's vault CR drops below 1.4 but not below 1.3, the agent has some time to amend the position before it can be liquidated.

Adjusted for the collateral pool's minimal CR, the same example applies to the collateral pool.

:::

#### Safety CR

If one or both of the collateral types fall below liquidation CR or below the minimum CR for a longer period of time, liquidation occurs.
When the offending collateral reaches a healthy CR again, the liquidation stops.
To prevent the agent from immediately reverting into liquidation after a small price change, the CR must reach the safety CR before it can start operating normally again and liquidation stops.

Each of the collateral types, the agent's vault and the collateral pool, has its own unique safety CR.

### Agent Thresholds

The following thresholds are set by each agent according to their own preferences.

<ThemedImage
  alt=""FAssets Collateral Ratio""
  sources={{
    light: useBaseUrl(""img/fassets/flare_fassets_collateral_ratio_light.svg""),
    dark: useBaseUrl(""img/fassets/flare_fassets_collateral_ratio_dark.svg""),
  }}
/>

#### Minting CR

For each mint done by an agent, the maximum amount allowed to be minted is calculated so that the CR for the agent's vault and the CR for the agent's collateral pool after the mint remain higher than the minting CR for each collateral type.
To reduce the threat of liquidation, agents should set the minting CR well above the minimal CR to accommodate price fluctuations that might occur before the CR falls below the minimal CR after the mint and minting is no longer possible.

#### Exit CR

After a user redeems CPTs, the pool CR must be more than the exit CR. If the pool CR is already below the exit CR, redemption cannot occur.
The exit CR is for the collateral pool only.

#### Top-up CR

To incentivize healthy collateral pools, if the pool CR falls below the top-up CR, anyone can add collateral to the pool and receive [CPTs](#pool-collateral) at a reduced price. This [top-up mechanism](#top-up) decreases the likelihood of liquidations because of a low amount of pool collateral.

## Minting Fees and Debt

As part of the minting process, users pay a [minting fee](/fassets/minting#fees) on the underlying chain.
The agent's share of this fee remains on the underlying chain, whereas the pool's share triggers the minting of an equivalent amount of FAssets on the Flare network.

These FAssets coming from the minting fee are added to the collateral pool, where they are shared between collateral providers in proportion to the amount of CPTs that providers have.
At any time, providers can claim their due share of the fees in the pool.
When providers exit the collateral pool by redeeming their CPTs, any remaining unclaimed fee is automatically transferred to them.

Providers are naturally only entitled to the minting fees accrued after they entered the pool.
Therefore, providers entering a pool with preexisting fees are assigned a **fee debt**.
The amount of fees a provider can actually withdraw from the pool is calculated by first subtracting their debt from the total amount of fees in the pool.
In this way, the amount of fees that a provider can withdraw upon entering a pool is exactly zero.

A provider's fee debt:

| Increases when the provider                 | Decreases when the provider                    |
| ------------------------------------------- | ---------------------------------------------- |
| Enters a pool which already has fees in it. | Exits the pool, partially or completely.       |
| Withdraws FAsset fees.                      | Deposits FAssets, paying off part of the debt. |

It is worth noting that:

- When a provider withdraws fees, their debt increases by the same amount.
- Since CPTs are ERC-20 tokens, a secondary market for them is expected to develop.
  If CPTs become more valuable than the FAsset fees they represent, returning the FAssets and paying off part of their fee debt might be more lucrative for providers.

<details>
<summary>Fee entitlement formulae and examples.</summary>

The following formulas consider all the above information to calculate each provider's due share of FAsset minting fees.

The amount of debt a provider $p$ is assigned upon entering a pool is calculated as:

$$
fee\_debt_p = { added\_collateral_p \over collateral\_in\_pool } \times fees\_in\_pool
$$

where:

- $added\_collateral_p$ is the amount of FLR tokens that provider $p$ is adding to the pool.
- $collateral\_in\_pool$ is the amount of FLR tokens in the pool before adding the new tokens.
- $fees\_in\_pool$ is the amount of FAsset minting fees currently in the pool.

The following formulas are based on the concept of **virtual fees**, which are the fees that a provider would be entitled to if they had no fee debt.

The **total virtual fees** is the sum of all provider's virtual fees and can be expressed as:

$$
total\_virtual\_fees = fees\_in\_pool + total\_fee\_debt
$$

where:

- $total\_fee\_debt$ is the sum of the fee debt held by all providers $= \sum_p fee\_debt_p$

Then, the virtual fees due to a provider $p$, i.e., the amount of FAsset minting fees they would be entitled to if they had no debt, are:

$$
virtual\_fees_p = { CPT_p \over currently\_issued\_CPT } \times total\_virtual\_fees
$$

where:

- $CPT_p$ is the amount of CPTs provider $p$ holds.
- $currently\_issued\_CPT$ is the circulating amount of CPTs.

Finally, the amount of fees from the pool that a provider $p$ is free to withdraw at any given time is:

$$
free\_fees_p = virtual\_fees_p - fee\_debt_p
$$

where:

- $fee\_debt_p$ is the amount of fee debt that provider $p$ holds.

---

The following example shows fee entitlement.

|                                                                       | FLR in pool | Fees in pool | Total fee debt | Total virtual fees |
| --------------------------------------------------------------------- | ----------: | -----------: | -------------: | -----------------: |
| An agent creates a new vault.                                         |           0 |            0 |              0 |                  0 |
| Alice deposits 100 FLR and gets 100 CPTs in return.                   |     **100** |            0 |              0 |                  0 |
| 10 FAssets of fees are added to the pool due to a mint.               |         100 |       **10** |              0 |             **10** |
| Bob deposits 100 FLR and gets 100s CPT in return.                     |     **200** |           10 |         **10** |             **20** |
| 10 more FAssets of fees are added to the pool due to another mint.    |         200 |       **20** |             10 |             **30** |
| Alice withdraws 10 FAssets of fees.                                   |         200 |       **10** |         **20** |                 30 |
| Bob exits the pool by returning the 100 CPTs and withdrawing 100 FLR. |     **100** |        **5** |         **10** |             **15** |

After step **4**, Bob is not entitled to any of the fees in the pool:

- Bob is assigned an initial fee debt of 10 FAssets, according to the $fee\_debt_p$ formula in the box above.
- As a result, the total virtual fees are increased to 20 FAssets. 10 of them are in fees, and 10 of them are in debt.
- Each user now holds half the total CPTs, therefore they are allowed to withdraw half the virtual fees, this is, 10 FAssets each.
- Alice has no debt, so she can withdraw 10 FAssets, which is all the fees in the pool, because she was the only CPT holder when these fees were accrued.
- Conversely, Bob has 10 FAssets of debt, so he can't withdraw any of the fees.

After step **5**, the new fees are shared between both users, and the previous 10 FAssets still belong to Alice:

- The 10 FAssets in new fees increase the total virtual fees to 30.
- Both users are entitled to half of the total, which is 15 FAssets each.
- Alice has no debt, so she can withdraw 15 FAssets: the initial 10 plus half of the 10 that were added to the pool afterwards.
- Bob has 10 FAssets of debt, so he can only withdraw 5, this is, his entitlement (15) minus the debt (10).

After step **6**:

- The 10 FAssets that Alice has withdrawn have converted into debt for her.
- However, this action does not change the total virtual fees because the sum of fees in the pool and total debt remains constant.
- Therefore, both users are still entitled to 15 FAssets each.
- However, now Alice has 10 FAssets of debt, so she can withdraw only 5 more.
- Nothing has changed for Bob, who can still withdraw 5 FAssets.

In step **7**:

- Bob is returning 100 CPTs, which is 50% of the circulating CPTs, so he is entitled to half the total virtual fees, 15 FAssets.
- Because he is exiting the pool, all his debt, which is 10 FAssets, must be cancelled.
- He can withdraw the remaining 5 FAssets from the fees pool.
- After Bob withdraws his 5 FAssets, the pool contains only 5 FAssets, which correspond to the amount that Alice can withdraw.

</details>

## Transferable and Locked CPTs

CPTs can always be **redeemed** by exiting the pool, but only the portion above the fee debt can be **transferred** to another account; therefore, CPTs held by providers are divided into two types.

### Transferable

Tokens whose time lock has expired and are also free of fee debt.
These tokens are fungible, and they can be transferred or traded just like any other ERC-20 token.

### Locked

The CPTs serve only as proof of ownership of some of the collateral in the pool, and they cannot be transferred nor traded.

Locked CPTs are one of the following types:

- **Time-locked**: Tokens whose time lock has not expired must wait to become transferable or redeemable.
- **Debt-locked**: Tokens corresponding to an amount of fees below the provider's fee debt cannot be transferred because they would need to carry the debt with them.
  However, they can be [redeemed](#cpt-redemption).

  As new fees arrive in the pool, some previously debt-locked tokens become transferable.

  These CPTs can also become transferable by adding FAssets to the pool, which settles, either partially or completely, the fee debt.

<details>
<summary>CPT transferability formulae and examples.</summary>

The amount of CPTs that a given provider $p$ can transfer is calculated as:

$$
transferable\_CPT_p = { free\_fees_p \over virtual\_fees_p } \times CPT_p
$$

where:

- $free\_fees_p$ is the amount of fees from the pool that a provider $p$ can withdraw, as defined in the previous formula box.
- $virtual\_fees_p$ is the amount of FAsset minting fees that provider $p$ would be entitled to if they had no debt, as defined in the previous formula box.
- $CPT_p$ is the amount of CPTs provider $p$ holds.

Accordingly, the amount of CPT that is locked and cannot be transferred is calculated as:

$$
locked\_CPT_p = { fee\_debt_p \over virtual\_fees_p } \times CPT_p
$$

As new minting fees arrive in the pool, the $transferable\_CPT_p$ of all providers also increases.

Conversely, when a provider withdraws fees from the pool, their debt increases in the same amount, and $total\_virtual\_fee$ remains the same.
Therefore, only that provider's $transferable\_CPT_p$ is reduced, without affecting the rest of the providers.

---

The following example shows transferability of CPTs

|                                                                    | Issued CPTs | Fees in pool | Total fee debt | Total virtual fees |
| ------------------------------------------------------------------ | ----------: | -----------: | -------------: | -----------------: |
| An agent creates a new vault.                                      |           0 |            0 |              0 |                  0 |
| Alice deposits 100 FLR and receives 100 CPTs.                      |     **100** |            0 |              0 |                  0 |
| 10 FAssets of fees are added to the pool due to a mint.            |         100 |       **10** |              0 |             **10** |
| Alice withdraws 5 FAssets of fees.                                 |         100 |        **5** |          **5** |                 10 |
| 10 more FAssets of fees are added to the pool due to another mint. |         100 |       **15** |              5 |             **20** |
| Alice transfers 75 CPTs to Bob.                                    |         100 |           15 |              5 |                 20 |
| Alice exits the pool by returning her remaining 25 CPTs.           |      **75** |           15 |          **0** |             **15** |

After step **2**, all of Alice's CPTs are transferable because she has no debt.

After step **3**, all of Alice's CPTs continue to be transferable, and she is entitled to 100% of the fees in the pool.
If she transferred or traded his CPTs, the recipient of those CPTs would be entitled to the fees.

After step **4**, only half of Alice's CPTs are transferable (50 CPTs). The other half is debt-locked.

After step **5**, only 25% of Alice's CPTs remain locked (25 CPTs), which correspond to her 5 FAssets of debt.

After step **6**:

- Alice has 25 CPTs, which entitle her to 5 FAssets of virtual fees.
  After subtracting her 5 FAssets of fees, her free fees are zero, which means she cannot withdraw any more fees.
- Bob has 75 CPTs and no debt, so he is entitled to 15 FAssets of fees, which are all the fees in the pool.

In step **7**:

- Alice is returning 25 CPTs, which is 25% of the circulating CPTs, so she is entitled to 25% of the total virtual fees, which is 5 FAssets.
- Because she is exiting the pool, all her debt, which is 5 FAssets, must be cancelled.
- Her $free\_fees_p$ are 0, so she cannot take any of the remaining fees in the pool.
- The 15 FAssets that remain in the fee pool now belong entirely to Bob, who holds 100% of all the issued CPTs, which is 75 CPTs.

</details>

## CPT Redemption

When collateral providers exit the pool by redeeming their CPTs, the FAssets system burns them and returns the appropriate share of the collateral plus the share of [FAsset-minting fees minus any FAsset-fee debt](#minting-fees-and-debt).

Providers also have the option to exit the pool partially, by redeeming only some of their CPTs.
In this case, they can choose one of the following options to manage their due FAsset fees: withdraw the fees, reduce the fee debt, or both, keeping the current fee-to-debt-ratio.

However, providers can exit, either fully or partially, only when the [collateral ratio CR](#collateral-ratio) is high enough.
After they exit, the **CR** must be higher than the **exit CR** to prevent their exit from reducing the **CR** to a dangerous level.

Therefore, exits are impossible when the **CR** is below the **exit CR**.
In this case, if providers have enough FAssets, they can exit by **self-closing**, which burns enough of their FAssets, plus their fees, to release their collateral.

Providers are mainly compensated in underlying assets for the burned FAssets, depending on the [number of lots](/fassets/minting#lots) of FAssets that need to be redeemed:

- If more than 1 lot needs to be redeemed, the value of the burned FAssets is redeemed through the standard [redemption process](/fassets/redemption).
- If less than 1 lot needs to be redeemed, the agent buys the underlying funds from the user using vault collateral, at the price reported by the [FTSO](/ftso/overview) minus a percentage defined by the agent.
  This purchase by the agent occurs because fees on underlying chains can be expensive, which makes redemption of small quantities too expensive for the agent.

  Providers can always request this option instead of receiving underlying tokens.
  Also, if enough vault collateral is not available, pool collateral is used instead.

:::warning
In the case where the agent does not redeem in the underlying asset, the FAssets system pays the provider in collateral from the agent's vault because the pool collateral backing the redeemed FAssets is already withdrawn.

    When this type of redemption occurs, users might receive less collateral than they would have received if they had made a normal redemption.

:::

## Agent Stake

Agents must have a stake in their collateral pools, which means they must hold the amount of CPTs proportional, by a system-defined constant, to the backed amount of FAssets.
The maximum amount of minting is limited by the amount of collateral pool tokens held by the agents.
The agents' tokens are locked, which means they cannot be redeemed or transferred, while agents back these FAssets.

When the agent's portion of the collateral pool is below the threshold, new mintings are not allowed.
However, this situation does not trigger a liquidation because only the total pool stake matters when collateral needs to be redeemed or a liquidation payment needs to be made.

If an agent's actions force a payment to be made from the collateral pool, the agent's CPTs, valued by the paid native tokens and recalculated by the collateral-pool-price formula, are burned.
These actions can cause the agent's CPTs to be burned:

- When a redemption payment fails, when enough vault collateral to compensate the redeemer is not available, or when the system is set to automatically pay for redemption failures from the collateral pool.
- Liquidation because the CR of the vault collateral is too low.
- Full liquidation because of an [agent infraction](/fassets/redemption#redemption-payment-failure) during a transfer on an underlying chain.

## Top-up

To reduce the likelihood of liquidations because the pool collateral is too low, the pool can be topped up at a reduced price when the **CR** is above the **top-up CR**. A top-up mechanism for vault collateral is not available. To prevent liquidation, agents can add vault collateral any time.",2025-03-08 01:27:14
1-overview.mdx,"title: FAssets
description: FAssets is a trustless over-collateralized bridge to non smart contract networks to Flare.
keywords: [fassets, xrp, bitcoin, dogecoin, flare-network]","import ThemedImage from ""@theme/ThemedImage"";
import useBaseUrl from ""@docusaurus/useBaseUrl"";

FAssets is a trustless, over-collateralized bridge connecting non smart contract networks to Flare.
It enables the creation of wrapped tokens (`FAssets`) for assets like BTC, DOGE and XRP.
These tokens can participate in Flare's DeFi ecosystem or be redeemed for their original assets.

FAssets are powered by Flare's enshrined data protocols:

- **[Flare Time Series Oracle (FTSO)](/ftso/overview):** Provides decentralized price feeds.
- **[Flare Data Connector (FDC)](/fdc/overview):** Verifies off-chain actions, such as transactions on other blockchains.

Each FAsset is backed by a mix of collateral, including:

1. Stablecoin or ETH collateral.
2. FLR (Flare's native token) or SGB (Songbird's native token) collateral.

Agents and a community-provided collateral pool ensure trustlessness through over-collateralization.

## FAsset Workflow

<ThemedImage
  alt=""FTSO Update Architecture""
  sources={{
    light: useBaseUrl(""img/fassets/flare_fassets_architecture_light.svg""),
    dark: useBaseUrl(""img/fassets/flare_fassets_architecture_dark.svg""),
  }}
/>

Anyone on the Flare blockchain can mint FAssets, which are wrapped versions of original tokens from other blockchains, known as underlying networks. The original tokens from these chains, such as Bitcoin (BTC), Litecoin (LTC), Dogecoin (DOGE), and XRP, are referred to as underlying assets. For example, the FAsset version of Bitcoin is known as FBTC.

### Minting

    - A user (minter) selects an agent and pays a fee to reserve collateral.
    - If the agent requires a handshake, the user's address is verified before proceeding with collateral reservation.
    - The user sends the underlying asset (e.g., BTC) to the agent.
    - The FDC verifies the transaction.
    - The equivalent FAssets (e.g., FBTC) are minted as ERC-20 tokens on Flare.

### Usage

Minted FAssets can be used in DeFi applications on Flare or bridged to other chains.

### Redeeming

Users can redeem FAssets for the original underlying assets at any time.

## Key Participants

### Agents

Agents manage the infrastructure and operations of the FAssets system, including:

- Holding the underlying assets.
- Providing collateral for minting and redemption.
- Redeeming underlying assets for users.

Each agent is verified through governance and uses the following addresses:

- **Work Address:** A hot wallet for executing operations.
- **Management Address:** A cold wallet for secure administrative actions.

Agents must comply with the **backing factor**, which ensures sufficient collateral is locked to back FAssets.

### Users

Users interact with the system by:

- **Minting:** Depositing underlying assets to mint FAssets.
- **Redeeming:** Exchanging FAssets for the original underlying assets.

Eligibility:

- No restrictions‚Äîanyone can mint or redeem FAssets.

### Collateral Providers

Collateral providers supply native FLR tokens to an agent's collateral pool and earn a share of minting fees as long as their tokens remain locked.

### Liquidators

Liquidators maintain system health by:

- Burning FAssets in exchange for collateral when an agent's collateral drops below the required minimum.
- Earning rewards, including premiums on the collateral received.

Eligibility:

- Open to all‚Äîanyone can become a liquidator.

### Challengers

Challengers monitor agents for illegal transactions that reduce collateral below the backing factor. They:

- Submit proof of illegal actions to the system.
- Earn rewards from the agent's vault upon successful challenges.

If an agent is found in violation, they enter **full liquidation**, permanently restricting them from new minting operations.

:::tip[What's next]

Learn more about the different components and processes involved in FAssets - [collateral](/fassets/collateral), [minting](/fassets/minting), [redemptions](/fassets/redemption), and [liquidations](/fassets/liquidation).

:::",2025-03-08 01:27:14
3-minting.mdx,"title: Minting
description: Understand how minting works in FAssets.
keywords: [fassets, xrp, bitcoin, dogecoin, flare-network]","Minting FAssets is the process of wrapping underlying tokens from connected blockchains into FAssets to be used on the Flare blockchain.
Any user can mint FAssets.

## Minting Process

This is the summary of the minting process:

1. The minter chooses an agent from the publicly available [agent list](/fassets/overview#agents).
   The choice is based on the minting fee or the amount of free collateral, which must be enough to back the amount to be minted.
2. The minter sends to the Asset Manager contract a collateral reservation transaction (CRT). The CRT includes:

   - The address of the chosen agent
   - The amount to mint, which must be a whole number of [lots](/fassets/minting#lots)
   - The [collateral reservation fee (CRF)](#fees) to compensate for the locked collateral

3. The Asset Manager contract locks the agent's collateral in the amount needed to back the whole minting until the underlying payment is proved or disproved.
   The collateral reservation response is an event issued by the contract, which includes:

   - The agent's address to which the minter must send funds on the underlying chain.
   - The amount to be paid on the underlying chain, which corresponds to the amount to be minted plus the agent's fee.
   - The payment reference, which is a unique 32-byte number the minter must include as a memo in the payment on the underlying chain.
   - The last underlying block and the last underlying timestamp to pay.
     Valid payments occur either before the last block or before the last timestamp, both inclusive.

     The time to pay is measured both in the underlying chain's block numbers and block times because the underlying chain might halt for a long time.
     In this situation, the block numbers do not increment but the block timestamps do.

4. After this event is emitted, the minter must pay the full underlying amount plus the fee to the agent on the underlying chain in a certain amount of time.
5. Using the Data Connector, the minter proves the payment on Flare.
6. After the payment is proved, the minter executes the minting process, which sends FAssets to the minter's account.

When minting is executed, the [minting fee](#fees) is split between the agent and the pool:

- The percentage split is set by the agent.
- The agent's share increases the free balance on the agent's underlying address.
  The free balance is the part of the balance in an agent's underlying address that the agent can withdraw.
  It is composed of minting fees, redemption fees, and self-closed FAssets.
- The pool share gets minted as FAssets and credited to the collateral pool contract.

After minting is complete, the Asset Manager creates a [redemption ticket](#redemption-tickets-and-the-redemption-queue), which includes the mint amount and the name of the agent backing the minting.

## Fees

The following fees are paid to mint FAssets:

### Collateral Reservation Fee

The **collateral reservation fee (CRF)** is paid in native tokens by the minter at the same time the [collateral reservation](#minting-process) is made.
The CRF is defined by governance as a percentage of the minted value, and the same fee applies to all agents.

The purpose of the CRF is to compensate the agent and collateral pool token (CPT) holders for the time their collateral is locked during the minting process.

- If the minter does not pay on the underlying chain, the CRF is distributed to the agent and the pool in the same share as the minting fee.
- If the minter successfully pays on the underlying chain, the CRF is also distributed to the agent and the pool in the same manner.

For underlying chains where proving payments takes longer, the CRF might be set higher to account for the extended lock-up time.
The CRF percentage is defined by governance and may vary based on the performance of the underlying chain.

### Minting Fee

The **minting fee** is paid by the minter with the underlying currency as a percentage of the minted amount, and each agent can declare a different fee value.
This fee is the main source of revenue for the agent and the CPT holders.

The minting fee is further divided in two shares:

#### Agent share

This share remains in the agent's underlying account but is not marked as being in use. The agent can use this balance freely.

#### Pool share

This share is minted as FAssets and sent to the [collateral pool](/fassets/collateral#pool-collateral). The percentage of this share is defined by the agent and can be changed by the agent after a delay that provides time for minters to notice the change.

### Trailing Fees

To ensure that agents and collateral pool providers receive steady income, the FAsset system offers an option to enable FAsset token transfer fees, also known as trailing fees.

Whenever FAssets are transferred, a small proportional fee is deducted and contributed to a common pool. In a regular transfer, this fee is subtracted from the payment, meaning the sender pays the exact amount specified in the transfer request, while the receiver ends up receiving a slightly lower amount.

There is also a method where the receiver gets the exact amount specified in the call, while the sender pays more. The fee percentage is a system setting and is typically quite small.

The fees are collected over a certain period, known as an epoch, after which they are distributed among all agents in proportion to each agent's average backed amount during that epoch.

An agent can claim their portion of the fees for an epoch at any time after the epoch ends and before it expires. When making a claim, the fee is distributed between the agent and the pool in the same manner as the minting fee, based on the agent's settings.

## Handshake

Certain jurisdictions may require agents to confirm that those minting or redeeming assets are not engaged in illegal activities. Although the FAsset system does not impose this requirement, it does provide agents with the option to utilize an external service to verify the identities of minters and redeemers before proceeding with minting or redemption.

To enable the handshake, the agent must configure this setting in the agent settings. Once this is enabled, minting and redemption will involve an additional step.

### Minting

The FAssets agent verifies the minter after the user completes the collateral reservation and pays the collateral reservation fee. The agent is responsible for confirming or rejecting the minter's status. If the agent does not respond within a certain timeframe, the minter has the option to cancel the reservation and receive a full refund of the collateral reservation fee.

To enable the agent to verify the minter, the collateral reservation must include the address (or multiple addresses, in the case of UTXO chains) from which the payment will be made. If multiple addresses are provided, all of them must be used for the payment.

Users must wait up to 60 seconds before they can cancel their request. If the agent accepts within this time, the user can proceed to mint by depositing the underlying assets. Therefore, it is important for the agent to respond quickly. If the agent does not respond in time, it will depend on whether the user is willing to wait; otherwise, the agent will simply miss the opportunity to mint, but there will be no loss of tokens.

When the agent rejects the minter's request or the minter decides to cancel, the minter will receive a refund of the collateral reservation fee, minus a small percentage (e.g., 5%) that is burned. This burned amount is designed to prevent abuse of the agent by stopping someone from repeatedly reserving collateral from a sanctioned address. If the burned percentage were zero, an attacker could exploit the system without any cost.

### Redemption

The agent has a few minutes to verify the redeemer's addresses and either approve or reject the redemption. If rejected, another agent can take over. If no one takes over, the minter receives the full amount plus a small premium from the rejecting agent, with the premium for a handshake rejection being smaller than for a redemption default.

:::info

An agent may only fulfill part of a request due to insufficient minting or too many small tickets. In these situations, the system allows for a ‚Äúpartial takeover‚Äù, where the remaining portion can either be taken over by another agent or covered by collateral from the agent who declined the redemption.

:::

## Payment Failure

To finalize the minting, the minter must pay the agent on the underlying chain and prove the payment was received.
If the payment is not completed in the time frame defined by the underlying chain block and timestamp, the agent must prove nonpayment to release the locked collateral.
After nonpayment is proved, the agent's collateral that was reserved by the [CRT](#minting-process) is released, and the agent receives the [CRF](#collateral-reservation-fee).

The [agent's registration process](/fassets/overview#agents) verifies that the agent's underlying address does not purposefully block payments and illegally collects the CRF.

The following example shows proof of nonpayment.

<details>
<summary>Proof of nonpayment example.</summary>

The following example shows how the nonpayment proof works.

The Data Connector's [payment nonexistence attestation type](https://gitlab.com/flarenetwork/state-connector-protocol/-/blob/main/specs/attestations/active-types/ReferencedPaymentNonexistence.md?ref_type=heads) proves nonpayment.

1. The minter sends a request to mint FBTC.
   At the time the request is received, the last mined block on the Bitcoin chain is number 92, with timestamp 09:00 AM.

   The Asset Manager answers with the following threshold settings to complete the payment:

   - Block 100
   - Timestamp 11:00 AM

2. Block 101 is mined with timestamp 10:59 AM.
   At this point, the payment can still happen.
3. Block 102 is mined with timestamp 11:04 AM.
   Payment did not occur.
   After this block is finalized, nonpayment can be proved.

4. Block 109 is mined.
   In this case, 7 blocks on the Bitcoin blockchain are enough blocks to assume finality.
5. The agent sends a nonpayment attestation request, which includes the payment reference, the underlying amount that was expected, the last block (100), and the last timestamp (11:00).
6. Attestation providers attest to the following facts:

   - Block 102 is finalized and has both the number and timestamp larger than required.
   - Until this block, the required payment either was not made or was not sufficient.

Now, the mint-payment failure and the nonpayment proof can be submitted to the FAssets system.

</details>

## Edge Cases

### Unresponsive minter

After a successful payment, the minter might not provide the payment proof needed to complete the minting process.
In this case, the agent can present the payment proof and execute minting at any time.
FAssets are still transferred to the minter's account, and the agent's collateral becomes redeemable.

### Expired proof

Proofs provided by the Data Connector are available for only 24 hours, approximately.
If neither the minter nor the agent presents the proof of payment or nonpayment within 24 hours, the regular minting process cannot continue, and the agent's collateral could be locked indefinitely.

In this case, the agent can still recover the collateral by buying it back with native tokens.
The recovery is accomplished with the following procedure:

    1. Request the proof from the time when the deposit should have happened.
     The Data Connector's answer will indicate that payments proofs are no longer available for that time.
    2. Provide the amount of FLR collateral equivalent to the price of the underlying assets that should have been deposited.
    3. Present the proof.

Because a successful deposit cannot be proven, the FAssets system burns the amount of collateral in native tokens provided by the agent.
After the burn is complete, the rest of the agent's collateral is released, both from his vault and the collateral pool.

:::warning
Note that this procedure should be used only in rare cases because providing timely payment or nonpayment proofs is always more advantageous for agents.
:::

## Duration of the Minting Process

The duration of the minting process depends mainly on the speed of the underlying chain.
The maximum duration of the process is the sum of:

- A system-defined maximum time for deposit.
  It is either a few blocks on the underlying chain or a few minutes, whichever is longer.
- The underlying chain's finalization time.
- The Data Connector proof time, which is approximately 3 - 5 minutes, independent of the underlying chain.

On fast chains like XRPL, the maximum total time is less than 10 minutes, while on Bitcoin it is approximately 1.5 hours.
For payment failures, the agent needs to wait the maximum time, as defined above, before the nonpayment proof can be retrieved.

## Minting Payment Reference

The system generates a unique payment reference at the time of the collateral reservation request.
The minter must include the payment reference in a memo field when the underlying payment transaction is made.

The payment reference ensures the payment transaction cannot be used by another entity that might claim to have made the payment on the underlying chain and receive the minted FAssets in return.
Additionally, if the payment time expires before payment is done, the agent can prove that no payment with that reference was made.

A similar payment reference for the same purposes is generated for [redemptions](/fassets/redemption).

## Redemption Tickets and the Redemption Queue

For every minting operation, a redemption ticket is created.
This ticket references the minted amount and the agent that is backing the minting.

The redemption tickets are ordered in a queue that determines the next agent to be [redeemed](/fassets/redemption) against according to the first in, first out method (FIFO).
In other words, the first redemption ticket created will be the first redemption ticket processed.
The FIFO queue impartially ensures that all agents have the opportunity to fulfill the duties of their role.

The following example shows how the redemption queue works.

<details>
<summary>Redemption queue example.</summary>

1.  Bob mints 10 FXRP with Agent 1.
2.  Alice mints 20 FXRP with Agent 2.
3.  Charlie mints 5 FXRP with Agent 1.

    After Bob, Alice, and Charlie have minted their FAssets, the redemption queue according to the FIFO method is:

    1. Agent 1 with 10 FXRP.
    2. Agent 2 with 20 FXRP.
    3. Agent 1 with 5 FXRP.

4.  Dana redeems 25 FXRP.
    To redeem 25 FXRP:

    1. Agent 1 pays 10 FXRP.
    2. Agent 2 pays 15 FXRP.

    Now, the redemption queue according to the FIFO method is:

    1. Agent 2 with 5 FXRP.
    2. Agent 1 with 5 FXRP.

</details>

## Lots

Every minting and redemption must be made in a whole number of lots.
Lots serve the following purposes:

- They prevent underlying transaction fees from exceeding minting or redemption fees.
- They restrict large numbers of very small redemption tickets from being submitted, which would increase gas costs.

Therefore, the amount of tokens in a lot (the _lot size_) varies for each underlying chain.
For example, on the XRPL chain, a lot can be as small as 10 XRP because transaction fees are low.
On the other hand, on the Bitcoin chain, lots might need to be as big as 0.25 BTC or more because transactions are far more expensive.

Over time, the lot size can be updated to reflect price fluctuations of the underlying asset.
Only a governance call can update the lot size, and it can be updated only by a limited amount per day.

## Dust

Some processes generate a fractional number of lots:

- On minting, part of the minting fee is minted as the FAsset fee to the collateral pool.
  This value is usually less than 1 lot.
- When the lot size is changed, redemptions close only a whole number of lots of each redemption ticket, which leaves the remainder unredeemed.

These amounts, known as dust, cannot be redeemed directly because redemption requires a whole number of lots.

In such cases, the generated dust is not included in any redemption ticket.
Instead, each agent's dust is accumulated until the dust amounts to a whole lot.
When that happens, another redemption ticket is automatically created.

Therefore, the dust can be recovered or destroyed in the following ways:

- If the dust exceeds 1 lot during minting, the part that is a whole multiple of a lot is automatically added to the created redemption ticket.
- If an agent does not mint any FAssets for a while but the lot size changes and several redemptions occur, enough dust might accumulate to more than 1 lot.

  In this case, the part that is a whole multiple of a lot can be converted to a redemption ticket by request.
  To prevent an inactive agent making FAssets less fungible, this request can be made by any address.

- Self-closing can work with fractional lots, so it can be used to remove dust.
- Liquidation can work with fractional lots too, so it can also be used to remove dust.

## Self-Minting

Agents can also act as minters and mint FAssets from their own vaults.
This process is called self-minting and is simpler than regular minting because neither the CRT nor the agent's fee are necessary.

When an agent self-mints FAssets:

- The agent still needs to pay the amount to mint on the underlying chain and execute the minting.
- The self-minting operation also adds a [ticket to the redemption queue](#redemption-tickets-and-the-redemption-queue), alongside tickets added by mints done by other users.
  All tickets are processed by the FIFO queue.
- Only the [pool's share of the fee](#fees) must be paid.

Because self-minting is done without a collateral reservation request, in some cases, a change between the underlying deposit and the execution, such as another collateral reservation, price change which reduces the amount of free [lots](#lots), or lot-size change, might prohibit the intended number of lots to be minted.
If one of these changes occurs, the agent can self-mint a smaller number of lots, even 0 lots, and the remainder of the deposited underlying assets is added to the free underlying balance.

Additionally, when agents create a vault, they can choose not to make it public, so the vault can only be used to self-mint.",2025-03-08 01:27:14
5-liquidation.mdx,"title: Liquidation
description: Understand how liquidations work in FAssets.
keywords: [fassets, xrp, bitcoin, dogecoin, flare-network]","Liquidation is the process of selling assets to bring the FAssets system back to health after an [agent](/fassets/overview#agents) becomes undercollateralized. The following types of liquidation can occur:

- **Unhealthy position liquidation**: Occurs when the [collateral ratio (CR)](/fassets/collateral#collateral-ratio) of either the agent's vault or collateral pool falls below its respective [minimal CR](/fassets/collateral#system-wide-thresholds).
  In this case, the agent's position is liquidated until the collateral ratio reaches the [safety CR](/fassets/collateral#system-wide-thresholds) or all of the backed FAssets are liquidated.
- **Full liquidation**: Occurs when the agent makes an [illegal payment](#illegal-payments) from the underlying chain address.
  In this case, all the FAssets backed by the agent are liquidated, and the liquidation cannot be stopped.

In both cases, [liquidators](/fassets/overview#liquidators), who can be anyone who holds FAssets, are encouraged to sell their FAssets back to the system.
They will be paid with the agent's collateral plus a premium, as a penalty against the agent for unhealthy positions or misconduct.

## Liquidation Process

When liquidation starts, any liquidator can send FAssets and get paid with a combination of vault collateral and pool collateral at the current asset price multiplied by a premium factor greater than 1.
The maximum amount of FAssets that is accepted is the amount required to make the agent's position healthy again, rounded up to the next lot.

The premium is a system-defined percentage, and it can increase through the duration of the liquidation.
The premium is limited to the agent's combined collateral ratio, which is the sum of the current value of the vault collateral and pool collateral divided by the current value of the backed FAsset amount.
However, if this limit is reached, all the agent's backed FAssets are liquidated, and all the vault collateral and pool collateral are paid to the liquidators.
The liquidation-collateral payment is divided between the agent and the collateral pool.

A fixed ratio (‚â• 1.0) of the payment is paid from the agent's collateral, and the remainder is paid from the pool collateral.
If not enough of one type of collateral exists, more is paid from the other type.

:::info

    Illegal payments trigger a full liquidation, which involves the following additional actions:

    * The liquidated agent's vault is locked so that it cannot be used to mint again.
        If the agent wants to continue to mint FAssets, he must create a new agent vault with a new underlying address.
    * Ongoing mintings against this agent's locked vault continue, but the minted FAssets are immediately added to the liquidation process.
    * Ongoing redemptions continue.
        New redemptions can start until all the agent's redemption tickets are liquidated.
        Unfortunately, if the agent's underlying backing is unhealthy, redeemers are more likely to be paid in native tokens from the collateral pool.

    This liquidation process includes the time-increasing premium, and it only stops when all the agent's collateral is liquidated.

:::

## Stopping Liquidations

After liquidation of an unhealthy position starts, it can be stopped by depositing enough collateral or self-closing FAssets to reach the [safety CR](/fassets/collateral#system-wide-thresholds).
Also, if a change in the price pushes the CR above the [safety CR](/fassets/collateral#system-wide-thresholds), anyone can stop the liquidation by notifying the FAssets system.

To maintain a healthy account, agents should track positions and automatically top up or self-close FAssets when liquidation approaches.
Otherwise, the agent and the liquidators compete to try to stop the liquidation.
To stop a liquidation, the agent's vault must reach the [safety CR](/fassets/collateral#system-wide-thresholds), which is above the minimal CR that triggered the liquidation.

The top-up mechanism can prevent liquidations caused by a low CR in the collateral pool, but full liquidations cannot be stopped.
However, an agent can still self-close positions to avoid paying a premium to liquidators.

<details>
<summary>Example with small price movement.</summary>

Using BTC as underlying and USDC as collateral, an agent creates a vault to mint FBTC FAssets.

1.  Initial conditions:

    - The agent is backing 1 FBTC, currently valued at $20K, according to the FTSO system.
    - The minimal CR is **1.3** for the vault collateral and **2.5** for pool collateral.
    - The agent must hold 20% of the pool's minimal CR.
      In this case, 20% of 2.5 times \$20K is **\$10K**.
    - The underlying backing factor is 50%, so the agent needs to hold only **0.5** BTC.
    - The liquidation premium factor is 1.1, of which 1.0 is paid in vault collateral, and 0.1 is paid in pool collateral.

    At this point, the 1 FBTC is backed by:

    - 0.5 BTC underlying.
    - $26K worth of USDC vault collateral.

      The vault CR is $$ \frac{\text{\$26K}}{\text{\$20K}} = 1.3 $$, equal to the vault's minimal CR.

    - \$60K worth of FLR in pool collateral, of which $10K belongs to the agent.

      The pool CR is $$ \$60K \over \$20K $$ \= 3, above the pool's minimal CR.

2.  Now the price of BTC increases from \$20K to $21K.
    As a result:

    - The vault CR is $$\frac{\text{\$26K}}{\text{\$21K}} \approx 1.24$$, **below the vault's 1.3 minimal CR**.
    - The pool CR is $$\frac{\text{\$60K}}{\text{\$21K}} \approx 2.86$$, still above the pool's 2.5 minimal CR.
      :::warning
      Because one of the CRs is below the minimal CR, liquidation can start after a system-defined wait period.

          If any of the CRs go below the liquidation CR, liquidations can start immediately.

      :::

3.  A liquidator notices the CR levels and decides to liquidate $10K worth of FAssets by returning 0.48 FBTC to the FAssets system.

    The liquidation premium factor is 1.1, so the liquidator receives $11K worth of assets:

    - $10K worth of USDC from the agent's vault collateral.
    - $1K worth of FLR from the agent's portion of the collateral pool.

      The corresponding $1K worth of CPTs are burned, so their price is unaffected.

    At this point, the agent is backing 0.52 FBTC with:

    - 0.5 BTC underlying.

      The ratio is $$ \frac{0.5}{0.52} \approx 0.96 $$, well above the 50% underlying backing factor.

    - $16K worth of USDC vault collateral.

      The vault CR is $$ \frac{\text{\$16K}}{\text{\$11K}} \approx 1.45 $$, now above the vault's minimal CR.

    - \$59K worth of FLR in pool collateral, of which $9K belong to the agent.

      The pool CR is $$ \frac{\text{\$59K}}{\text{\$11K}} \approx 5.36 $$, still well above the pool's minimal CR.

Both CRs are now above the minimal CR values, but liquidation does not stop until the CRs further increase up to the safety CR.

In summary, as a result of the price increase and the liquidation, around 50% of the backed FBTC was burned.
The actual amount of FAssets that need to be burned, though, depends on the safety CR setting.

</details>

<details>
<summary>Example with large price movement.</summary>

The same setup and initial conditions as in Example 1 are used:
Using BTC as underlying and USDC as collateral, an agent creates a vault to mint FBTC FAssets.

1.  Initial conditions:

    - The agent is backing 1 FBTC, currently valued at $20K, according to the FTSO system.
    - The minimal CR is **1.3** for the vault collateral and **2.5** for pool collateral.
    - The agent must hold 20% of the pool's minimal CR.
      In this case, 20% of 2.5 times \$20 K is **\$10 K**.
    - The underlying backing factor is 50%, so the agent needs to hold only **0.5** BTC.
    - The liquidation premium factor is 1.1, of which 1.0 is paid in vault collateral, and 0.1 is paid in pool collateral.

    At this point, the 1 FBTC is backed by:

    - 0.5 BTC underlying.
    - \$26 K worth of USDC vault collateral.

      The vault CR is $$ \frac{\text{\$26\ K}}{\text{\$20\ K}} = 1.3 $$, equal to the vault's minimal CR.

    - \$60 K worth of FLR in pool collateral, of which \$10 K belongs to the agent.

      The pool CR is $$ \frac{\text{\$60\ K}}{\text{\$20\ K}} = 3 $$, above the pool's minimal CR.

2.  Now the price of BTC increases from \$20K to $30K.
    As a result:

    - The vault CR is $$ \frac{\text{\$26\ K}}{\text{\$30\ K}} \approx 0.87 $$, **way below the vault's 1.3 minimal CR**.
    - The pool CR is $$ \frac{\text{\$60\ K}}{\text{\$30\ K}} = 2 $$, **below the vault's 2.5 minimal CR**.

    To comply with the vault's 1.3 minimal CR, the agent needs $$ 1.3 \times \text{\$30\ K} = \text{\$39\ K} $$ of USDC vault collateral, which he does not have.

    **Warning:** At this point, all the agent's FAssets backed by this vault must be liquidated.

3.  A liquidator notices this situation and decides to liquidate 1 FBTC, currently worth $30K.

    The liquidation premium factor is 1.1, so the liquidator receives $33K worth of assets:

    - \$26 K worth of USDC, which is all of the collateral in the agent's vault.
    - \$7 K worth of FLR.

    Note that the portion of payment in FLR is higher than in Example 1 because enough USDC in collateral did not exist.

    At this point, the agent is backing 0 FBTC, and the remaining collateral is:

    - 0.5 BTC underlying.
    - \$0 worth of USDC in vault collateral.
    - \$53 K worth of FLR in pool collateral, of which \$3 K belongs to the agent.

      All this collateral can be freely withdrawn by its owners.
      Because this collateral is not backing any FAssets anymore, no part of it is locked.

</details>

<details>
<summary>Example with a very large price movement.</summary>

A price increment such that the vault plus the pool collateral is not enough to back the minted FAssets results in a combined CR lower than 1.
By design, liquidation payments will never exceed the combined CR times the liquidated amount, so, in this case, liquidation is not a profitable operation.

Moreover, the collateral locked in the FAssets system might not be a strong enough deterrent for agents that want to dispose of the higher-valued underlying in an illegal way.

</details>

## Liquidation Triggers

Some events related to liquidation are not detected automatically and must be triggered by entities external to the blockchain.
These entities are [liquidators](/fassets/overview#liquidators) and [challengers](/fassets/overview#challengers).

Anyone can be a liquidator or a challenger and earn rewards for contributing to the correct working of the FAssets system.

Some triggers put an agent in liquidation mode, and some others get agents out of liquidation mode.

### Liquidation-Enabling Triggers

- A valid liquidation request is submitted, triggering the liquidation automatically.
- A liquidator triggers a liquidation manually, but does not submit a liquidation request immediately, seeking a better premium, because the premium might increase as time passes.
- A liquidator detects that the CR is below the [CCB](/fassets/collateral#system-wide-thresholds) and sets the start time for an agent.
  This operation does not immediately trigger the liquidation.
  Instead, it starts a timer that enables the liquidation to be triggered after a system-defined time has elapsed.
- A [proof of illegal activity](#illegal-payments) is presented, which immediately triggers a full liquidation.

### Liquidation-Disabling Triggers

After an agent enters the liquidation state, it remains there until its CR exceeds the [safety CR](/fassets/collateral#system-wide-thresholds) again.

The following operations can increase an agent's CR and can, therefore, potentially get the agent out of the liquidation state:

- Redemptions.
- A liquidation improves the agent's position.
- The agent deposits more collateral.
- The agent self-closes a position.
- After the price has moved so that the agent's position is healthy again, the agent, or someone on the agent's behalf, manually sets the liquidation state to false.

Exiting the liquidation state as soon as possible is in the agent's best interest, even if the agent might re-enter it again soon.
Premiums paid to liquidators might depend on how long the agent has been in liquidation, for example.
Also, exiting the liquidation state resets the CCB timer.

## Tracking the Underlying Balance

Agents are required to keep a certain percentage of underlying asset for each backed FAsset.
This percentage, called the [backing factor](/fassets/overview#agents), is stored at an address on the underlying chain controlled by the agent.

This requirement is enforced by balance-tracking in the FAsset contract.
To track balances, the system must receive reports for each payment sent and received at the agent's address:

- Incoming payments are part of the [minting process](/fassets/minting) and are updated as the process occurs.
- Outgoing payments are either part of the [redemption process](/fassets/redemption) or illegal payments, which are penalized.

Challengers maintain the health of the FAssets system by monitoring the agent's underlying address to identify illegal operations that can make the agent's underlying backing too low.
Challengers that correctly report illegal operations receive rewards from the agent's vault collateral.

The following subsections contain details about all the topics that must be considered when monitoring an agent's underlying balance.

### Chain Fees

Fees for gas on the underlying chain can create issues for the FAssets system, so part of tracking an agent's underlying balance involves tracking the amount spent on fees on the underlying chain.

Expensive gas fees can cause an address to have fewer assets than it should have and trigger a liquidation.
Therefore, consider these actions:

- **Cap the gas usage on underlying chains**: On smart-contract chains, the Data Connector defines a cap on the gas amount to enable any simple transaction to pass.
  If senders limit their gas amount to this cap and a transaction still fails due to insufficient gas, the failure is considered the receiver's fault, and the transaction is labeled as blocked.

  The gas cap is defined by the Data Connector, not the FAssets system, because it is the Data Connector that labels transactions as blocked.

- **Maintain the underlying balance**: Agents must ensure that the payment plus the transaction fee for a redemption never reduce their balance to an amount lower than the amount required to back the FAssets.
  Agents can ensure that redemptions do not reduce that balance in several ways:

  - They can honor redemptions from some other address.
    On UTXO chains, they can also honor redemptions from a combination of addresses.
  - They can top up the underlying address and then send proof of payment to update the tracked balance.
    After a redemption begins, the agent has a limited time to comply, so topping-up is time-sensitive.

### Underlying Withdrawals

Agents might legally withdraw part of the funds on their underlying address in several ways:

- **Minting fees**: A part of a minter's payment is the [mint fee](/fassets/minting#fees) in the underlying asset.
- **Failed redemptions**: When an address is backing assets and those assets were redeemed, but the agent [does not pay the redeemer](/fassets/redemption#redemption-payment-failure), the redeemer is paid with collateral, and the agent can withdraw the assets.
- **Liquidated assets**: If an agent's position was partially or fully liquidated, the agent can withdraw the assets.
- **Self-closed assets**: After an agent [self-closes](/fassets/minting#self-minting), the closed assets can be withdrawn.

The FAssets system must keep track of the agent's underlying funds, so when performing the above legal withdrawals, agents must still adhere to the following process:

1. Announce the withdrawal to the FAssets system and obtain a payment reference.
2. Perform the withdrawal, using the payment reference.
3. Use the [FDC](/fdc/overview) to obtain a proof of payment.
4. Present the proof of payment to the FAssets system, which clears the announcement.

   If the agent does not present the proof of payment, anyone can present it after a while and receive a reward from the agent's vault.
   Enabling nonagents to present this proof helps the FAssets system keep track of underlying balances.

Only one withdrawal announcement can be active per agent at any time to prevent the agent from overwhelming the balance-tracking system with many simultaneous small withdrawals.

### Illegal Payments

Any challenger can report illegal payments from an underlying address and receive rewards in return.

An illegal payment always triggers a full liquidation, which cannot be stopped.
An agent can still escape paying the liquidation premium by self-closing before liquidators submit their liquidation requests, but the agent's vault remains unusable and must be closed.
To resume operations, the agent must open a new vault with a different underlying address.

The challenge system ensures that all minted FAssets are always backed by the assets on the agent's underlying address in the required percentage.
Malicious agents might try to remove those assets in different ways.
Therefore, challengers can report illegal activities by using these different _challenges_:

#### Illegal Payment Challenge

A payment from the agent's underlying address without a payment reference or with a payment reference that does not correspond to any open [redemption](/fassets/redemption) or [announced withdrawal](#underlying-withdrawals).

This challenge is performed in the following way:

1. The challenger obtains proof of the illegal payment using the FDC.
2. The challenger presents the proof to the FAssets system, which triggers:

   - A vault collateral payment from the agent's vault to the challenger's address as a reward.
   - The agent's state for the address is set to [full liquidation](#liquidation-process).

#### Double Payment Challenge

An agent might try to abuse a redemption request to pay to the redeemer and use the same payment reference to pay an amount to the agent's own address.
An agent might even try to pay the redeemer multiple times when he is redeeming against himself.

This activity is easy to detect after the first payment is reported in [step 6 of the redemption process](/fassets/redemption#redemption-process), because then the request is deleted and the second payment becomes illegal.
However, a malicious agent might try to issue the second payment before reporting the completion of the first one.

The double payment challenge catches this attempt as soon as the payments are finalized, regardless of whether they have been reported to the FAssets system.

This challenge is performed in the following way:

1. The challenger detects two seemingly legal payments from the same agent's underlying address and with equal payment reference, and obtains proofs for both using the Data Connector.
2. The challenger presents the two proofs to the FAssets system and triggers the reward payment and full liquidation.

#### Negative Balance Challenge

One or more legal payments can make the balance on the agent's underlying address too small or equivalently make the free underlying balance negative.
This situation can happen because gas fees might be unknown when redemptions are approved.

This situation would normally be detected after all payments are reported, but in this way it can be caught as soon as the payments are finalized on the underlying chain:

1. The challenger detects one or more legal payments from the same agent's underlying address and the total outgoing amount exceeds the sum of all redemption values plus the total free balance.
   The challenger obtains proofs for all of them using the Data Connector.
2. The challenger presents all the proofs to the FAssets system, which checks that the transactions are from the agent's underlying address, that they have not been confirmed yet, and that their total really makes the free balance negative.
   Then, it triggers reward payment and full liquidation.

### Time Lock for Withdrawing Collateral

The agent's collateral backs minted FAssets but also pays challenge fees and possibly illegal payment penalties.
Because finalization on some underlying chains takes a long time, challenges can sometimes be proved to be valid only after an agent's position is already closed and enough collateral to pay them is not available.

For this reason, collateral withdrawals are locked for a certain amount of time before they become effective.
The amount of time varies depending on the underlying chain and the time frame required for achieving finality on that chain.

For agents, any collateral withdrawals must be announced, and then the amount is locked for some time before it can be withdrawn.
The locked collateral is also ineligible for minting.

Agents must announce the closing of their vaults.
They become unusable until the lock expires, and then they can be closed.",2025-03-08 01:27:14
4-redemption.mdx,"title: Redemption
description: Understand how redemptions work in FAssets.
keywords: [fassets, xrp, bitcoin, dogecoin, flare-network]","Any holder of FAssets can redeem their FAssets for the underlying original asset.
To do so, these holders, known as redeemers, send FAssets to the Asset Manager smart contract, and the redeemed amount is paid with the underlying asset from an agent's address.

## Redemption Process

This is the summary of the redemption process:

1. The redeemer starts the redemption for a whole number of lots by issuing a request to the Asset Manager smart contract.

   The FAssets system chooses one or more redemption tickets from the front of the [FIFO redemption queue](/fassets/minting#redemption-tickets-and-the-redemption-queue).
   The number of chosen redemption tickets is capped to avoid high gas consumption.
   If the redemption amount requires too many tickets, only a partial redemption is done.

2. The system burns FAssets from the redeemer's account in the amount of the total of the selected redemption tickets.
   If the redeemer's account does not contain enough FAssets, the redemption fails immediately.

3. Each chosen ticket belongs to an agent.
   For every agent participating in the redemption, the system issues an event with the following redemption payment information:

   - Redeemer's underlying address.

     Agents can use the Data Connector to ensure the validity of this address.
     Otherwise, malicious redeemers could provide an address that systematically blocks payments and exploit the redeeming process to their advantage.

   - Amount to pay minus the fee that was already subtracted.
   - [A payment reference](/fassets/minting#minting-payment-reference).
     This payment reference is different for each agent and each redemption.
   - The last underlying block and the last underlying timestamp to complete the payment.

4. Every agent pays the redeemer on the underlying chain and includes the payment reference in the memo field of the payment transaction.

   Agents can pay the redemption from any address they control on the underlying chain.
   It does not need to be the same address where they receive minting payments.

5. After the payment is finalized, the agent uses the [FDC](/fdc/overview) to prove the payment and obtain a payment proof.

6. After the payment proof is presented to the FAssets system, the agent's vault collateral and pool collateral that were backing those FAssets are released.

   After the collateral is released, it can either back the minting of more FAssets or be withdrawn.

## Redemption-Payment Failure

Agents have a limited time to pay the redeemer on the underlying chain.
The amount of time is defined by the last block and the last timestamp on the underlying chain.
If the payment is not made in time, the redeemer has to prove nonpayment to be compensated.
After the redeemer presents the nonpayment proof, he is paid with the agent's collateral plus a _redemption default premium_.
The premium is intended to encourage the agent to complete redemptions by paying with the underlying asset instead of collateral.

If a payment fails and the failed transaction is recorded on the underlying chain, the agent must submit a proof of failed payment.
In this way, the gas costs of the failed transaction can be accounted for by the FAssets system.
If the transaction was not recorded, then no gas was spent and reporting is not necessary.

If the agent does not report the failed payment in time, anyone can report the failed payment and receive a reward from the agent's vault.

:::info

    When payment fails because of the redeemer, the agent can obtain a proof of the failed payment from the Data Connector and present it to the FAssets system.
    The agent's obligation is then fulfilled, and he can keep both the collateral and the underlying.

    Two different proofs can be used:

    * Proof of invalid address, due to a wrong syntax or checksum, for example.
    * Proof of blocked payment: Even if the address is valid, it might contain a contract that blocks the payment.
        This can only happen on underlying networks supporting smart contracts.

        The agent must still try to pay and, if the payment is blocked, the agent can request this proof from the Data Connector and present it to the FAssets system.

:::

During step 4 above, if any agent does not to pay on the underlying chain, the redeemer completes the following procedure separately for each nonpaying agent:

1. The redeemer obtains a proof of nonpayment from the Data Connector.
2. The redeemer presents the nonpayment proofs to the FAssets system, which triggers a redemption failure.
3. The redeemer is paid with collateral, according to the current price plus a premium.
4. FAssets are overcollateralized, so, even after paying the redeemer with a premium, a remainder is released.
   This remainder is derived by the [system-wide collateral ratio settings](/fassets/collateral#system-wide-thresholds) specified by governance.
5. The underlying assets backing the redeemed FAssets are marked as free and can be withdrawn by the agent later.

## Edge Cases

### Unresponsive redeemer

After a redemption nonpayment, the redeemer might not report the failure for some reason.
In this case, the agent can present a nonpayment proof, and the redeemer receives collateral plus a premium.
After this operation, the underlying backing collateral and the remaining local collateral are released.

### Unresponsive agent

After a successful payment, the agent might not present the payment proof.

Because the agent has already paid, the redeemer is not affected.
However, the system still requires the payment proof to correctly track the agent's balance on the underlying chain.
After enough time for the agent to present the proof has elapsed, anyone can present the payment proof and receive collateral from the agent's vault.

### Expired proof

Proofs provided by the Data Connector are available for only 24 hours, approximately.
If neither the redeemer nor the agent presents the proof of payment or nonpayment within 24 hours, the regular redeeming process cannot continue, and the agent's collateral could be locked indefinitely.

The procedure to recover this collateral is the same as the procedure in the minting case.

## Redemption Fee

The redemption fee is the amount of the underlying asset that the agent can keep for doing the redemption.
This fee is meant only to cover the agent's transaction fee on the underlying chain, so it is not shared with the collateral pool.
The fee percentage is defined by governance, is the same for all agents, and is typically smaller than the minting fee.

Governance calculates the percentage so that the fee to redeem 1 lot pays for a typical transaction fee on the underlying chain.
Therefore, when larger amounts on a single address are redeemed, the agent accrues some extra fees because the underlying fee for small and large transactions is the same.
However, when underlying fees are very high, the agent might still lose funds when a redemption for a small amount, such as 1 lot, is made.
If this situation occurs frequently, governance will increase the redemption-fee percentage.

## Self-redemption

Agents can also act as users and redeem FAssets from their own vaults.
This process is called self-redemption or self-closing, and it is simplified because payment on the underlying chain is not required.

As shown in the following process, agents can self-redeem for any reason, including to stop liquidations because it reduces the amount of FAssets the agent is backing.

1. An agent sends FAssets to their account.
2. FAssets are burned.
3. The collateral that was backing those assets is released.
4. The underlying collateral is released and can be withdrawn from the underlying address later.

The self-redeemed amount is not limited to a whole number of lots and can be less than 1 lot, which makes self-closing ideal for redeeming an agent's dust.",2025-03-08 01:27:14
6-operational-parameters.mdx,"title: Operational Parameters
slug: operational-parameters
description: Songbird FAssets Operational Parameters
keywords: [fassets, xrp, bitcoin, dogecoin, flare-network]","import Tabs from ""@theme/Tabs"";
import TabItem from ""@theme/TabItem"";

import OperationalParameters from ""/src/components/FAssets/OperationalParameters"";

This page lists the current values for the most important parameters of the FAssets system on **Songbird Canary-Network** and **Songbird Testnet Coston**. These values are subject to change as the system is further developed and tested.

## Asset Manager Operational Parameters

To get the default agent settings, you need to call the `getSettings` function on the `IAssetManager` interface. Read more about the `IAssetManager` interface [here](/fassets/reference/IAssetManager).

### Minting and Redeeming

<OperationalParameters sectionTitle=""Minting and Redeeming"" />

### Payment Times

<OperationalParameters sectionTitle=""Payment Times"" />

### Collateral Ratios

<OperationalParameters sectionTitle=""Collateral Ratios"" />

### Liquidation

<OperationalParameters sectionTitle=""Liquidation"" />

### Rewarding

<OperationalParameters sectionTitle=""Rewarding"" />

### Time Locks

<OperationalParameters sectionTitle=""Time Locks"" />

### Emergency Pause

<OperationalParameters sectionTitle=""Emergency Pause"" />

### FAssets Upgrade

<OperationalParameters sectionTitle=""FAssets Upgrade"" />

### Transfer Fees

<OperationalParameters sectionTitle=""Transfer Fees"" />

### Handshake

<OperationalParameters sectionTitle=""Handshake"" />

## Default Agent Settings

To get the default agent settings, you need to call the `getAgentInfo` function on the `IAssetManager` interface. Read more about the `IAssetManager` interface [here](/fassets/reference/IAssetManager).

<OperationalParameters sectionTitle=""Default Agent Settings"" />",2025-03-08 01:27:14
8-reference.mdx,"title: FAssets Reference
description: Solidity reference for FAssets smart contracts.
keywords:
  [
    solidity,
    reference,
    fassets,
    xrp,
    bitcoin,
    dogecoin,
    flare-network,
    smart-contracts,
  ]","import Tabs from ""@theme/Tabs"";
import TabItem from ""@theme/TabItem"";
import DocCardList from ""@theme/DocCardList"";
import SolidityReference from ""@site/src/components/DataTables/SolidityReference"";

## Deployed Contracts

<Tabs block>
    <TabItem value=""flare"" label=""Flare Mainnet"">

        |         **Contract** | **Address** | **Description** |
        | -------------------: | ----------- | --------------- |
        | `AgentOwnerRegistry` | -           | -               |
        |               `FXRP` | -           | -               |
        |               `USDX` | -           | -               |


    </TabItem>
    <TabItem value=""coston2"" label=""Flare Testnet Coston2"">

        |         **Contract** | **Address** | **Description** |
        | -------------------: | ----------- | --------------- |
        | `AgentOwnerRegistry` | -           | -               |
        |               `FXRP` | -           | -               |
        |               `USDX` | -           | -               |


    </TabItem>
    <TabItem value=""songbird"" label=""Songbird Canary-Network"" default>

        |         **Contract** | **Address**                                                                                                                                | **Description**                                                                                                                          |
        | -------------------: | ------------------------------------------------------------------------------------------------------------------------------------------ | ---------------------------------------------------------------------------------------------------------------------------------------- |
        | `AgentOwnerRegistry` | [`0xa7f5d3C81f55f2b072FB62a0D4A03317BFd1a3c0`](https://songbird-explorer.flare.network/address/0xa7f5d3C81f55f2b072FB62a0D4A03317BFd1a3c0) | Manages agent whitelisting and allows setting and retrieving details such as work and management addresses, name, description, and icon. |
        |   `AssetManager_XRP` | [`0x299d678f67e7ADD4efdf295Ebe0E92FCb4f75C4c`](https://songbird-explorer.flare.network/address/0x299d678f67e7ADD4efdf295Ebe0E92FCb4f75C4c) | Smart ontract that can mint and burn FXRP while managing collateral and backing funds. |
        |               `FXRP` | [`0xF9a84f4ec903F4EaB117A9c1098BeC078BA7027d`](https://songbird-explorer.flare.network/address/0xF9a84f4ec903F4EaB117A9c1098BeC078BA7027d) | The FAsset-wrapped XRP token, ready for use on Songbird.                                                                             |
        | `AssetManager_FDOGE` | [`0x866077dC52445167dC971643c1b2910608eD0C5A`](https://songbird-explorer.flare.network/address/0x866077dC52445167dC971643c1b2910608eD0C5A) | Smart ontract that can mint and burn FDOGE while managing collateral and backing funds. |
        |              `FDOGE` | [`0xaa25ee3B68c515e69A463876Ab262bc4e8339030`](https://songbird-explorer.flare.network/address/0xaa25ee3B68c515e69A463876Ab262bc4e8339030) | The FAsset-wrapped DOGE token, ready for use on Songbird.                                                                             |
        |               `USDX` | [`0x4A771Cc1a39FDd8AA08B8EA51F7Fd412e73B3d2B`](https://songbird-explorer.flare.network/address/0x4A771Cc1a39FDd8AA08B8EA51F7Fd412e73B3d2B) | ERC-20 token used by FAssets as vault collateral.                                                                                                            |

    </TabItem>
    <TabItem value=""coston"" label=""Songbird Testnet Coston"">

        |         **Contract** | **Address** | **Description** |
        | -------------------: | ----------- | --------------- |
        | `AgentOwnerRegistry` | -           | -               |
        |               `FXRP` | -           | -               |
        |               `USDX` | -           | -               |

    </TabItem>

</Tabs>

## Interfaces

<DocCardList />",2025-03-08 01:27:14
7-songbird.mdx,"title: FAssets on Songbird
description: Participate in the FAssets open beta.
keywords: [fassets, xrp, bitcoin, dogecoin, flare-network]","import JiraIssueCollector from ""/src/components/JiraIssueCollector"";

The launch of FAssets on Songbird Canary-Network demonstrates system behavior while paving the way for its next deployment on Flare Mainnet. The primary goals of this test are to ensure the system operates as intended, identify edge cases, refine usability and automation, and incentivize whitehat security researchers to uncover potential code errors.

The test on Songbird Canary-Network will have the following characteristics:

| Parameters                          | Description                                                                                                                                                                                                                              |
| ----------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| FAsset Sequence                     | XRP will be tested first, followed by either BTC or DOGE.                                                                                                                                                                                |
| Agent Whitelisting                  | FAssets agents must be whitelisted by Flare Labs to perform their roles.                                                                                                                                                                 |
| Caps and Losses                     | Flare Labs will underwrite up to \$300,000 in FAsset issuance to cover any losses resulting from system issues, while imposing a cap of $2 million in issuance per asset.                                                                |
| Duration of the Test                | Each FAsset will be tested on Songbird for at least 6 weeks until no issues have been found.                                                                                                                                             |
| FAssets Minting dApps               | FAssets system users can access the frontend web interface for minting and redeeming: <br/> - [`https://fasset.oracle-daemon.com/sgb`](https://fasset.oracle-daemon.com/sgb) <br /> - [`https://fassets.au.cc/`](https://fassets.au.cc/) |
| System Integrity and FAsset Pricing | During the Songbird test, restrictions and incentives may cause the FAsset price to deviate from the underlying currency's value. The current focus is on testing system integrity, not price alignment.                                 |
| Vault Collateral                    | USDX will serve as collateral for FAsset agent vaults. To ensure sufficient support for FAsset issuance and possible liquidations on Songbird, a large amount of USDX has been minted.                                                   |

:::tip[Help improve FAssets]

To participate, begin by joining the Flare Network FAssets Songbird [Telegram channel](https://t.me/FlareSupport) or contact [support@flarelabs.org](mailto:support@flarelabs.org).

<JiraIssueCollector />

:::",2025-03-08 01:27:14
5-faq.mdx,"sidebar_position: 5
slug: faq
title: FAssets Agent FAQs
description: Frequently Asked Questions by FAssets Agents.
tags: [intermediate, fassets, bitcoin, dogecoin]
authors: [fassko]
keywords: [fassets, xrp, btc, doge flare-network, flare-network]","### How to set up FAssets agent?

Refer to the [FAssets Agent Setup Guide](/fassets/guides/deploy-fassets-agent).

### What are the FAssets agent icon file requirements?

A link to your FAssets agent icon should end with `.png`, `.jpg`, `.svg`, etc., and **must not** be the same as the example provided by the bot.

### Can an agent's logo, description, or name be changed after approval?

No, it is not.

### Can I register a new management address if one is already whitelisted in my Telegram account?

No, you would need a new Telegram account.

### What is a management address?

It is an EVM address you control. Ensure your seed phrase remains secure.

### What is an owner's address, and is it different from a work address?

Work and owner addresses are the same and are referred to as `owner.native.address` in your `secrets.json` file. This address provides collateral for your vault and pool.

### How can I change the agent's fees?

Use the command:

```bash
updateAgentSetting <agentVaultAddress> <agentSettingName> <agentSettingValue>
```

Alternatively, update your `tmp.agent-settings.json` file.

### Do I need my agent running all the time?

Yes, for an agent to stay operational, it must run continuously.

### What should I do if my agent database is corrupted, lost, or deleted?

Do not restart the agent, as this may result in double payments.
The current solution is duplicating the database and launching a new agent instance.
You should monitor your database closely and, if access is lost, remove the agent from the available list, self-close FAssets, and backup agent keys.

### Is there a minimum history needed in the Data Availability Layer for agents?

No minimum history is required; it can be set to the latest block.
You need to start the [Data Availability Layer](/fdc/overview#data-availability-layer) before you can participate as an FAsset agent.",2025-03-08 01:27:14
1-deploy-fassets-agent.mdx,"sidebar_position: 1
slug: deploy-fassets-agent
title: Deploy an FAssets Agent
description: Deploy and run an FAssets agent.
tags: [intermediate, fassets, bitcoin, dogecoin]
authors: [fassko]
keywords: [fassets, xrp, btc, doge flare-network, flare-network]","import RestartDocker from ""./_restart_docker.mdx"";

The FAssets system by Flare enables non-smart contract tokens like BTC and XRP to interact trustlessly with smart contracts on the Flare network, unlocking their use in DeFi applications. It achieves this through collateralized minting, utilizing [Flare Data Connector (FDC)](/fdc/overview) and [Flare Time Series Oracle (FTSO)](/ftso/overview) for secure cross-chain functionality.

Agents in the FAssets system facilitate the minting and redemption of FAssets by providing over-collateralized assets and managing transactions securely. A liquidator in the FAssets system monitors agent's collateralization levels to ensure the system's security and trustlessness.

In this guide, you will learn the preferred methods for setting up and managing the FAssets agents using the frontend interface and running the liquidator bot.

## Prerequisites

### Hardware

The server should have a minimum of 2 CPUs and 4 GB of RAM and be built on AMD64 architecture running a Linux operating system.
It also requires at least 40 GB of disk space to accommodate the FAssets agent and its dependencies

Recommended Providers: Linode, DigitalOcean, AWS, GCP.

### Software

Ensure you have installed Docker version 25.0.4 or higher and Docker Compose version v2.24.7 or higher.
Setting up and running the FAssets agent is accomplished by using Docker containers, so knowledge of Docker is essential.
Using Docker eliminates the need to manage tool versions and their compatibilities.

### Financials

To participate, ensure you meet the following minimum deposit requirements:

- **Songbird Tokens (SGB):** Deposit a minimum of 1,000 SGB into the `owner.native.address` specified in the `secrets.json` file.

- **USDX Tokens:** Agents must deposit a USDX as vault collateral tokens into the `owner.native.address`.

- **XRP Tokens:** For XRP agents, you need to deposit 500 XRP Ledger native tokens (XRP) into the `owner.XRP.address`.

- **Bitcoin (BTC):** Bitcoin agents should hold at least 0.005 BTC to cover potential high transaction fees in the `owner.BTC.address`.

- **Dogecoin (DOGE):** Doge agents should maintain a minimum balance of 100 DOGE to cover potential high transaction fees in the `owner.DOGE.address`.

Additionally, please ensure there is sufficient collateral for vault and pool requirements at the `owner.native.address`.

### Contract Addresses

See the [FAssets Reference](/fassets/reference) for important FAssets smart contract addresses representing tokens and notable system components, provided for your convenience during the Open Beta on the Songbird network.

## Setting Up

Follow these steps to set up the FAssets agent using Docker:

1. Clone the repository in your Linux server:

   ```bash
   git clone https://github.com/flare-labs-ltd/fasset-bots-deploy
   cd fasset-bots-deploy
   ```

2. Set up the environment file:

   ```bash
   cp .env.template .env
   ```

3. Set up the configuration file:

   ```bash
   ./populate_config.sh
   ```

4. Login into GitHub Container Registry:

   ```bash
   docker login ghcr.io
   ```

5. Get the latest docker containers from the registry:

   ```bash
   docker compose pull
   ```

### Setting Environment Variables

To begin using the FAssets Docker infrastructure, you must configure the settings in the `.env` environment file.

- Make sure to set the machine address in the `.env` file using the `MACHINE_ADDRESS` variable.
- Set the database password `FASSET_DB_PASSWORD`.

:::warning
Once the database is created, the password will not change if you modify it in the `.env` file.
:::

#### Optional Settings

You can configure several optional settings in the `.env` environment file.

## Setting up Secret Keys

The FAsset agents require multiple keys for the Flare and underlying network chains, which must be generated to make the agent operational.

1. Create a new management wallet or use an existing one, preferably a cold wallet, as the management address for your agent.
2. Generate the secrets using this command by replacing the `MANAGEMENT_WALLET_ADDRESS` with your management wallet address:

   ```bash
   ./generate_secrets.sh MANAGEMENT_WALLET_ADDRESS
   ```

3. Copy the `secrets.new.json` to `secrets.json`:

   ```bash
   cp secrets.new.json secrets.json
   ```

4. Allow the user to read and write `secrets.json`:

   ```bash
   chmod 600 secrets.json
   ```

5. Set file ownership to user ID 1000, the default Linux user ID, for proper permissions:

   ```bash
   sudo chown 1000:1000 secrets.json
   ```

6. Make a backup of the `secrets.json` file and store it securely.

## Setting the File Permissions

Set the file permissions for the `log` directory:

```bash
sudo chown 1000:1000 log -R
```

## Whitelist the Management Address

:::info
Given our current insurance mechanisms to protect users, Flare Labs will not add any more agents to the FAssets protocol on Songbird.
As covered in this [blog](https://flare.network/fxrp-is-live-on-songbird/), Flare Labs will cover losses up to \$100,000 per asset, for a total coverage of $300,000.
We appreciate the interest received and look forward to onboarding agents once we have launched FAssets on Flare mainnet.
:::

To access the FAssets system, you must be whitelisted for security reasons.

1. Use the [FlareFAssetsSongbirdBot Telegram channel](https://t.me/FlareFAssetsSongbirdBot), specifically designed for registration, and provide the necessary information.
2. Enter the information and confirm, and the Telegram bot will inform you about the successful process.
3. You need to wait for the Flare team to approve registrations.
4. If the information you entered is correct, the Telegram Bot will notify you that you have been whitelisted for the FAssets Songbird.

### Check Whitelist Status

Checking if your agent's management address has been whitelisted is straightforward. Follow these steps:

1. Navigate with the block explorer to the [`AgentOwnerRegistry`](/fassets/reference#deployed-contracts) contract and open the Read Contract tab.
2. Connect your wallet with any address to the block explorer so you can gain access to read functions from the smart contract.
3. Execute the `isWhitelisted` function with the value of the management address. This function returns `bool`: `true` for whitelisted or `false` for not whitelisted.

## Set the Work Address

After you have completed with the whitelisting process, you need to set the work address for your agent.
Configuring the native address links your agent's work address to the management address and grants access.

1. Navigate with the block explorer to the [`AgentOwnerRegistry`](/fassets/reference#deployed-contracts) contract and open the Write Contract tab.
2. Connect the management address wallet you used to generate the access keys above.
3. Register the work address by executing the `setWorkAddress` function with the value of `owner.native.address` from the `secrets.json` file.

## Configure the RPCs

In order to connect to various blockchains, you need to configure the Remote Procedure Call (RPC) configurations.

You can obtain the `xrp_rpc` for the XRP Ledger, `btc_rpc` for Bitcoin, and `doge_rpc` for Dogecoin from the Flare team, configured in the `secrets.json` file under the `apiKey` key.

## Configure the Server

To access the FAssets admin interface, configure the server to route requests to both the frontend and backend.
Allow requests on the default port of `4000` for the backend and `3000` for the frontend.

:::warning

When configuring the server for FAssets, ensure all **security measures** are implemented to safeguard your system. Exposing the FAssets backend can lead to severe vulnerabilities.

- **Never expose the FAssets agent interface (`/fasset-backend`) to the public network**.
- As a rule of thumb, restrict access to the backend **only** within the local network.
- Use firewalls and IP-based access controls to allow requests **only** from trusted IP addresses.
- Consider enabling IP whitelisting for specific addresses to restrict access.

:::

## Start the FAssets Agent

Start the FAssets agent using the Docker infrastructure by running the following command:

```bash
docker compose up -d
```

## Execute FAsset Bot Commands

To run commands for the FAsset bot, please use the `cli` profile.

Use the specific Docker container:

- the `agent-bot` for the FAsset agent bot;
- the `user-bot` for the FAsset user bot.

### Execute Agent Bot Commands

To execute agent bot commands, use the `cli` profile with the `agent-bot` Docker container.
For example, to get the FAssets system running agents, use this command:

```bash
docker compose --profile cli run agent-bot listAgents --fasset FASSET
```

Full reference for the agent bot commands can be found in the [Agent Bot CLI Reference](/fassets/reference/agent-bot).

### Execute User Bot Commands

To execute user bot commands, use the `cli` profile and the `user-bot` Docker container.
For example, to retrieve FAsset system info, use this command:

```bash
docker compose --profile cli run user-bot info --fasset FASSET
```

### Update the FAssets Agent

<RestartDocker />

## Access the Agent Frontend

You can access the FAssets agent frontend user interface by navigating to the `FRONTEND_URL` in your browser.
You will be prompted to enter the password set in the `.env` file.

Refer to the [Create FAssets Agent via UI](/fassets/guides/create-fasset-agent-ui) guide for more information on the user interface.

:::tip[What's next]

If you need to refresh your knowledge about FAssets, you can explore the various components and processes involved, such as [collateral](/fassets/collateral), [minting](/fassets/minting), [redemptions](/fassets/redemption), and [liquidations](/fassets/liquidation).

Additionally, if you have questions while setting up your FAssets agent, be sure to check out the [FAQ page](/fassets/guides/faq) for answers and guidance.

:::",2025-03-08 01:27:14
3-create-fasset-agent-cli.mdx,"sidebar_position: 3
slug: create-fasset-agent-cli
title: Create FAssets Agent via CLI
description: Set up and manage an FAssets agent using the CLI.
tags: [intermediate, fassets, bitcoin, dogecoin]
authors: [fassko]
keywords: [fassets, xrp, btc, doge flare-network, flare-network]","The FAssets Bots CLI allows you to create and manage FAssets agent bots and user tools directly from the command line. It also allows you to monitor the agent bot, create FAssets agent vaults, and interact with the FAssets system efficiently.

You can access the FAssets Agent CLI after you follow the guide on how to [set up the FAssets agent](/fassets/guides/deploy-fassets-agent).

:::info

Learn how to use the FAssets Agent CLI as a [Docker service](/fassets/guides/deploy-fassets-agent#execute-fasset-bot-commands).

:::

### Configure the Agent

You need to set up your agent's parameters like name, collateral, and fund with underlying assets.

1.  Prepare the agent settings `tmp.agent-settings.json` exchanging `FASSET` with `FXRP`, `FBTC` or `FDOGE` according to which underlying network you want to work on:

    ```bash
    docker compose --profile cli run agent-bot --fasset FASSET create --prepare
    ```

2.  Choose a suffix for your agent's collateral pool and fill in the `poolTokenSuffix` field in the `tmp.agent-settings.json`.
    The `poolTokenSuffix` should only include uppercase letters, numbers, and the `-` symbol.
    This suffix will be used for the FAsset Collateral Pool Token. For example, for `FXRP`, if you use `MY-ALPHA-AGENT-1`, it would be `FCPT-XRP-MY-ALPHA-AGENT-1`.

3.  The `USDX` is used to back up the agent vault collateral.

4.  In the `secrets.json` file, the `owner.XRP.address`, `owner.BTC.address`, and `owner.DOGE.address` fields represent the underlying accounts that will pay transaction fees for XRP, BTC, and DOGE, respectively.

5.  Create the agent by specifying the FAsset and agent settings, noting that this operation can take up to 10 minutes because the FAssets verifies the underlying assets.
    This command will print out your agent's address.
    Exchange `FASSET` with `FXRP`, `FBTC` or `FDOGE` according to which underlying network you are creating the agent.

        ```bash
        docker compose --profile cli run agent-bot --fasset FASSET create tmp.agent-settings.json
        ```

### Deposit Collateral

To make your newly created agent public, it must hold enough [collateral](/fassets/collateral) to mint one lot.
This means its agent vault contract needs to be funded with the two collaterals (CFLR and a `USDX`) held by your `owner.native.address`.

You have two options: either deposit the vault collateral and buy pool collateral separately or use the system function to calculate the needed collateral for you.

#### Deposit Collaterals Together

To deposit both vault and pool collateral together and let the tool calculate the minimum required collateral to back the lots, you can use the `depositCollateral` function to the agent, specifying your created agent address in the `AGENT_ADDRESS` and lot size in the `LOTS`, as well exchange `FASSET` with `FXRP`, `FBTC` or `FDOGE` according to which underlying network you are creating the agent:

```bash
docker compose --profile cli run agent-bot depositCollaterals AGENT_ADDRESS LOTS --fasset FASSET
```

#### Deposit Collateral Separately

1. Deposit enough vault collateral to the agent specifying your created agent address in the `AGENT_ADDRESS` and the amount of the stablecoin or wrapped ETH in the `AMOUNT` field, as well exchange `FASSET` with `FXRP`, `FBTC` or `FDOGE` according to which underlying network you are creating the agent.

   ```bash
   docker compose --profile cli run agent-bot depositVaultCollateral AGENT_ADDRESS AMOUNT --fasset FASSET
   ```

2. Buy enough pool collateral for the agent specifying your agent's address in the `AGENT_ADDRESS` and the amount of the CFLR in the `CFLR_AMOUNT` field, as well exchange `FASSET` with `FXRP`, `FBTC` or `FDOGE` according to which underlying network you are creating the agent.

   ```bash
   docker compose --profile cli run agent-bot buyPoolCollateral AGENT_ADDRESS CFLR_AMOUNT --fasset FASSET
   ```

### Register the Agent as Available

You need to make your agent available to mint and redeem FAssets.

1. Register your agent as available to the network by executing this command replacing the `AGENT_ADDRESS` with your agent address, as well exchange `FASSET` with `FXRP`, `FBTC` or `FDOGE` according to which underlying network you are entering the agent:

   ```bash
   docker compose --profile cli run agent-bot enter AGENT_ADDRESS --fasset FASSET
   ```

2. If you deposited enough collateral, you should see that your agent has at least one lot available by running the command replacing `FASSET` with `FXRP`, `FBTC` or `FDOGE` according to which underlying network you are running the agent.

   ```bash
   docker compose --profile cli run user-bot agents --fasset FASSET
   ```

If you don't have available lots, check if the vault and pool collaterals are enough.

:::tip[What's next]

You can use the [FAssets Agent UI](/fassets/guides/create-fasset-agent-ui) to manage your agent vaults, monitor the agent bot, and perform various actions related to the FAssets agent.

:::",2025-03-08 01:27:14
2-create-fasset-agent-ui.mdx,"sidebar_position: 2
slug: create-fasset-agent-ui
title: Create FAssets Agent via UI
description: Set up and manage an FAssets agent using the frontend UI.
tags: [intermediate, fassets, bitcoin, dogecoin]
authors: [fassko]
keywords: [fassets, xrp, btc, doge flare-network, flare-network]","import FAssetsAgentInterface from ""/static/img/fassets/fassets-agent.png"";
import FAssetsAgentInterfaceAddVault from ""/static/img/fassets/fassets-agent-add-vault.png"";
import FAssetsAgentInterfaceAddVaultForm from ""/static/img/fassets/fassets-agent-add-vault-form.png"";
import FAssetsAgentInterfaceVaultOperations from ""/static/img/fassets/fassets-agent-vault-operations.png"";

The FAssets Agent user interface (UI) is designed to provide a seamless and intuitive experience for users managing the FAssets agent. It allows users to monitor the agent bot and create and manage FAssets agent vaults.

You can access the FAssets Agent UI after you follow the guide how to [set up the FAssets agent](/fassets/guides/deploy-fassets-agent).

<img src={FAssetsAgentInterface} />

## Creating Agent Vault

To create a new agent vault, click on the three dots under the Actions menu in the Agent Bots list, then select the ""Add Vault"" button.

<img src={FAssetsAgentInterfaceAddVault} />

You will be prompted to enter the required information for the vault.

<img src={FAssetsAgentInterfaceAddVaultForm} />

Once you have saved the information and initiated the process, please allow some time for the Flare Data Connector (FDC) to verify the details and create the vault. This can take up to five minutes. You can monitor the status of the vault creation in the Agent Bots list.

## Changing Agent Vault Settings

1. In the **Vaults** section on the dashboard, locate the agent vault you want to modify, and click the three dots icon in the **Actions** column.
   The **Vault options** menu is displayed.

   <img src={FAssetsAgentInterfaceVaultOperations} />

2. In the **Vaults** section on the dashboard, locate the agent vault you want to modify, and click the three dots icon in the **Actions** column.
   The **Vault options** menu is displayed.

3. Click **Edit** at the top of the page.

4. Update your settings.
   These settings always have time locks to minimize abuse.
   During the Open Beta, the time-locks are further reduced so that you can try different configurations.
   Before you save your updates, ensure you understand the time-locks associated with settings you are changing.

5. Click **Save and execute**.

## Depositing Vault Collateral

1. In the **Vaults** section on the dashboard, locate the vault you want to update, and click the three dots icon in the **Actions** column.
   The **Vault options** menu is displayed.

2. In the **Agent Vault Operations** section you have three options:

   - **Deposit Collateral (Lots)**: Deposit collateral into the vault in lots.
   - **Deposit Vault Collateral**: Deposit collateral into the agent vault.
   - **Deposit Pool Collateral**: Deposit collateral into the agent pool.

## Activating Vault

Activating a vault makes it publicly available for minting FAssets.
To be activated, a vault must contain at least 1 [lot](/fassets/minting#lots) for minting. To activate a vault:

1. On the dashboard, locate the vault you want to activate, and click the three dots icon in the **Actions** column.
   The **Vault options** menu is displayed.
2. In the **Agent Vault Operations** section, click **Activate Vault (Enter)**.
   The **Activate Vault** window is displayed.
3. Read the message in the **Activate Vault** window about minting requirements, ensure your vault contains at least 1 lot to meet the requirement, and then click **Confirm** to activate the vault.
   A confirmation message is displayed.

## Closing Vaults

Closing a vault makes it unavailable for minting FAssets. To close a vault:

    1. On the dashboard, locate the vault you want to close, and click the three dots icon in the **Actions** column.
        The **Vault options** menu is displayed.
    2. In the **Agent Vault Operations** section, click **Close Vault (Exit)**.
        The **Deactivate Vault** window is displayed.
    3. Ensure you want to close the vault, and click **Confirm** to close it.
        A confirmation message is displayed.

:::tip[What's next]

You can use the FAssets Agent UI to manage your agent vaults, monitor the agent bot, and perform various actions related to the FAssets agent.

:::",2025-03-08 01:27:14
_restart_docker.mdx,,"To restart and update the FAssets agent, execute the following commands, replacing `FASSET` with the name of the FAsset (FXRP, FDOGE, or FBTC):

```bash
docker compose down
git pull
docker compose pull
docker compose --profile cli run agent-bot listAgents --fasset FASSET
docker compose up -d
```
",2025-03-08 01:27:14
6-export-private-keys.mdx,"sidebar_position: 6
slug: export-private-keys
title: Export Private Keys
description: Export private keys for minting and redeeming
tags: [intermediate, fassets, bitcoin, dogecoin]
authors: [fassko]
keywords: [fassets, xrp, btc, doge flare-network, flare-network]","This guide explains how to export the private keys for the FAssets agent's underlying address by specifying the export file in the Docker container setup. This process is essential if you need to migrate your FAssets agent after full liquidation.

1. Create a directory named `export` to export the private keys.
2. Assign ownership of the directory to user ID 1000 by setting the appropriate permissions:

   ```bash
   sudo chown 1000:1000 export -R
   ```

3. Execute the following command to export the private keys and mount the export path to the Docker container:

   ```bash
   docker-compose --profile cli run -v $(pwd)/export:/export agent-bot exportPrivateKeys /export/keys.tmp --fasset FXRP
   ```",2025-03-08 01:27:14
7-agent-bot-notifications.mdx,"sidebar_position: 7
slug: agent-bot-notifications
title: Agent Bot Notifications
description: Learn how to set up agent bot notifications for FAssets.
tags: [intermediate, fassets, bitcoin, dogecoin]
authors: [fassko]
keywords: [fassets, xrp, btc, doge flare-network, flare-network]","The agent bot can send notifications to a Telegram bot or API endpoint.
It helps monitor the health of the agent and the network.

## Agent Bot Notifications Configuration

1. Add the following configuration to the `apiNotifierConfigs` list in the `config.json` file:

   ```json
   {
     ""apiUrl"": ""NOTIFICATIONS_API_URL"",
     ""apiKey"": ""API_KEY"",
     ""level"": ""danger""
   }
   ```

   If the level field is omitted inside configuration, the bot will default it to `danger`.

2. The `apiUrl` field specifies the URL to send the notifications to.
   The bot will send the notifications as POST requests to the `/api/agent/botAlert` endpoint.

3. The `apiKey` is sent in the header under `x-apikey`.
   The `level` field specifies the minimum level of alerts to send.
   If the `level` field is omitted, the bot will default it to `danger`.

4. The agent bot can send notifications as POST requests to the endpoint `apiUrl/api/agent/botAlert` with the following body:

   ```typescript
   PostAlert = {
     bot_type: string,
     address: string,
     level: string,
     title: string,
     description: string,
   };
   ```

## Flare Hosted Telegram Notifications Alert Configuration

1. Get the API key from the [FAssets Telegram Bot](http://t.me/FlareFAssetsSongbirdBot) by sending `/events` and selecting `Subscribe to Events`.
2. Add the following configuration to the `apiNotifierConfigs` list in the `config.json` file, replacing `API_KEY` with the key obtained from the bot.

   ```json
   {
     ""apiUrl"": ""https://fasset-tg-bot-songbird.flare.network"",
     ""apiKey"": ""API_KEY"",
     ""level"": ""danger""
   }
   ```

   Notifications will only be sent out for `danger` and `critical` levels, regardless of the configured level.
   This is enforced by the Telegram bot, which delivers priority messages due to heavy load.",2025-03-08 01:27:14
8-infrastructure.mdx,"sidebar_position: 8
slug: infrastructure
title: FAssets Agent Infrastructure
description: Configuring the FAsset Bot to Use Custom Infrastructure
tags: [intermediate, fassets, bitcoin, dogecoin]
authors: [fassko]
keywords: [fassets, xrp, btc, doge flare-network, flare-network]","import RestartDocker from ""./_restart_docker.mdx"";

By default, the FAsset bot operates on Flare infrastructure.
This guide explains how to configure it to utilize your own infrastructure for enhanced performance and reliability.

## Prerequisites

- [Running an RPC node](/run-node/rpc-node)
- [Configure FTSO data provider](/run-node/ftso-data-provider)
- [Configuring FDC attestation provider](/run-node/fdc-attestation-provider)
- [Setting up DAL](https://github.com/flare-foundation/data-availability)

## Setting Up

1.  Update `config.json`

    Update the `config.json` file to include your own URLs for the data access layer, RPC, and verifier.

    Replace the following URLs with your own:

        - Substitute the Data Availability Layer URL with the URL for your Data Access Layer.
        - Update the Songbird RPC URL with your RPC endpoint.
        - Replace your verifier URL with your verifier endpoint both for FXRP and FDOGE.

    ```json
    {
      ""dataAccessLayerUrls"": [
        ""Data Availability Layer URL"",
        ""https://sgb-data-availability.flare.network""
      ],
      ""rpcUrl"": ""Songbird RPC URL"",
      ""fAssets"": {
        ""FXRP"": {
          ""indexerUrls"": [
            ""Verifier URL"",
            ""https://fdc-verifiers-mainnet.flare.network/verifier/xrp""
          ]
        },
        ""FDOGE"": {
          ""indexerUrls"": [
            ""Verifier URL"",
            ""https://fdc-verifiers-mainnet.flare.network/verifier/doge""
          ]
        }
      }
    }
    ```

2.  Update `secrets.json`

    Ensure your API keys are correctly set in the `secrets.json` file:

    ```json
    {
      ""indexer"": [""Your API key"", ""Flare API key""],
      ""data_access_layer"": [""Your API key"", ""Flare API key""],
      ""native_rpc"": ""your Songbird API key""
    }
    ```

    Replace the following: - Substitute your API key with your own custom API key(s) for indexers and data access layers. - Replace your Songbird API key with your RPC API key.

    :::warning

        The API keys must align with the corresponding URLs in dataAccessLayerUrls and indexerUrls. For example, the first API key in indexer should match the first verifier URL in indexerUrls.

        Currently, only a single RPC URL is supported.
        Multiple RPC URLs are not supported yet.

3.  Restart Docker Containers

    <RestartDocker />",2025-03-08 01:27:14
4-custom-handshake.mdx,"sidebar_position: 4
slug: custom-handshake
title: Implement Custom Handshake
description: Implement compliance checks for minting and redeeming.
tags: [intermediate, fassets, bitcoin, dogecoin]
authors: [fassko]
keywords: [fassets, xrp, btc, doge flare-network, flare-network]","The [Handshake](/fassets/minting#handshake) in the FAsset system is an optional step where an agent verifies the minter's or redeemer's address using an external service to ensure compliance (e.g., sanctions checks) before proceeding with minting or redemption. If enabled, the agent must approve the provided address within a set time; failure to respond allows the user to cancel or proceed based on system rules.

FAssets agents can establish custom handshake mechanisms for verifying minters and redeemers. The most straightforward approach is to create a separate web service that exposes an API which accepts two parameters:

- API service URL
- Address that requires verification

You need to configure the `kyc` block in the `secrets.json` file.

```json
""kyc"": {
    ""url"": """",
    ""api_key"": """"
}
```

The `url` field represents the web service link, while the `api_key` field is sent as a custom header using the variable `Token`.

:::info

You can check [`HandshakeAddressVerifier.ts`](https://github.com/flare-labs-ltd/fasset-bots/blob/main/packages/fasset-bots-core/src/actors/plugins/HandshakeAddressVerifier.ts) for implementation details related to the `ChainalysisClient` class in the [fasset-bots](https://github.com/flare-labs-ltd/fasset-bots) repo.

:::",2025-03-08 01:27:14
IAssetManager.mdx,"title: IAssetManager
description: FAssets IAssetManager interface reference.
keywords: [fassets, xrp, bitcoin, dogecoin, flare-network]","Command line reference for managing and interacting with FAssets `IAssetManager`.

Sourced from `IAssetManager.sol` on [GitHub](https://github.com/flare-labs-ltd/fassets/blob/main/contracts/userInterfaces/IAssetManager.sol).

## Functions

### `getSettings`

Returns the complete asset manager settings.
Returns the [`AssetManagerSettings`](https://github.com/flare-labs-ltd/fassets/blob/main/contracts/userInterfaces/data/AssetManagerSettings.sol) struct.

```solidity
function getSettings()
    external view
    returns (AssetManagerSettings.Data memory);
```

### `getAgentInfo`

Return detailed info about an agent.
Returns the [`AgentInfo`](https://github.com/flare-labs-ltd/fassets/blob/main/contracts/userInterfaces/data/AgentInfo.sol) struct.
Need to provide the agent vault address.

```solidity
function getAgentInfo(address _agentVault)
    external view
    returns (AgentInfo.Info memory);
```",2025-03-08 01:27:14
user-bot.mdx,"title: User Bot CLI Reference
description: FAssets User Bot command line interface reference.
keywords: [fassets, xrp, bitcoin, dogecoin, flare-network]","Command line reference for managing and interacting with FAssets user bot. It allows users to mint and redeem FAssets, manage collateral pools, and query system information.

Sourced from `user-bot.ts` on [GitHub](https://github.com/flare-labs-ltd/fasset-bots/blob/main/packages/fasset-bots-cli/src/cli/user-bot.ts).

## Setup

Before running user-bot, ensure it is properly set up using the [FAsset agent deploy](/fassets/guides/deploy-fassets-agent) with Docker and then learn [how to execute the command line commands](/fassets/guides/deploy-fassets-agent#execute-fasset-bot-commands).

## Usage

To run the user-bot command line interface, use the `yarn user-bot` command with the desired command and arguments and add the `--fasset` flag with the FAsset symbol.

```bash
yarn user-bot [command] <args> --fasset [fAssetSymbol]
```

To list all available commands:

```bash
yarn user-bot help
```

To execute a specific command using the [Docker container](/fassets/guides/deploy-fassets-agent#execute-fasset-bot-commands) change `yarn user-bot` with `docker compose --profile cli run user-bot`:

```bash
docker compose --profile cli run user-bot [command] <args> --fasset [fAssetSymbol]
```

## General Commands

## System Info

Display information about the FAssets system.

```bash
yarn user-bot info
```

### List Agents

List available FAssets agents.

```bash
yarn user-bot agents
```

### Agent Information

Display information about a specific FAssets agent by providing the agent vault address.

```bash
yarn user-bot agentInfo <agentVaultAddress>
```

### Minting

### Mint

Mint the specified number of FAsset lots, specifying the number of lots to mint.

```bash
yarn user-bot mint <numberOfLots>
```

When executing the `mint` command, the following custom flags can be specified:

- **`-a <agentVaultAddress>`**  
  Specifies the agent for minting. If omitted, the bot automatically selects the agent with the lowest fee and sufficient capacity.

- **`--executor <executorAddress>`** _(Optional)_  
  Specifies the executor's native address.

- **`--executorFee <executorFee>`** _(Optional)_  
  Specifies the executor's fee in NAT.

- **`--noWait`**  
   Reserves and pays for minting without waiting for proof.

### Mint Execute

The `mintExecute` function is essential for completing the minting process.
It handles the minting of FAssets, distributes fees, and unlocks collateral.

This function ensures the following:

- The minter receives their minted FAssets after payment is confirmed.
- Agents and collateral providers are compensated for their involvement.
- System stability is maintained by requiring proof of underlying payments.

Using this function need to specify the `requestId` of the minting request.

```bash
yarn user-bot mintExecute <requestId>
```

### Mint Status

The `mintStatus` function provides information about the current state of a minting request.
It helps to track the progress of the minting process.

```bash
yarn user-bot mintStatus
```

### Update Mintings

The `updateMintings` function updates the status of all open minting requests in the FAsset system.
It ensures that the system remains up-to-date by resolving minting requests based on their current state or conditions, such as time expiration or payment verification.

```bash
yarn user-bot updateMintings
```

## Redemption

### Redeem

The `redeem` function enables FAsset holders to burn their FAssets in exchange for the equivalent amount of the underlying asset.
This ensures that FAssets can be converted to their original value on the underlying blockchain.
To redeem, specify the number of FAsset lots you wish to exchange.

```bash
yarn user-bot redeem <numberOfLots>
```

When executing the `redeem` command, the following custom flags can be specified:

- **`--executor <executorAddress>`** _(Optional)_  
   Specifies the executor's native address.

- **`--executorFee <executorFee>`** _(Optional)_  
   Specifies the executor's fee in NAT.

### Redemption Default

The `redemptionDefault` function is invoked when an agent fails to fulfill their obligation to deliver the underlying asset during a redemption process.
This function ensures that the redeemer is compensated, system integrity is maintained, and the agent is penalized for failing to meet their commitment.

Specify the `requestId` of the redemption request.

```bash
yarn user-bot redemptionDefault <requestId>
```

Additionally the custom flag can be specified:

- **`--noWait`\***
  Does not wait for non-payment proof. don't wait for non-payment proof, but immediately exit with exitcode 10 if the proof isn't available

### Redemption Status

The `redemptionStatus` function provides information about the current state of a redemption request in the FAsset system. It lists all open redemptions and their statuses.

Status can be one of the following:

- `PENDING`
- `SUCCESS`
- `DEFAULT`
- `EXPIRED`

```bash
yarn user-bot redemptionStatus
```

Additionally, the custom flag can be specified:

- **`--request-id <requestId>`**  
  Specifies the request ID of the redemption.

### Update Redemptions

The `updateRedemptions` function updates the status of one or more open redemption requests. It ensures that these requests are processed efficiently and appropriately addresses any unresolved or overdue requests. This function is essential for automating the entire redemption lifecycle.

```bash
yarn user-bot updateRedemptions
```

## Collateral Pool Management

### List Collateral Pools

Lists all available collateral pools, including:

- Pool address
- Token symbol
- Token price (CFLR)
- Collateral (CFLR)
- Fees (FXRP)
- Collateral Ratio

```bash
yarn user-bot pools
```

### Pool Holdings

The 'poolHoldings' function provides detailed information about the pools that user has holdings, listing:

- Pool address
- Token symbol
- Pool tokens

```bash
yarn user-bot poolHoldings
```

### Enter Pool

The `enterPool` function allows users to deposit collateral into a specific collateral pool and become a participant by specifying the collateral pool ID and collateral amount.

```bash
yarn user-bot enterPool <poolId> <collateralAmount>
```

### Exit Pool

The `exitPool` function allows participants to withdraw their share of collateral from a collateral pool by burning their Collateral Pool Tokens (CPTs) and receiving collateral. Specify the pool ID and the amount of collateral to withdraw.

```bash
yarn user-bot exitPool <poolId> <amount|all>
```

## Balance Management

## Balance

Displays balance for relevant tokens like FAssets, underlying, native, wrapped native, and vault collateral.

```bash
yarn user-bot balance
```

## Secrets Management

### Generate Secrets

The function `generateSecrets' generates a secret JSON file for user addresses and private keys.

```bash
yarn user-bot generateSecrets --user
```

When executing the `generateSecrets` command, the following custom flag can be specified:

- **`-o <filename>`** (Optional)
  Saves the secrets to a specified file; otherwise, they are printed to the console.",2025-03-08 01:27:14
agent-bot.mdx,"title: Agent Bot CLI Reference
description: FAssets Agent Bot command line interface reference.
keywords: [fassets, xrp, bitcoin, dogecoin, flare-network]","Command line reference for managing and interacting with FAssets agent bots.

Sourced from `agent-bot.ts` on [GitHub](https://github.com/flare-labs-ltd/fasset-bots/blob/main/packages/fasset-bots-cli/src/cli/agent-bot.ts).

## Setup

Before running agent-bot, ensure it is properly set up using the [FAsset agent deploy](/fassets/guides/deploy-fassets-agent) with Docker and then learn [how to execute the command line commands](/fassets/guides/deploy-fassets-agent#execute-fasset-bot-commands).

## Usage

To run the agent-bot command line interface, use the `yarn agent-bot` command with the desired command and arguments and add the `--fasset` flag with the FAsset symbol.

```bash
yarn agent-bot [command] <args> --fasset [fAssetSymbol]
```

To list all available commands:

```bash
yarn agent-bot help
```

To execute a specific command using the [Docker container](/fassets/guides/deploy-fassets-agent#execute-fasset-bot-commands) change `yarn agent-bot` with `docker compose --profile cli run agent-bot`:

```bash
docker compose --profile cli run agent-bot [command] <args> --fasset [fAssetSymbol]
```

## Owner and Agent Management

### Validate Owner

Validate the setup of an agent owner for the FAsset by checking address whitelisting, proper registrations, and sufficient balances on management, work, and test asset addresses.
It confirms that all configurations and balances meet the requirements for the agent owner.

```bash
yarn agent-bot validateOwner
```

### Create

Create a new agent vault. Use `--prepare` to generate a settings template, or pass the settings as a file path argument.

```bash
yarn agent-bot create [agentSettingsPath]
```

### List Agents

List your active FAsset agents active agents from the persistent state.

```bash
yarn agent-bot listAgents
```

### Get Info

Output your FAsset agent information by specifying the agent vault address.
Use `--raw` to get direct output.

```bash
yarn agent-bot info <agentVaultAddress>
```

## Collateral Management

### Deposit Collaterals

Deposit enough vault and pool collateral for minting by specifying the FAsset agent vault address and amount of lots.

```bash
yarn agent-bot depositCollaterals <agentVaultAddress> <lots>
```

### Deposit Vault Collateral

Deposit vault collateral for minting by specifying the FAsset agent vault address and amount.

```bash
yarn agent-bot depositVaultCollateral <agentVaultAddress> <amount>
```

### Add Pool Collateral

Add pool collateral and get the FAsset agent's pool tokens by specifying the FAsset agent vault address and amount.

```bash
yarn agent-bot buyPoolCollateral <agentVaultAddress> <amount>
```

### Withdraw Vault Collateral

Start vault collateral withdrawal.
Automatically executed by the running bot later.
Specify the FAsset agent vault address and amount.

```bash
yarn agent-bot withdrawVaultCollateral <agentVaultAddress> <amount>
```

### Cancel Vault Collateral Withdrawal

Cancel vault collateral withdrawal.
Specify the FAsset agent vault address.

```bash
yarn agent-bot cancelVaultCollateralWithdrawal <agentVaultAddress>
```

### Redeem Collateral Pool Tokens

Start pool tokens redemption process.
Automatically executed by the running bot later. Specify the FAsset agent vault address and amount.

```bash
yarn agent-bot redeemCollateralPoolTokens <agentVaultAddress> <amount>
```

### Cancel Collateral Pool Token Redemption

Cancel collateral pool token redemption.
Specify the FAsset agent vault address.

```bash
yarn agent-bot cancelCollateralPoolTokenRedemption <agentVaultAddress>
```

### Withdraw Vault Collateral

Start vault collateral withdrawal.
Automatically executed by the running bot later.
Specify the FAsset agent vault address and amount.

```bash
yarn agent-bot withdrawVaultCollateral <agentVaultAddress> <amount>
```

### Pool Fees Balance

Get pool fees balance of the FAssets agent by specifying the agent vault address.

```bash
yarn agent-bot poolFeesBalance <agentVaultAddress>
```

### Top Up Underlying

Sends additional underlying assets to the FAssets agent, increasing the assets backing their minted FAssets.
Specify the FAsset agent vault address and amount.

```bash
yarn agent-bot topUpUnderlying <agentVaultAddress> <amount>
```

### Withdraw Underlying

Withdrawing underlying assets in the FAssets system allows agents to reclaim original assets stored on their underlying address, provided they no longer back any FAssets.
The process includes announcing the withdrawal, paying a fee, and obtaining a transaction hash while ensuring no risk to redeemers or collateral providers.
Agents must comply with system rules, such as avoiding illegal payments or liquidations, to perform the withdrawal successfully.
Specify the FAsset agent vault address, amount, and destination address.

```bash
yarn agent-bot withdrawUnderlying <agentVaultAddress> <amount> <destinationAddress>
```

### Cancel Underlying Withdrawal

Cancel underlying withdrawal announcement by specifying the FAsset agent vault address.

```bash
yarn agent-bot cancelUnderlyingWithdrawal <agentVaultAddress>
```

### Delegate Pool Collateral

Collateral providers or agents can delegate native pool collateral to the Flare Time Series Oracle (FTSO) by specifying the agent vault address, recipient, and share (ranging from 0 to 1, where 1 represents 100%).
This enables the locked collateral to earn rewards while maintaining system security and liquidity.
This feature enhances incentives by providing passive income without affecting the collateral's ability to back FAssets.

```bash
yarn agent-bot delegatePoolCollateral <agentVaultAddress> <recipient> <share>
```

### Undelegate Pool Collateral

Remove pool collateral delegation by specifying the FAsset agent vault address.

```bash
yarn agent-bot undelegatePoolCollateral <agentVaultAddress>
```

### Create Underlying Account

Create an underlying account for the FAssets agent.

```bash
yarn agent-bot createUnderlyingAccount
```

### Free Vault Collateral

Free vault collateral that is not currently locked to back FAssets by specifying the FAsset agent vault address.

```bash
yarn agent-bot freeVaultCollateral <agentVaultAddress>
```

### Free Pool Collateral

Free pool collateral by specifying the agent vault address.

```bash
yarn agent-bot freePoolCollateral <agentVaultAddress>
```

### Free Underlying Balance

Release the underlying balance assets on an agent's address that are not currently locked to back FAssets.
Specify the FAssets agent vault address.

```bash
yarn agent-bot freeUnderlyingBalance <agentVaultAddress>
```

### Switch Vault Collateral

Switch the vault collateral by specifying the agent vault address and the new token, using `--deposit` to auto-deposit equivalent tokens.

```bash
yarn agent-bot switchVaultCollateral <agentVaultAddress> <token>
```

### Self Mint FAsset

Mint FAssets using the agent vault without requiring the agent to be publicly available by specifying the agent vault address and amount.

```bash
yarn agent-bot selfMintFAsset <agentVaultAddress> <amount>
```

### Self Mint From Underlying

Mint FAssets directly using newly deposited underlying assets by specifying the agent vault address and amount, without requiring the agent to be publicly available.

```bash
yarn agent-bot selfMintFromUnderlying <agentVaultAddress> <numberOfLots>
```

## Status Management

### Enter Available

Enter the available FAssets agent list by specifying the FAsset agent vault address to register the agent vault and collateral pool, making them publicly accessible for minting by other users.

```bash
yarn agent-bot enter <agentVaultAddress>
```

### Exit Available

Exit the available agent list to automatically remove the agent vault and collateral pool from public availability, preventing users (minters) from selecting the agent to mint new FAssets.
Specify the agent vault address.

```bash
yarn agent-bot exit <agentVaultAddress>
```

### Execute Exit Available

Manually execute the exit from the available agent list that was previously announced, as this is typically unnecessary since the running bot can handle it automatically.

```bash
yarn agent-bot executeExit <agentVaultAddress>
```

### Self Close

Self-close means reducing the FAsset agent's obligations by burning FAssets and releasing the equivalent amount of underlying assets and/or collateral back to themselves by specifying the agent vault address and amount.

```bash
yarn agent-bot selfClose <agentVaultAddress> <amount>
```

### Close Agent Vault

Shut down the FAsset agent vault, ending all operations related to minting and backing FAssets by specifying the agent vault address.
The closing will be executed automatically later.

```bash
yarn agent-bot close <agentVaultAddress>
```

## Agent Settings Management

### Get Agent Settings

Retrieve the configuration parameters by specifying the agent vault address.

```bash
yarn agent-bot getAgentSettings <agentVaultAddress>
```

### Update Agent Setting

Modify specific operational parameters for the agent vault by specifying the agent vault address, name, and value.

```bash
yarn agent-bot updateAgentSetting <agentVaultAddress> <name> <value>
```

## Account Management

### Upgrade WNat

Upgrade the Wrapped Native Token (WNat) contract used in the FAsset agent collateral pool by specifying the agent vault address.

```bash
yarn agent-bot upgradeWnat <agentVaultAddress>
```

### Export Private Keys

Export the private keys for the FAssets agent underlying address by specifying the export file.

```bash
yarn agent-bot exportPrivateKeys <exportFile>
```",2025-03-08 01:27:14
3-solidity-reference.mdx,"title: Network Reference
description: Solidity reference for Flare contracts.
keywords: [solidity, reference, ftso, flare-network, smart-contracts]","import Tabs from ""@theme/Tabs"";
import TabItem from ""@theme/TabItem"";
import DocCardList from ""@theme/DocCardList"";
import SolidityReference from ""@site/src/components/DataTables/SolidityReference"";

## Deployed Contracts

export const contracts = [
  ""FlareContractRegistry"",
  ""ProtocolsV2"",
  ""RandomNumberV2"",
  ""RewardsV2"",
  ""ClaimSetupManager"",
  ""DistributionToDelegators"",
  ""WNat"",
  ""RNat"",
];

<Tabs block>
    <TabItem value=""flare"" label=""Flare Mainnet"" default>

        <SolidityReference
            network=""FlareMainnet""
            contractNames={contracts}
        />

    </TabItem>
    <TabItem value=""coston2"" label=""Flare Testnet Coston2"">

        <SolidityReference
            network=""FlareTestnetCoston2""
            contractNames={contracts}
        />

    </TabItem>
    <TabItem value=""songbird"" label=""Songbird Canary-Network"">

        <SolidityReference
            network=""SongbirdCanaryNetwork""
            contractNames={contracts}
        />

    </TabItem>
    <TabItem value=""coston"" label=""Songbird Testnet Coston"">


        <SolidityReference
            network=""SongbirdTestnetCoston""
            contractNames={contracts}
        />

    </TabItem>

</Tabs>

:::tip

`FlareContractRegistry` has the same address across all four networks.
You can query the [`getAllContracts`](/network/solidity-reference/IFlareContractRegistry#getallcontracts) method to fetch all protocol contract addresses on that network.

:::

## Interfaces

<DocCardList />",2025-03-08 01:27:14
1-getting-started.mdx,"slug: getting-started
title: Getting Started
description: Deploy a smart contract on Flare using your browser.
keywords: [solidity, smart-contract, metamask, remix, flare-network, blockchain]","import Remix from ""@site/src/components/remix"";
import YoutubeEmbed from ""@site/src/components/youtube"";
import CodeBlock from ""@theme/CodeBlock"";
import HelloWorld from ""!!raw-loader!/examples/developer-hub-solidity/HelloWorld.sol"";
import OpenMetamask from ""/static/img/deploy-first-contract/0-open-metamask.png"";
import AddCoston2 from ""/static/img/deploy-first-contract/1-add-coston2.png"";
import ApproveCoston2 from ""/static/img/deploy-first-contract/2-approve-coston2.png"";
import SwitchNetwork from ""/static/img/deploy-first-contract/3-switch-networks.png"";
import CopyAddress from ""/static/img/deploy-first-contract/4-copy-address.png"";
import PasteAddress from ""/static/img/deploy-first-contract/5-paste-address.png"";
import AfterFaucetConfirmation from ""/static/img/deploy-first-contract/6-after-faucet-confirmation.png"";
import OpenSolidityCompiler from ""/static/img/deploy-first-contract/7-open-solidity-compiler.png"";
import SetEvmVersion from ""/static/img/deploy-first-contract/8-set-evm-version.png"";
import CompileContract from ""/static/img/deploy-first-contract/9-compile-contract.png"";
import DeployAndRunTxs from ""/static/img/deploy-first-contract/10-deploy-and-run-transactions.png"";
import SetInjectedProvider from ""/static/img/deploy-first-contract/11-set-injected-provider.png"";
import ConnectToMetamask from ""/static/img/deploy-first-contract/12-connect-to-metamask.png"";
import ConfirmPermissions from ""/static/img/deploy-first-contract/13-confirm-permissions.png"";
import MessageWhenDeploying from ""/static/img/deploy-first-contract/14-message-when-deploying.png"";
import ConfirmDeployInMetamask from ""/static/img/deploy-first-contract/15-confirm-deploy-in-metamask.png"";
import ClickOnMessage from ""/static/img/deploy-first-contract/16-click-on-message.png"";
import UpdateMessage from ""/static/img/deploy-first-contract/17-update-message.png"";
import ConfirmMetamaskUpdateMessage from ""/static/img/deploy-first-contract/18-confirm-metamask-update-message.png"";
import QueryUpdatedMessage from ""/static/img/deploy-first-contract/19-query-updated-message.png"";

You can deploy your first smart contract and run it in your browser without prior knowledge of Flare. This guide demonstrates how easy it is to develop smart contracts using the [Solidity language](https://soliditylang.org/), a [MetaMask wallet](https://metamask.io/) and the [Remix Development Environment](https://remix.ethereum.org/). All these tools are accessible in your browser for free, without requiring any sign-up.

## Goals

You will create and deploy a simple ""Hello World"" smart contract following these steps:

1. **Write:** Draft a smart contract outlining its logic, updating a simple string state variable.

2. **Compile:** Convert your human-readable smart contract code into bytecode, comprehensible to the Flare blockchain.

3. **Deploy:** Send the compiled smart contract to the blockchain, where its code becomes immutable.

4. **Call functions:** Execute the functions defined in your contract, triggering changes in the state of the blockchain.

## Steps

<details>
<summary>**1. Install, configure and fund your MetaMask wallet**</summary>

1. [Install the MetaMask browser extension wallet](https://metamask.io/download/)

2. After installing, open MetaMask from your browser extensions.

   <img src={OpenMetamask} style={{ width: 300 }} />

3. Follow the instructions to create a new wallet. During setup, you'll receive a 12-word mnemonic phrase. Safeguard this phrase in a secure location, as it's crucial for accessing your wallet in the future.

4. Add the Flare Testnet Coston2 to your MetaMask wallet. Go to the [Coston2 Explorer](https://coston2.testnet.flarescan.com/), scroll to the footer of the page and click on **Add Flare Testnet Coston2**.

   <img src={AddCoston2} style={{ width: 300 }} />

5. A MetaMask prompt will open asking you to approve adding the network. Click on **Approve**.

   <img src={ApproveCoston2} style={{ width: 300 }} />

6. Once approved, MetaMask will ask you to switch to Flare Testnet Coston2. Click on **Switch network**.

   <img src={SwitchNetwork} style={{ width: 300 }} />

7. Copy your MetaMask address.

   <img src={CopyAddress} style={{ width: 300 }} />

8. Paste your address in the [Coston2 Faucet](https://faucet.flare.network/coston2) and click on **Request C2FLR**.

   <img src={PasteAddress} style={{ width: 400 }} />

9. After the faucet completes the transaction, which can take a few seconds, you should find testnet C2FLR in your MetaMask wallet.

   <img src={AfterFaucetConfirmation} style={{ width: 300 }} />

With your wallet configured and funded, you're ready to write, compile, and deploy your contract.

</details>

<details>
<summary>**2. Write, compile and deploy your first smart contract**</summary>

Start with a simple HelloWorld.sol example. This contract illustrates setting and retrieving variables within a smart contract onchain.

<CodeBlock language=""solidity"" title=""HelloWorld.sol"">
  {HelloWorld}
</CodeBlock>

<details>
<summary>Didn't understand the Solidity code?</summary>

Let's break down the `HelloWorld` contract:

1.  **Pragma Directive:** The `pragma solidity >=0.8.0 <0.9.0;` statement specifies the version of the Solidity compiler the contract should use. In this case, the contract is compatible with any version of Solidity above (including) 0.8.0 and below 0.9.0.

2.  **Contract Declaration:** The `contract HelloWorld { ... }` statement defines a new Solidity contract named `HelloWorld`.

3.  **State Variable:** `string public message`; declares a state variable named `message`, which is of type `string` and is publicly accessible (due to the `public` visibility modifier). This variable will store a message that can be read by any external entity.

4.  **Constructor:** The `constructor(string memory initialMessage) { ... }` function is a special function that is executed only once when the contract is deployed. It initializes the `message` state variable with the value passed as `initialMessage` when the contract is deployed.

5.  **Function `updateMessage`:** This function allows anyone to update the `message` state variable. It takes a `newMessage` parameter of type `string`, updates the `message` variable with the new value, and is publicly accessible (`public` visibility modifier).

</details>

{/* prettier-ignore */}
1. <Remix fileName=""HelloWorld.sol"">Open contract in Remix</Remix>

2. Click on `HelloWorld.sol` in the file explorer to open the contract in the Remix editor.

3. Navigate to the **Solidity compiler** tab on the left to view the compiler settings.

   <img src={OpenSolidityCompiler} style={{ width: 300 }} />

4. Expand the **Advanced Configurations** section and make sure the **EVM Version** is set to `london`.

   <img src={SetEvmVersion} style={{ width: 300 }} />

4. Click the **Compile HelloWorld.sol** button to compile the contract. This converts the contract from human-readable Solidity code into bytecode that the Flare blockchain can understand.

   <img src={CompileContract} style={{ width: 300 }} />

5. After Remix compiles the contract, deploy it. On the left side of Remix, click the **Deploy & Run Transactions** tab to view the deployment settings.

   <img src={DeployAndRunTxs} style={{ width: 300 }} />

6. In the deployment settings, select the **Injected Provider - MetaMask** environment. This tells Remix that you want to deploy your contract to the blockchain that you configured in MetaMask.

   <img src={SetInjectedProvider} style={{ width: 300 }} />

7. Next to the **Deploy** button, enter a message that you want to send with the smart contract when you deploy it. This contract has a constructor that sets an initial message when you deploy the contract.

   <img src={MessageWhenDeploying} style={{ width: 300 }} />

8. Click the **Deploy** button to deploy the contract and its initial message to the blockchain. MetaMask opens and asks you to confirm payment to deploy the contract. Make sure MetaMask is set to the Flare Testnet Coston2 network before you accept the transaction. Click on **Confirm**.

   <img src={ConfirmDeployInMetamask} style={{ width: 300 }} />

9. After a few seconds, the transaction completes and your contract appears under the **Deployed/Unpinned Contracts** list in Remix. Click the contract dropdown to view its variables and functions. Click the **message** button. Remix retrieves and prints the initial message that you set.

   <img src={ClickOnMessage} style={{ width: 300 }} />

The contract has an address just like your wallet address. To see details about your deployed contract, copy the contract address from the list in Remix and search for it in the [Coston2 Explorer](https://coston2.testnet.flarescan.com/).

</details>

<details>
<summary>**3. Call functions in your contract**</summary>

Since you deployed the contract to a blockchain, multiple nodes on the test network have confirmed your payment for the smart contract. The contract, along with its variables and functions, is now permanently stored on the blockchain. To change the `message` variable within your contract, simply run the `updateMessage` function.

1. In your deployed contract, enter a new message next to the updateMessage function. Click the **updateMessage** button to set the new message in the contract data.

   <img src={UpdateMessage} style={{ width: 300 }} />

2. A MetaMask prompt will open and ask you to confirm payment to update the state of your contract. Click **Confirm** to approve the transaction.

   <img src={ConfirmMetamaskUpdateMessage} style={{ width: 300 }} />

3. Click the **message** button again to see the updated value.

   <img src={QueryUpdatedMessage} style={{ width: 300 }} />

</details>

Now you know how to deploy and call example contracts on Flare's testnet. You can write your own contracts and test them using this same process.

## Watch the video

<YoutubeEmbed embedLink=""1t-JrzkcVsc?si=tzSVnrpte_p_4eN1""></YoutubeEmbed>

:::tip[What's next?]

Read FTSOv2's [Getting Started](/ftso/getting-started) guide to learn how to connect your smart contracts to Flare's enshrined oracle and retrieve onchain data feeds.

:::",2025-03-08 01:27:14
0-overview.mdx,"slug: overview
title: Network
description: Learn about the different Flare networks, configuration, supported wallets, transaction format, smart contracts, consensus, and more.
keywords:
  [flare-network, configuration, blockchain, data, smart-contracts, wallets]","import Tabs from ""@theme/Tabs"";
import TabItem from ""@theme/TabItem"";
import IconExternalLink from ""@theme/Icon/ExternalLink"";
import IconCopy from ""@theme/Icon/Copy"";
import CodeBlock from ""@theme/CodeBlock"";
import BlockNumCostonJS from ""!!raw-loader!/examples/developer-hub-javascript/block_number_coston.js"";
import BlockNumFlareJS from ""!!raw-loader!/examples/developer-hub-javascript/block_number_flare.js"";
import BlockNumCoston2JS from ""!!raw-loader!/examples/developer-hub-javascript/block_number_coston2.js"";
import BlockNumSongbirdJS from ""!!raw-loader!/examples/developer-hub-javascript/block_number_songbird.js"";
import BlockNumCostonPy from ""!!raw-loader!/examples/developer-hub-python/block_number_coston.py"";
import BlockNumFlarePy from ""!!raw-loader!/examples/developer-hub-python/block_number_flare.py"";
import BlockNumCoston2Py from ""!!raw-loader!/examples/developer-hub-python/block_number_coston2.py"";
import BlockNumSongbirdPy from ""!!raw-loader!/examples/developer-hub-python/block_number_songbird.py"";
import BlockNumCostonRs from ""!!raw-loader!/examples/developer-hub-rust/src/bin/block_number_coston.rs"";
import BlockNumFlareRs from ""!!raw-loader!/examples/developer-hub-rust/src/bin/block_number_flare.rs"";
import BlockNumCoston2Rs from ""!!raw-loader!/examples/developer-hub-rust/src/bin/block_number_coston2.rs"";
import BlockNumSongbirdRs from ""!!raw-loader!/examples/developer-hub-rust/src/bin/block_number_songbird.rs"";
import BlockNumCostonGo from ""!!raw-loader!/examples/developer-hub-go/coston/block_number.go"";
import BlockNumFlareGo from ""!!raw-loader!/examples/developer-hub-go/flare/block_number.go"";
import BlockNumCoston2Go from ""!!raw-loader!/examples/developer-hub-go/coston2/block_number.go"";
import BlockNumSongbirdGo from ""!!raw-loader!/examples/developer-hub-go/songbird/block_number.go"";

Flare has four networks, each serving different purposes, so choosing the right one is crucial. All of these networks operate on a permissionless basis and are EVM compatible:

- **Flare Mainnet.** The production network where all the action happens. Transactions cost real money here.

- **Flare Testnet Coston2.** Test your applications without spending real money. This should be your first choice when developing applications.

- **Songbird Canary-Network.** Experimental proving ground for Flare.

- **Songbird Testnet Coston.** The testnet for Songbird Canary-Network.

The most common development tracks are:

- **Flare Testnet Coston2 ‚Üí Flare Mainnet**: Recommended track for application developers.

- **Songbird Testnet Coston ‚Üí Songbird Canary-Network ‚Üí Flare Testnet Coston2 ‚Üí Flare Mainnet**: Required track for all protocol level changes.

## Configuration

Configuration for all Flare networks, along with public and private RPCs, blockchain explorers, and faucets.

<Tabs block groupId=""network"">
  <TabItem value=""flare"" label=""Flare Mainnet"" default>

    | Network name         | Flare Mainnet                                                                                                                                        |
    | :------------------- | :--------------------------------------------------------------------------------------------------------------------------------------------------- |
    | RPCs (HTTPS)         | `https://flare-api.flare.network/ext/C/rpc` <br/> `https://stylish-light-theorem.flare-mainnet.quiknode.pro/ext/bc/C/rpc`                            |
    | RPCs (WSS)           | `wss://flare-api.flare.network/ext/C/ws` <br/> `wss://stylish-light-theorem.flare-mainnet.quiknode.pro/ext/bc/C/ws`                               |
    | Chain ID             | 14                                                                                                                                                   |
    | Currency symbol      | FLR                                                                                                                                                  |
    | Currency decimals    | 18                                                                                                                                                   |
    | Blockchain Explorers | [`https://flarescan.com`](https://flarescan.com) <br/> [`https://flare-explorer.flare.network`](https://flare-explorer.flare.network)            |
    | Private RPCs         | [API Portal](https://api-portal.flare.network/apis/flare-api)                                                                                        |
    | Faucets              | -                                                                                                                                                    |
    | Bootstrapping nodes  | `https://flare-bootstrap.flare.network` <br/> `https://flare-bootstrap-1.staking.production.figment.io` <br/> `https://flare.senseinode.com` |
    | \{Safe\}Wallet       | [`https://multisig.flare.network`](https://multisig.flare.network)                                                                                   |

    :::tip[RPC Connection code snippet]
    <Tabs block>
      <TabItem value=""curl"" label=""curl"" default>

        ```bash
        curl https://flare-api.flare.network/ext/C/rpc -X POST -H ""Content-Type: application/json"" --data '{""jsonrpc"":""2.0"",""method"":""eth_blockNumber"",""params"":[],""id"":1}'
        ```

      </TabItem>
      <TabItem value=""web3js"" label=""web3.js"">

        <CodeBlock language=""javascript"">
          {BlockNumFlareJS}
        </CodeBlock>

      </TabItem>
      <TabItem value=""web3py"" label=""web3.py"">

        <CodeBlock language=""python"">
          {BlockNumFlarePy}
        </CodeBlock>

      </TabItem>
      <TabItem value=""goethereum"" label=""go-ethereum"">

        <CodeBlock language=""go"">
          {BlockNumFlareGo}
        </CodeBlock>

      </TabItem>
      <TabItem value=""alloyrs"" label=""alloy-rs"">

        <CodeBlock language=""rust"">
          {BlockNumFlareRs}
        </CodeBlock>

      </TabItem>
    </Tabs>
    :::

  </TabItem>
  <TabItem value=""coston2"" label=""Flare Testnet Coston2"">

    | Network name          | Flare Testnet Coston2                                                                                                                                                         |
    | :-------------------- | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
    | RPCs (HTTPS)          | `https://coston2-api.flare.network/ext/C/rpc` <br/> `https://falling-skilled-uranium.flare-coston2.quiknode.pro/ext/bc/C/rpc`                                                                                                                              |
    | RPCs (WSS)            | `wss://coston2-api.flare.network/ext/C/ws` <br/> `wss://falling-skilled-uranium.flare-coston2.quiknode.pro/ext/bc/C/ws`                                                                                                                              |
    | Chain ID              | 114                                                                                                                                                                           |
    | Currency symbol       | C2FLR                                                                                                                                                                         |
    | Currency decimals     | 18                                                                                                                                                                            |
    | Blockchain Explorers  | [`https://coston2.testnet.flarescan.com`](https://coston2.testnet.flarescan.com) <br/> [`https://coston2-explorer.flare.network`](https://coston2-explorer.flare.network) |
    | Private RPCs          | [API Portal](https://api-portal.flare.network/apis/coston2-api)                                                                                                               |
    | Faucets               | [Coston2 Faucet](https://faucet.flare.network/coston2)                                                                                                                        |
    | Bootstrapping nodes   | `https://coston2-bootstrap.flare.network`                                                                                                                                     |

    :::tip[RPC Connection code snippet]
    <Tabs block>
      <TabItem value=""curl"" label=""curl"" default>

        ```bash
        curl https://coston2-api.flare.network/ext/C/rpc -X POST -H ""Content-Type: application/json"" --data '{""jsonrpc"":""2.0"",""method"":""eth_blockNumber"",""params"":[],""id"":1}'
        ```

      </TabItem>
      <TabItem value=""web3js"" label=""web3.js"">

        <CodeBlock language=""javascript"">
          {BlockNumCoston2JS}
        </CodeBlock>

      </TabItem>
      <TabItem value=""web3py"" label=""web3.py"">

        <CodeBlock language=""python"">
          {BlockNumCoston2Py}
        </CodeBlock>

      </TabItem>
      <TabItem value=""goethereum"" label=""go-ethereum"">

        <CodeBlock language=""go"">
          {BlockNumCoston2Go}
        </CodeBlock>

      </TabItem>
      <TabItem value=""alloyrs"" label=""alloy-rs"">

        <CodeBlock language=""rust"">
          {BlockNumCoston2Rs}
        </CodeBlock>

      </TabItem>
    </Tabs>
    :::

  </TabItem>
    <TabItem value=""songbird"" label=""Songbird Canary-Network"">

    | Network name         | Songbird Canary-Network                                                                                                                                           |
    | :------------------- | :---------------------------------------------------------------------------------------------------------------------------------------------------------------- |
    | RPC (HTTPS)          | `https://songbird-api.flare.network/ext/C/rpc`                                                                                                                    |
    | RPC (WSS)            | `wss://songbird-api.flare.network/ext/C/ws`                                                                                                                    |
    | Chain ID             | 19                                                                                                                                                                |
    | Currency symbol      | SGB                                                                                                                                                               |
    | Currency decimals    | 18                                                                                                                                                                |
    | Blockchain Explorers | [`https://songbird.flarescan.com`](https://songbird.flarescan.com) <br/> [`https://songbird-explorer.flare.network`](https://songbird-explorer.flare.network) |
    | Private RPCs         | [API Portal](https://api-portal.flare.network/apis/songbird-api)                                                                                                  |
    | Faucets              | -                                                                                                                                                                 |
    | Bootstrapping nodes  | `https://songbird-bootstrap.flare.network`                                                                                                                        |

    :::tip[RPC Connection code snippet]
    <Tabs block>
      <TabItem value=""curl"" label=""curl"" default>

        ```bash
        curl https://songbird-api.flare.network/ext/C/rpc -X POST -H ""Content-Type: application/json"" --data '{""jsonrpc"":""2.0"",""method"":""eth_blockNumber"",""params"":[],""id"":1}'
        ```

      </TabItem>
      <TabItem value=""web3js"" label=""web3.js"">

        <CodeBlock language=""javascript"">
          {BlockNumSongbirdJS}
        </CodeBlock>

      </TabItem>
      <TabItem value=""web3py"" label=""web3.py"">

        <CodeBlock language=""python"">
          {BlockNumSongbirdPy}
        </CodeBlock>

      </TabItem>
      <TabItem value=""goethereum"" label=""go-ethereum"">

        <CodeBlock language=""go"">
          {BlockNumSongbirdGo}
        </CodeBlock>

      </TabItem>
      <TabItem value=""alloyrs"" label=""alloy-rs"">

        <CodeBlock language=""rust"">
          {BlockNumSongbirdRs}
        </CodeBlock>

      </TabItem>
    </Tabs>
    :::

  </TabItem>
  <TabItem value=""coston"" label=""Songbird Testnet Coston"">
  
    | Network name         | Songbird Testnet Coston                                                                                                                                                   |
    | :------------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
    | RPC (HTTPS)          | `https://coston-api.flare.network/ext/C/rpc`                                                                                                                              |
    | RPC (WSS)            | `wss://coston-api.flare.network/ext/C/ws`                                                                                                                              |
    | Chain ID             | 16                                                                                                                                                                        |
    | Currency symbol      | CFLR                                                                                                                                                                      |
    | Currency decimals    | 18                                                                                                                                                                        |
    | Blockchain Explorers | [`https://coston.testnet.flarescan.com`](https://coston.testnet.flarescan.com) <br/> [`https://coston-explorer.flare.network`](https://coston-explorer.flare.network) |
    | Private RPCs         | [API Portal](https://api-portal.flare.network/apis/coston-api)                                                                                                            |
    | Faucets              | [Coston Faucet](https://faucet.flare.network/coston)                                                                                                                      |
    | Bootstrapping nodes  | `https://coston-bootstrap.flare.network`                                                                                                                                  |

    :::tip[RPC Connection code snippet]
    <Tabs block>
      <TabItem value=""curl"" label=""curl"" default>

        ```bash
        curl https://coston-api.flare.network/ext/C/rpc -X POST -H ""Content-Type: application/json"" --data '{""jsonrpc"":""2.0"",""method"":""eth_blockNumber"",""params"":[],""id"":1}'
        ```

      </TabItem>
      <TabItem value=""web3js"" label=""web3.js"">

        <CodeBlock language=""javascript"">
          {BlockNumCostonJS}
        </CodeBlock>

      </TabItem>
      <TabItem value=""web3py"" label=""web3.py"">

        <CodeBlock language=""python"">
          {BlockNumCostonPy}
        </CodeBlock>

      </TabItem>
      <TabItem value=""goethereum"" label=""go-ethereum"">

        <CodeBlock language=""go"">
          {BlockNumCostonGo}
        </CodeBlock>

      </TabItem>
      <TabItem value=""alloyrs"" label=""alloy-rs"">

        <CodeBlock language=""rust"">
          {BlockNumCostonRs}
        </CodeBlock>

      </TabItem>
    </Tabs>
    :::

  </TabItem>

</Tabs>

## Community tools

Developer tools for Flare built by the community including RPCs, bridges, indexers, account abstraction, wallet SDKs, and more.

<Tabs block groupId=""network"">
  <TabItem value=""flare"" label=""Flare Mainnet"" default>

    | RPCs                 | [QuickNode](https://www.quicknode.com/chains/flare), [Ankr](https://www.ankr.com/rpc/flare/), [Thirdweb](https://14.rpc.thirdweb.com), [ChainList<IconExternalLink/>](https://ChainList.org/chain/14)                                                                                                                                                                                                                                                                                                   |
    | :------------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
    | Bridging             | [LayerZero V2](https://docs.layerzero.network/v2/developers/evm/technical-reference/deployed-contracts#flare), [Stargate V2](https://stargateprotocol.gitbook.io/stargate/v/v2-developer-docs/technical-reference/mainnet-contracts#flare) ([OFTs](https://stargateprotocol.gitbook.io/stargate/v/v2-developer-docs/technical-reference/v2-supported-networks-and-assets#flare)), [zkBridge](https://docs.zkbridge.com/layerzero-zklightclient-configurations/layerzero-v2-zklightclient-dvn-addresses) |
    | Indexers             | [Goldsky](https://docs.goldsky.com/chains/supported-networks), [SubQuery](https://github.com/subquery/flare-subql-starter/tree/main/Flare/flare-starter), [sqd](https://docs.sqd.dev/subsquid-network/reference/networks/#evm--ethereum-compatible)                                                                                                                                                                                                                                                     |
    | OAuth Login          | [Web3Auth](https://web3auth.io/docs/connect-blockchain/evm/flare)                                                                                                                                                                                                                                                                                                                                                                                                                                       |
    | Account Abstraction  | [Etherspot Prime SDK](https://etherspot.fyi/prime-sdk/intro)                                                                                                                                                                                                                                                                                                                                                                                                                                            |
    | Wallet SDK           | [Wagmi](https://wagmi.sh/react/chains), [RainbowKit](https://www.rainbowkit.com/docs/introduction)                                                                                                                                                                                                                                                                                                                                                                                                      |
    | Full-stack Dev Infra | [Tenderly](https://tenderly.co)                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |

  </TabItem>

  <TabItem value=""coston2"" label=""Flare Testnet Coston2"">

    |                 RPCs | [QuickNode](https://www.quicknode.com/chains/flare), [Ankr](https://www.ankr.com/rpc/flare/), [Thirdweb](https://114.rpc.thirdweb.com), [ChainList<IconExternalLink/>](https://ChainList.org/chain/114) |
    | :------------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
    |             Bridging | [LayerZero V2](https://docs.layerzero.network/v2/developers/evm/technical-reference/deployed-contracts#flare-testnet)                                                                                   |
    |             Indexers | [Goldsky](https://docs.goldsky.com/chains/supported-networks)                                                                                                                                           |
    |          OAuth Login | [Web3Auth](https://web3auth.io/docs/connect-blockchain/evm/flare)                                                                                                                                       |
    |  Account Abstraction | [Etherspot Prime SDK](https://etherspot.fyi/prime-sdk/intro)                                                                                                                                            |
    |           Wallet SDK | [Wagmi](https://wagmi.sh/react/chains), [RainbowKit](https://www.rainbowkit.com/docs/introduction)                                                                                                      |
    | Full-stack Dev Infra | [Tenderly](https://tenderly.co)                                                                                                                                                                         |

  </TabItem>
    <TabItem value=""songbird"" label=""Songbird Canary-Network"">

    | RPCs                 | [Ankr](https://www.ankr.com/rpc/flare/), [Thirdweb](https://19.rpc.thirdweb.com), [ChainList<IconExternalLink/>](https://ChainList.org/chain/19) |
    | :------------------- | :----------------------------------------------------------------------------------------------------------------------------------------------- |
    | Bridging             | -                                                                                                                                                |
    | Indexers             | [SubQuery](https://github.com/subquery/flare-subql-starter/tree/main/Flare/songbird-starter)                                                     |
    | OAuth Login          | [Web3Auth](https://web3auth.io/docs/connect-blockchain/evm/songbird/)                                                                            |
    | Account Abstraction  | -                                                                                                                                                |
    | Wallet SDK           | [Wagmi](https://wagmi.sh/react/chains), [RainbowKit](https://www.rainbowkit.com/docs/introduction)                                               |
    | Full-stack Dev Infra | [Tenderly](https://tenderly.co)                                                                                                                  |

  </TabItem>
  <TabItem value=""coston"" label=""Songbird Testnet Coston"">

    | RPCs                 | [Ankr](https://www.ankr.com/rpc/flare/), [Thirdweb](https://16.rpc.thirdweb.com), [ChainList<IconExternalLink/>](https://ChainList.org/chain/16) |
    | :------------------- | :----------------------------------------------------------------------------------------------------------------------------------------------- |
    | Bridging             | -                                                                                                                                                |
    | Indexers             | -                                                                                                                                                |
    | OAuth Login          | [Web3Auth](https://web3auth.io/docs/connect-blockchain/evm/songbird/)                                                                            |
    | Account Abstraction  | -                                                                                                                                                |
    | Wallet SDK           | [Wagmi](https://wagmi.sh/react/chains), [RainbowKit](https://www.rainbowkit.com/docs/introduction)                                               |
    | Full-stack Dev Infra | [Tenderly](https://tenderly.co)                                                                                                                  |

  </TabItem>

</Tabs>

## Supported wallets

Several desktop, browser and mobile app based wallets support Flare. Discover suitable options for your needs on the [Flare Wallets](https://flare.network/wallets/) page.

## Transaction format

- **Address space:** Matches Ethereum, 20-byte addresses using ECDSA.

- **Transaction format:** Matches Ethereum, complies with [EIP-2718](https://eips.ethereum.org/EIPS/eip-2718), encoded with [RLP](https://ethereum.org/en/developers/docs/data-structures-and-encoding/rlp/).

- **Transaction fees:**

  - **Type0** (Legacy) - Fee is calculated as `gasUsed * gasPrice`.

  - **Type2** (EIP-1559) - Fee is calculated as `(baseFee + priorityFee) * gas`. Both the base and priority fees are burned.

## Smart contracts

- **RPC-API:** [Ethereum RPC API](https://ethereum.org/en/developers/docs/apis/json-rpc/)

- **Supported opcodes:** All [opcodes](https://www.evm.codes/?fork=london) up to the London hard fork are supported.

## Block verification

- **Header:** [Verifying block header in Go](https://github.com/flare-foundation/go-flare/blob/main/coreth/consensus/dummy/consensus.go#L187).

- **Body:** [Validating block body in Go](https://github.com/flare-foundation/go-flare/blob/main/coreth/core/block_validator.go#L62).

- **Verify transaction in block:** Merkle Patricia Trie verification against the receipt root.

## Consensus

- **Sybil resistance mechanism:** Proof-of-Stake (PoS)

- **Delegation:** In-protocol

- **Block time:** ‚âà1.8 seconds

- **Finality:** Single-slot. Once a block is validated through the gossip protocol, it is finalized.

- **Transaction ordering:** Leaders' discretion, default behaviour is priority gas auction.

- **Consensus mechanism:** Snowman++ (from [Avalanche](https://docs.avax.network)) offers a high-throughput, totally ordered consensus mechanism alongside a leader protocol to minimize MEV.

- **Consensus participants:** Validators vote on block proposals and serve as leaders. To serve as a validator, a node must meet a governance defined [minimum self-bond](https://proposals.flare.network/FIP/FIP_5.html). Validators are randomly selected as leaders to propose new blocks. The probability of being elected leader is proportional to the validator's stake.

- **Enshrined protocols:** In addition to consensus, Flare validators are also data providers for [FTSO](/ftso/overview) and attestation providers for [FDC](/fdc/overview).

- **Stake distribution:** Network comprises [over 90 validators](https://flarescan.com/validators) with a median stake of ‚âà0.7% and a maximum stake of ‚âà3.3%. This includes both self-bonded and delegated stakes.

:::note[Adding Flare's native token FLR to your exchange]

Flare is just like Ethereum. To add it to your exchange:

- Set up an [RPC node](/run-node/rpc-node)
- Use the appropriate [network configuration](#configuration) for Flare Mainnet

Additional info: [Media & Branding](https://flare.network/media/), [Flare source code](https://github.com/flare-foundation/go-flare)

:::",2025-03-08 01:27:14
4-fsp.mdx,"slug: fsp
title: Flare Systems Protocol
description: Foundational architecture supporting Flare's enshrined protocols.
keywords: [flare-network, configuration, blockchain, data, smart-contracts]","import Tabs from ""@theme/Tabs"";
import TabItem from ""@theme/TabItem"";
import DocCardList from ""@theme/DocCardList"";
import SolidityReference from ""@site/src/components/DataTables/SolidityReference"";
import ThemedImage from ""@theme/ThemedImage"";
import useBaseUrl from ""@docusaurus/useBaseUrl"";

The **F**lare **S**ystems **P**rotocol (**FSP**) is a foundational infrastructure designed to support Flare's enshrined protocols (technically referred to as sub-protocols).
Its primary goal is to facilitate secure, efficient, and decentralized consensus mechanisms through weighted voting by a select group of entities known as voters.
These voters are off-chain participants who accrue vote power from the Flare community via delegations of wrapped FLR tokens (WFLR) or stakes.

FSP ensures that agreements on off-chain data or calculations are reached securely and fairly, enabling the reliable operation of sub-protocols
like the [Flare Time Series Oracle](/ftso/overview) and the [Flare Data Connector](/fdc/overview).

**Key FSP Features:**

- **Decentralized Governance**: Through a weighted voting system involving a diverse set of voters.
- **Efficient Data Management**: By offloading complex calculations off-chain and minimizing on-chain storage requirements.
- **Robust Reward Mechanisms**: Incentivizing participation and penalizing delays or non-compliance to maintain network health.
- **Extensibility**: Designed to support additional sub-protocols and future enhancements like C-chain staking.
- **Security**: Implements mechanisms to prevent malicious behavior and ensures data integrity through Merkle proofs.

<ThemedImage
  alt=""FSP Architecture""
  sources={{
    light: useBaseUrl(""img/fsp/fsp_light.svg""),
    dark: useBaseUrl(""img/fsp/fsp_dark.svg""),
  }}
/>

<DocCardList />",2025-03-08 01:27:14
ProtocolsV2Interface.md,"title: ProtocolsV2Interface
description: Primary interface for managing protocol related metadata.
sidebar_position: 2","Primary interface for managing protocol related metadata. This is a long-term support (LTS) interface, designed to ensure continuity even as underlying contracts evolve or protocols migrate to new versions.

Sourced from `ProtocolsV2Interface.sol` on [GitHub](https://github.com/flare-foundation/flare-smart-contracts-v2/blob/main/contracts/userInterfaces/LTS/ProtocolsV2Interface.sol).

## Functions

### firstRewardEpochStartTs

Timestamp when the first reward epoch started, in seconds since UNIX epoch.

```solidity
function firstRewardEpochStartTs(
) external view returns (
    uint64
);
```

### firstVotingRoundStartTs

Timestamp when the first voting epoch started, in seconds since UNIX epoch.

```solidity
function firstVotingRoundStartTs(
) external view returns (
    uint64
);
```

### getCurrentRewardEpochId

Returns the current reward epoch id.

```solidity
function getCurrentRewardEpochId(
) external view returns (
    uint24
);
```

### getCurrentVotingEpochId

Returns the current voting epoch id.

```solidity
function getCurrentVotingEpochId(
) external view returns (
    uint32
);
```

### getStartVotingRoundId

Returns the start voting round id for given reward epoch id.

```solidity
function getStartVotingRoundId(
    uint256 _rewardEpochId
) external view returns (
    uint32
);
```

### getVotePowerBlock

Returns the vote power block for given reward epoch id.

```solidity
function getVotePowerBlock(
    uint256 _rewardEpochId
) external view returns (
    uint64 _votePowerBlock
);
```

### rewardEpochDurationSeconds

Duration of reward epoch, in seconds.

```solidity
function rewardEpochDurationSeconds(
) external view returns (
    uint64
);
```

### votingEpochDurationSeconds

Duration of voting epoch, in seconds.

```solidity
function votingEpochDurationSeconds(
) external view returns (
    uint64
);
```",2025-03-08 01:27:14
IRNat.md,"title: IRNat
description: Interface for managing rFLR.
sidebar_position: 10","Interface for managing rFLR.

Sourced from `IRNat.sol` on [GitHub](https://github.com/flare-foundation/flare-smart-contracts-v2/blob/main/contracts/userInterfaces/IRNat.sol).

## Functions

### allowance

Returns the remaining number of tokens that `spender` will be
allowed to spend on behalf of `owner` through transferFrom. This is
zero by default.

This value changes when approve or transferFrom are called.

```solidity
function allowance(
    address owner,
    address spender
) external view returns (
    uint256
);
```

### approve

Sets a `value` amount of tokens as the allowance of `spender` over the
caller's tokens.

Returns a boolean value indicating whether the operation succeeded.

IMPORTANT: Beware that changing an allowance with this method brings the risk
that someone may use both the old and the new allowance by unfortunate
transaction ordering. One possible solution to mitigate this race
condition is to first reduce the spender's allowance to 0 and set the
desired value afterwards:
https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729

Emits an Approval event.

```solidity
function approve(
    address spender,
    uint256 value
) external returns (
    bool
);
```

### balanceOf

Returns the value of tokens owned by `account`.

```solidity
function balanceOf(
    address account
) external view returns (
    uint256
);
```

### claimRewards

Claim rewards for a list of projects up to the given month.

```solidity
function claimRewards(
    uint256[] _projectIds,
    uint256 _month
) external returns (
    uint128 _claimedRewardsWei
);
```

#### Parameters

- `_projectIds`: The ids of the projects.
- `_month`: The month up to which (including) rewards will be claimed.

#### Returns

- `_claimedRewardsWei`: The total amount of rewards claimed (in wei).

### decimals

Returns the decimals places of the token.

```solidity
function decimals(
) external view returns (
    uint8
);
```

### distributeRewards

Distributes the rewards of a project for a given month to a list of recipients.
It must be called by the project's distributor.
It can only be called for the last or current month (if enabled).

```solidity
function distributeRewards(
    uint256 _projectId,
    uint256 _month,
    address[] _recipients,
    uint128[] _amountsWei
) external;
```

#### Parameters

- `_projectId`: The id of the project.
- `_month`: The month of the rewards.
- `_recipients`: The addresses of the recipients.
- `_amountsWei`: The amounts of rewards to distribute to each recipient (in wei).

### firstMonthStartTs

Returns the timestamp of the start of the first month.

```solidity
function firstMonthStartTs(
) external view returns (
    uint256
);
```

### getBalancesOf

Gets owner's balances of `WNat`, `RNat` and locked tokens.

```solidity
function getBalancesOf(
    address _owner
) external view returns (
    uint256 _wNatBalance,
    uint256 _rNatBalance,
    uint256 _lockedBalance
);
```

#### Parameters

- `_owner`: The address of the owner.

#### Returns

- `_wNatBalance`: The balance of `WNat` (in wei).
- `_rNatBalance`: The balance of `RNat` (in wei).
- `_lockedBalance`: The locked/vested balance (in wei).

### getClaimableRewards

Gets the claimable rewards of a project for a given owner.

```solidity
function getClaimableRewards(
    uint256 _projectId,
    address _owner
) external view returns (
    uint128
);
```

#### Parameters

- `_projectId`: The id of the project.
- `_owner`: The address of the owner.

#### Returns

- ``: The amount of rewards claimable by the owner (in wei).

### getCurrentMonth

Gets the current month.

```solidity
function getCurrentMonth(
) external view returns (
    uint256
);
```

#### Returns

- ``: The current month.

### getOwnerRewardsInfo

Gets the rewards information of a project for a given month and owner.

```solidity
function getOwnerRewardsInfo(
    uint256 _projectId,
    uint256 _month,
    address _owner
) external view returns (
    uint128 _assignedRewards,
    uint128 _claimedRewards,
    bool _claimable
);
```

#### Parameters

- `_projectId`: The id of the project.
- `_month`: The month of the rewards.
- `_owner`: The address of the owner.

#### Returns

- `_assignedRewards`: The amount of rewards assigned to the owner for the month (in wei).
- `_claimedRewards`: The amount of rewards claimed by the owner for the month (in wei).
- `_claimable`: Whether the rewards are claimable by the owner.

### getProjectInfo

Gets the information of a project.

```solidity
function getProjectInfo(
    uint256 _projectId
) external view returns (
    string _name,
    address _distributor,
    bool _currentMonthDistributionEnabled,
    bool _distributionDisabled,
    bool _claimingDisabled,
    uint128 _totalAssignedRewards,
    uint128 _totalDistributedRewards,
    uint128 _totalClaimedRewards,
    uint128 _totalUnassignedUnclaimedRewards,
    uint256[] _monthsWithRewards
);
```

#### Parameters

- `_projectId`: The id of the project.

#### Returns

- `_name`: The name of the project.
- `_distributor`: The address of the distributor.
- `_currentMonthDistributionEnabled`: Whether distribution is enabled for the current month.
- `_distributionDisabled`: Whether distribution is disabled.
- `_claimingDisabled`: Whether claiming is disabled.
- `_totalAssignedRewards`: The total amount of rewards assigned to the project (in wei).
- `_totalDistributedRewards`: The total amount of rewards distributed by the project (in wei).
- `_totalClaimedRewards`: The total amount of rewards claimed from the project (in wei).
- `_totalUnassignedUnclaimedRewards`: The total amount of unassigned unclaimed rewards (in wei).
- `_monthsWithRewards`: The months with rewards.

### getProjectRewardsInfo

Gets the rewards information of a project for a given month.

```solidity
function getProjectRewardsInfo(
    uint256 _projectId,
    uint256 _month
) external view returns (
    uint128 _assignedRewards,
    uint128 _distributedRewards,
    uint128 _claimedRewards,
    uint128 _unassignedUnclaimedRewards
);
```

#### Parameters

- `_projectId`: The id of the project.
- `_month`: The month of the rewards.

#### Returns

- `_assignedRewards`: The amount of rewards assigned to the project for the month (in wei).
- `_distributedRewards`: The amount of rewards distributed by the project for the month (in wei).
- `_claimedRewards`: The amount of rewards claimed from the project for the month (in wei).
- `_unassignedUnclaimedRewards`: The amount of unassigned unclaimed rewards for the month (in wei).

### getProjectsBasicInfo

Gets the basic information of all projects.

```solidity
function getProjectsBasicInfo(
) external view returns (
    string[] _names,
    bool[] _claimingDisabled
);
```

#### Returns

- `_names`: The names of the projects.
- `_claimingDisabled`: Whether claiming is disabled for each project.

### getProjectsCount

Gets the total number of projects.

```solidity
function getProjectsCount(
) external view returns (
    uint256
);
```

#### Returns

- ``: The total number of projects.

### getRNatAccount

Gets owner's RNat account. If it doesn't exist it reverts.

```solidity
function getRNatAccount(
    address _owner
) external view returns (
    contract IRNatAccount
);
```

#### Parameters

- `_owner`: Account to query.

#### Returns

- ``: Address of its RNat account.

### getRewardsInfo

Gets totals rewards information.

```solidity
function getRewardsInfo(
) external view returns (
    uint256 _totalAssignableRewards,
    uint256 _totalAssignedRewards,
    uint256 _totalClaimedRewards,
    uint256 _totalWithdrawnRewards,
    uint256 _totalWithdrawnAssignableRewards
);
```

#### Returns

- `_totalAssignableRewards`: The total amount of assignable rewards (in wei).
- `_totalAssignedRewards`: The total amount of assigned rewards (in wei).
- `_totalClaimedRewards`: The total amount of claimed rewards (in wei).
- `_totalWithdrawnRewards`: The total amount of withdrawn rewards (in wei).
- `_totalWithdrawnAssignableRewards`: The total amount of withdrawn once assignable rewards (in wei).

### name

Returns the name of the token.

```solidity
function name(
) external view returns (
    string
);
```

### setClaimExecutors

Sets the addresses of executors and adds the owner as an executor.

If any of the executors is a registered executor, some fee needs to be paid.

```solidity
function setClaimExecutors(
    address[] _executors
) external payable;
```

#### Parameters

- `_executors`: The new executors. All old executors will be deleted and replaced by these.

### symbol

Returns the symbol of the token.

```solidity
function symbol(
) external view returns (
    string
);
```

### totalSupply

Returns the value of tokens in existence.

```solidity
function totalSupply(
) external view returns (
    uint256
);
```

### transfer

Moves a `value` amount of tokens from the caller's account to `to`.

Returns a boolean value indicating whether the operation succeeded.

Emits a Transfer event.

```solidity
function transfer(
    address to,
    uint256 value
) external returns (
    bool
);
```

### transferExternalToken

Allows the caller to transfer ERC-20 tokens from their RNat account to the owner account.

The main use case is to move ERC-20 tokes received by mistake (by an airdrop, for example) out of the
RNat account and move them into the main account, where they can be more easily managed.

Reverts if the target token is the `WNat` contract: use method `withdraw` or `withdrawAll` for that.

```solidity
function transferExternalToken(
    contract IERC20 _token,
    uint256 _amount
) external;
```

#### Parameters

- `_token`: Target token contract address.
- `_amount`: Amount of tokens to transfer.

### transferFrom

Moves a `value` amount of tokens from `from` to `to` using the
allowance mechanism. `value` is then deducted from the caller's
allowance.

Returns a boolean value indicating whether the operation succeeded.

Emits a Transfer event.

```solidity
function transferFrom(
    address from,
    address to,
    uint256 value
) external returns (
    bool
);
```

### WNat

Returns the `WNat` contract.

```solidity
function wNat(
) external view returns (
    contract IWNat
);
```

### withdraw

Allows the caller to withdraw `WNat` wrapped tokens from their RNat account to the owner account.
In case there are some self-destruct native tokens left on the contract,
they can be transferred to the owner account using this method and `_wrap = false`.

```solidity
function withdraw(
    uint128 _amount,
    bool _wrap
) external;
```

#### Parameters

- `_amount`: Amount of tokens to transfer (in wei).
- `_wrap`: If `true`, the tokens will be sent wrapped in `WNat`. If `false`, they will be sent as `Nat`.

### withdrawAll

Allows the caller to withdraw `WNat` wrapped tokens from their RNat account to the owner account.
If some tokens are still locked, only 50% of them will be withdrawn, the rest will be burned as a penalty.
In case there are some self-destruct native tokens left on the contract,
they can be transferred to the owner account using this method and `_wrap = false`.

```solidity
function withdrawAll(
    bool _wrap
) external;
```

#### Parameters

- `_wrap`: If `true`, the tokens will be sent wrapped in `WNat`. If `false`, they will be sent as `Nat`.

## Events

### Approval

Emitted when the allowance of a `spender` for an `owner` is set by
a call to approve. `value` is the new allowance.

```solidity
event Approval(
    address owner,
    address spender,
    uint256 value
)
```

### ClaimingPermissionUpdated

```solidity
event ClaimingPermissionUpdated(
    uint256[] projectIds,
    bool disabled
)
```

### DistributionPermissionUpdated

```solidity
event DistributionPermissionUpdated(
    uint256[] projectIds,
    bool disabled
)
```

### ProjectAdded

```solidity
event ProjectAdded(
    uint256 id,
    string name,
    address distributor,
    bool currentMonthDistributionEnabled
)
```

### ProjectUpdated

```solidity
event ProjectUpdated(
    uint256 id,
    string name,
    address distributor,
    bool currentMonthDistributionEnabled
)
```

### RNatAccountCreated

```solidity
event RNatAccountCreated(
    address owner,
    contract IRNatAccount rNatAccount
)
```

### RewardsAssigned

```solidity
event RewardsAssigned(
    uint256 projectId,
    uint256 month,
    uint128 amount
)
```

### RewardsClaimed

```solidity
event RewardsClaimed(
    uint256 projectId,
    uint256 month,
    address owner,
    uint128 amount
)
```

### RewardsDistributed

```solidity
event RewardsDistributed(
    uint256 projectId,
    uint256 month,
    address[] recipients,
    uint128[] amounts
)
```

### RewardsUnassigned

```solidity
event RewardsUnassigned(
    uint256 projectId,
    uint256 month,
    uint128 amount
)
```

### Transfer

Emitted when `value` tokens are moved from one account (`from`) to
another (`to`).

Note that `value` may be zero.

```solidity
event Transfer(
    address from,
    address to,
    uint256 value
)
```

### UnassignedRewardsWithdrawn

```solidity
event UnassignedRewardsWithdrawn(
    address recipient,
    uint128 amount
)
```

### UnclaimedRewardsUnassigned

```solidity
event UnclaimedRewardsUnassigned(
    uint256 projectId,
    uint256 month,
    uint128 amount
)
```",2025-03-08 01:27:14
IWNat.md,"title: IWNat
description: Interface for wrapping and unwrapping native tokens.
sidebar_position: 7","Interface for wrapping and unwrapping native tokens.

Sourced from `IWNat.sol` on [GitHub](https://github.com/flare-foundation/flare-smart-contracts-v2/blob/main/contracts/userInterfaces/IWNat.sol).

## Functions

### allowance

Returns the remaining number of tokens that `spender` will be
allowed to spend on behalf of `owner` through transferFrom. This is
zero by default.

This value changes when approve or transferFrom are called.

```solidity
function allowance(
    address owner,
    address spender
) external view returns (
    uint256
);
```

### approve

Sets a `value` amount of tokens as the allowance of `spender` over the
caller's tokens.

Returns a boolean value indicating whether the operation succeeded.

IMPORTANT: Beware that changing an allowance with this method brings the risk
that someone may use both the old and the new allowance by unfortunate
transaction ordering. One possible solution to mitigate this race
condition is to first reduce the spender's allowance to 0 and set the
desired value afterwards:
https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729

Emits an Approval event.

```solidity
function approve(
    address spender,
    uint256 value
) external returns (
    bool
);
```

### balanceOf

Returns the value of tokens owned by `account`.

```solidity
function balanceOf(
    address account
) external view returns (
    uint256
);
```

### balanceOfAt

Queries the token balance of `_owner` at a specific `_blockNumber`.

```solidity
function balanceOfAt(
    address _owner,
    uint256 _blockNumber
) external view returns (
    uint256
);
```

#### Parameters

- `_owner`: The address from which the balance will be retrieved.
- `_blockNumber`: The block number to query.

#### Returns

- ``: The balance at `\_blockNumber`.

### batchDelegate

Undelegate all percentage delegations from the sender and then delegate corresponding
`_bips` percentage of voting power from the sender to each member of the `_delegatees` array.

```solidity
function batchDelegate(
    address[] _delegatees,
    uint256[] _bips
) external;
```

#### Parameters

- `_delegatees`: The addresses of the new recipients.
- `_bips`: The percentages of voting power to be delegated expressed in basis points (1/100 of one percent). The sum of all `_bips` values must be at most 10000 (100%).

### cleanupBlockNumber

Get the current cleanup block number set with `setCleanupBlockNumber()`.

```solidity
function cleanupBlockNumber(
) external view returns (
    uint256
);
```

#### Returns

- ``: The currently set cleanup block number.

### decimals

Returns the number of decimals used to get its user representation.
For example, if `decimals` equals 2, a balance of 505 tokens should
be displayed to a user as 5.05 (505 / 10<sup>2</sup>).

Tokens usually opt for a value of 18, imitating the relationship between
Ether and wei. This is the default value returned by this function, unless
it's overridden.

NOTE: This information is only used for _display_ purposes: it in
no way affects any of the arithmetic of the contract, including
balanceOf and transfer.

Should be compatible with ERC20 method.

```solidity
function decimals(
) external view returns (
    uint8
);
```

### delegate

Delegate voting power to account `_to` from `msg.sender`, by percentage.

```solidity
function delegate(
    address _to,
    uint256 _bips
) external;
```

#### Parameters

- `_to`: The address of the recipient.
- `_bips`: The percentage of voting power to be delegated expressed in basis points (1/100 of one percent). Not cumulative: every call resets the delegation value (and a value of 0 revokes all previous delegations).

### delegateExplicit

Explicitly delegate `_amount` voting power to account `_to` from `msg.sender`.
Compare with `delegate` which delegates by percentage.

```solidity
function delegateExplicit(
    address _to,
    uint256 _amount
) external;
```

#### Parameters

- `_to`: The address of the recipient.
- `_amount`: An explicit vote power amount to be delegated. Not cumulative: every call resets the delegation value (and a value of 0 revokes all previous delegations).

### delegatesOf

Get the list of addresses to which `_who` is delegating, and their percentages.

```solidity
function delegatesOf(
    address _who
) external view returns (
    address[] _delegateAddresses,
    uint256[] _bips,
    uint256 _count,
    uint256 _delegationMode
);
```

#### Parameters

- `_who`: The address to query.

#### Returns

- `_delegateAddresses`: Positional array of addresses being delegated to.
- `_bips`: Positional array of delegation percents specified in basis points (1/100 of 1 percent). Each one matches the address in the same position in the `_delegateAddresses` array.
- `_count`: The number of delegates.
- `_delegationMode`: Delegation mode: 0 = NOT SET, 1 = PERCENTAGE, 2 = AMOUNT (i.e. explicit).

### delegatesOfAt

Get the list of addresses to which `_who` is delegating, and their percentages, at the given block.

```solidity
function delegatesOfAt(
    address _who,
    uint256 _blockNumber
) external view returns (
    address[] _delegateAddresses,
    uint256[] _bips,
    uint256 _count,
    uint256 _delegationMode
);
```

#### Parameters

- `_who`: The address to query.
- `_blockNumber`: The block number to query.

#### Returns

- `_delegateAddresses`: Positional array of addresses being delegated to.
- `_bips`: Positional array of delegation percents specified in basis points (1/100 of 1 percent). Each one matches the address in the same position in the `_delegateAddresses` array.
- `_count`: The number of delegates.
- `_delegationMode`: Delegation mode: 0 = NOT SET, 1 = PERCENTAGE, 2 = AMOUNT (i.e. explicit).

### delegationModeOf

Get the delegation mode for account '\_who'. This mode determines whether vote power is
allocated by percentage or by explicit amount. Once the delegation mode is set,
it can never be changed, even if all delegations are removed.

```solidity
function delegationModeOf(
    address _who
) external view returns (
    uint256
);
```

#### Parameters

- `_who`: The address to get delegation mode.

#### Returns

- ``: Delegation mode: 0 = NOT SET, 1 = PERCENTAGE, 2 = AMOUNT (i.e. explicit).

### deposit

Deposit Native and mint WNat ERC20.

```solidity
function deposit(
) external payable;
```

### depositTo

Deposit Native from msg.sender and mints WNat ERC20 to recipient address.

```solidity
function depositTo(
    address recipient
) external payable;
```

#### Parameters

- `recipient`: An address to receive minted WNat.

### governanceVotePower

When set, allows token owners to participate in governance voting
and delegating governance vote power.

```solidity
function governanceVotePower(
) external view returns (
    contract IGovernanceVotePower
);
```

### name

Returns the name of the token.

Should be compatible with ERC20 method.

```solidity
function name(
) external view returns (
    string
);
```

### readVotePowerContract

Returns VPContract event interface used for read-only operations (view methods).
The only non-view method that might be called on it is `revokeDelegationAt`.

`readVotePowerContract` is almost always equal to `writeVotePowerContract`
except during an upgrade from one `VPContract` to a new version (which should happen
rarely or never and will be announced beforehand).

Do not call any methods on `VPContract` directly.
State changing methods are forbidden from direct calls.
All methods are exposed via `VPToken`.
This is the reason that this method returns `IVPContractEvents`.
Use it only for listening to events and revoking.

```solidity
function readVotePowerContract(
) external view returns (
    contract IVPContractEvents
);
```

### revokeDelegationAt

Revoke all delegation from sender to `_who` at given block.
Only affects the reads via `votePowerOfAtCached()` in the block `_blockNumber`.
Block `_blockNumber` must be in the past.
This method should be used only to prevent rogue delegate voting in the current voting block.
To stop delegating use delegate / delegateExplicit with value of 0 or undelegateAll / undelegateAllExplicit.

```solidity
function revokeDelegationAt(
    address _who,
    uint256 _blockNumber
) external;
```

#### Parameters

- `_who`: Address of the delegatee.
- `_blockNumber`: The block number at which to revoke delegation..

### setCleanerContract

Set the contract that is allowed to call history cleaning methods.

```solidity
function setCleanerContract(
    address _cleanerContract
) external;
```

#### Parameters

- `_cleanerContract`: Address of the cleanup contract. Usually this will be an instance of `CleanupBlockNumberManager`.

### setCleanupBlockNumber

Set the cleanup block number.
Historic data for the blocks before `cleanupBlockNumber` can be erased.
History before that block should never be used since it can be inconsistent.
In particular, cleanup block number must be lower than the current vote power block.

```solidity
function setCleanupBlockNumber(
    uint256 _blockNumber
) external;
```

#### Parameters

- `_blockNumber`: The new cleanup block number.

### symbol

Returns the symbol of the token, usually a shorter version of the name.

Should be compatible with ERC20 method.

```solidity
function symbol(
) external view returns (
    string
);
```

### totalSupply

Returns the value of tokens in existence.

```solidity
function totalSupply(
) external view returns (
    uint256
);
```

### totalSupplyAt

Total amount of tokens held by all accounts at a specific block number.

```solidity
function totalSupplyAt(
    uint256 _blockNumber
) external view returns (
    uint256
);
```

#### Parameters

- `_blockNumber`: The block number to query.

#### Returns

- ``: The total amount of tokens at `\_blockNumber`.

### totalVotePower

Get the current total vote power.

```solidity
function totalVotePower(
) external view returns (
    uint256
);
```

#### Returns

- ``: The current total vote power (sum of all accounts' vote power).

### totalVotePowerAt

Get the total vote power at block `_blockNumber`.

```solidity
function totalVotePowerAt(
    uint256 _blockNumber
) external view returns (
    uint256
);
```

#### Parameters

- `_blockNumber`: The block number to query.

#### Returns

- ``: The total vote power at the queried block (sum of all accounts' vote powers).

### transfer

Moves a `value` amount of tokens from the caller's account to `to`.

Returns a boolean value indicating whether the operation succeeded.

Emits a Transfer event.

```solidity
function transfer(
    address to,
    uint256 value
) external returns (
    bool
);
```

### transferFrom

Moves a `value` amount of tokens from `from` to `to` using the
allowance mechanism. `value` is then deducted from the caller's
allowance.

Returns a boolean value indicating whether the operation succeeded.

Emits a Transfer event.

```solidity
function transferFrom(
    address from,
    address to,
    uint256 value
) external returns (
    bool
);
```

### undelegateAll

Undelegate all voting power of `msg.sender`. This effectively revokes all previous delegations.
Can only be used with percentage delegation.
Does not reset delegation mode back to NOT SET.

```solidity
function undelegateAll(
) external;
```

### undelegateAllExplicit

Undelegate all explicit vote power by amount of `msg.sender`.
Can only be used with explicit delegation.
Does not reset delegation mode back to NOT SET.

```solidity
function undelegateAllExplicit(
    address[] _delegateAddresses
) external returns (
    uint256
);
```

#### Parameters

- `_delegateAddresses`: Explicit delegation does not store delegatees' addresses, so the caller must supply them.

#### Returns

- ``: The amount still delegated (in case the list of delegates was incomplete).

### undelegatedVotePowerOf

Compute the current undelegated vote power of the `_owner` account.

```solidity
function undelegatedVotePowerOf(
    address _owner
) external view returns (
    uint256
);
```

#### Parameters

- `_owner`: The address to query.

#### Returns

- ``: The unallocated vote power of `\_owner`.

### undelegatedVotePowerOfAt

Get the undelegated vote power of the `_owner` account at a given block number.

```solidity
function undelegatedVotePowerOfAt(
    address _owner,
    uint256 _blockNumber
) external view returns (
    uint256
);
```

#### Parameters

- `_owner`: The address to query.
- `_blockNumber`: The block number to query.

#### Returns

- ``: The unallocated vote power of `\_owner`.

### votePowerFromTo

Get current delegated vote power from delegator `_from` to delegatee `_to`.

```solidity
function votePowerFromTo(
    address _from,
    address _to
) external view returns (
    uint256
);
```

#### Parameters

- `_from`: Address of delegator.
- `_to`: Address of delegatee.

#### Returns

- ``: votePower The delegated vote power.

### votePowerFromToAt

Get delegated vote power from delegator `_from` to delegatee `_to` at `_blockNumber`.

```solidity
function votePowerFromToAt(
    address _from,
    address _to,
    uint256 _blockNumber
) external view returns (
    uint256
);
```

#### Parameters

- `_from`: Address of delegator.
- `_to`: Address of delegatee.
- `_blockNumber`: The block number to query.

#### Returns

- ``: The delegated vote power.

### votePowerOf

Get the current vote power of `_owner`.

```solidity
function votePowerOf(
    address _owner
) external view returns (
    uint256
);
```

#### Parameters

- `_owner`: The address to query.

#### Returns

- ``: Current vote power of `\_owner`.

### votePowerOfAt

Get the vote power of `_owner` at block `_blockNumber`

```solidity
function votePowerOfAt(
    address _owner,
    uint256 _blockNumber
) external view returns (
    uint256
);
```

#### Parameters

- `_owner`: The address to query.
- `_blockNumber`: The block number to query.

#### Returns

- ``: Vote power of `\_owner`at block number`\_blockNumber`.

### votePowerOfAtIgnoringRevocation

Get the vote power of `_owner` at block `_blockNumber`, ignoring revocation information (and cache).

```solidity
function votePowerOfAtIgnoringRevocation(
    address _owner,
    uint256 _blockNumber
) external view returns (
    uint256
);
```

#### Parameters

- `_owner`: The address to query.
- `_blockNumber`: The block number to query.

#### Returns

- ``: Vote power of `\_owner`at block number`\_blockNumber`. Result doesn't change if vote power is revoked.

### withdraw

Withdraw Native and burn WNat ERC20.

```solidity
function withdraw(
    uint256 amount
) external;
```

#### Parameters

- `amount`: The amount to withdraw.

### withdrawFrom

Withdraw WNat from an owner and send native tokens to msg.sender given an allowance.

```solidity
function withdrawFrom(
    address owner,
    uint256 amount
) external;
```

#### Parameters

- `owner`: An address spending the Native tokens.
- `amount`: The amount to spend. Requirements: - `owner` must have a balance of at least `amount`. - the caller must have allowance for `owners`'s tokens of at least `amount`.

### writeVotePowerContract

Returns VPContract event interface used for state-changing operations (non-view methods).
The only non-view method that might be called on it is `revokeDelegationAt`.

`writeVotePowerContract` is almost always equal to `readVotePowerContract`,
except during upgrade from one `VPContract` to a new version (which should happen
rarely or never and will be announced beforehand).
In the case of an upgrade, `writeVotePowerContract` is replaced first to establish delegations.
After some period (e.g., after a reward epoch ends), `readVotePowerContract` is set equal to it.

Do not call any methods on `VPContract` directly.
State changing methods are forbidden from direct calls.
All are exposed via `VPToken`.
This is the reason that this method returns `IVPContractEvents`
Use it only for listening to events, delegating, and revoking.

```solidity
function writeVotePowerContract(
) external view returns (
    contract IVPContractEvents
);
```",2025-03-08 01:27:14
IFlareContractRegistry.md,"title: IFlareContractRegistry
sidebar_position: 1
description: Registry interface with all Flare contract addresses.","Registry interface with all Flare contract addresses.

Sourced from `IFlareContractRegistry.sol` on [GitLab](https://gitlab.com/flarenetwork/flare-smart-contracts/-/blob/master/contracts/userInterfaces/IFlareContractRegistry.sol).

## Functions

### getContractAddressByName

Returns contract address for the given name - might be address(0)

```solidity
function getContractAddressByName(
    string _name
) external view returns (
    address);
```

#### Parameters

- `_name`: name of the contract

### getContractAddressByHash

Returns contract address for the given name hash - might be address(0)

```solidity
function getContractAddressByHash(
    bytes32 _nameHash
) external view returns (
    address);
```

#### Parameters

- `_nameHash`: hash of the contract name (keccak256(abi.encode(name))

### getContractAddressesByName

Returns contract addresses for the given names - might be address(0)

```solidity
function getContractAddressesByName(
    string[] _names
) external view returns (
    address[]);
```

#### Parameters

- `_names`: names of the contracts

### getContractAddressesByHash

Returns contract addresses for the given name hashes - might be address(0)

```solidity
function getContractAddressesByHash(
    bytes32[] _nameHashes
) external view returns (
    address[]);
```

#### Parameters

- `_nameHashes`: hashes of the contract names (keccak256(abi.encode(name))

### getAllContracts

Returns all contract names and corresponding addresses

```solidity
function getAllContracts(
) external view returns (
    string[] _names,
    address[] _addresses);
```",2025-03-08 01:27:14
RandomNumberV2Interface.md,"title: RandomNumberV2Interface
description: Primary interface for random number generation.
sidebar_position: 3","Primary interface for random number generation. This is a long-term support (LTS) interface, designed to ensure continuity even as underlying contracts evolve or protocols migrate to new versions.

Sourced from `RandomNumberV2Interface.sol` on [GitHub](https://github.com/flare-foundation/flare-smart-contracts-v2/blob/main/contracts/userInterfaces/LTS/RandomNumberV2Interface.sol).

## Functions

### getRandomNumber

Returns the current random number, its timestamp and the flag indicating if it is secure.

```solidity
function getRandomNumber(
) external view returns (
    uint256 _randomNumber,
    bool _isSecureRandom,
    uint256 _randomTimestamp
);
```

#### Returns

- `_randomNumber`: The current random number.
- `_isSecureRandom`: The flag indicating if the random number is secure.
- `_randomTimestamp`: The timestamp of the random number.

### getRandomNumberHistorical

Returns the historical random number for a given \_votingRoundId,
its timestamp and the flag indicating if it is secure.
If no finalization in the \_votingRoundId, the function reverts.

```solidity
function getRandomNumberHistorical(
    uint256 _votingRoundId
) external view returns (
    uint256 _randomNumber,
    bool _isSecureRandom,
    uint256 _randomTimestamp
);
```

#### Parameters

- `_votingRoundId`: The voting round id.

#### Returns

- `_randomNumber`: The current random number.
- `_isSecureRandom`: The flag indicating if the random number is secure.
- `_randomTimestamp`: The timestamp of the random number.",2025-03-08 01:27:14
RewardsV2Interface.md,"title: RewardsV2Interface
description: Primary interface for managing all protocol rewards.
sidebar_position: 4","Primary interface for managing all protocol rewards. This is a long-term support (LTS) interface, designed to ensure continuity even as underlying contracts evolve or protocols migrate to new versions.

Sourced from `RewardsV2Interface.sol` on [GitHub](https://github.com/flare-foundation/flare-smart-contracts-v2/blob/main/contracts/userInterfaces/LTS/RewardsV2Interface.sol).

## Functions

### active

Indicates if the contract is active - claims are enabled.

```solidity
function active(
) external view returns (
    bool
);
```

### claim

Claim rewards for `_rewardOwner` and transfer them to `_recipient`.
It can be called by reward owner or its authorized executor.

```solidity
function claim(
    address _rewardOwner,
    address payable _recipient,
    uint24 _rewardEpochId,
    bool _wrap,
    struct RewardsV2Interface.RewardClaimWithProof[] _proofs
) external returns (
    uint256 _rewardAmountWei
);
```

#### Parameters

- `_rewardOwner`: Address of the reward owner.
- `_recipient`: Address of the reward recipient.
- `_rewardEpochId`: Id of the reward epoch up to which the rewards are claimed.
- `_wrap`: Indicates if the reward should be wrapped (deposited) to the WNat contract.
- `_proofs`: Array of reward claims with merkle proofs.

#### Returns

- `_rewardAmountWei`: Amount of rewarded native tokens (wei).

### getNextClaimableRewardEpochId

Returns the next claimable reward epoch for a reward owner.

```solidity
function getNextClaimableRewardEpochId(
    address _rewardOwner
) external view returns (
    uint256
);
```

#### Parameters

- `_rewardOwner`: Address of the reward owner to query.

### getRewardEpochIdsWithClaimableRewards

Returns the start and the end of the reward epoch range for which the reward is claimable.

```solidity
function getRewardEpochIdsWithClaimableRewards(
) external view returns (
    uint24 _startEpochId,
    uint24 _endEpochId
);
```

#### Returns

- `_startEpochId`: The oldest epoch id that allows reward claiming.
- `_endEpochId`: The newest epoch id that allows reward claiming.

### getStateOfRewards

Returns the state of rewards for a given address for all unclaimed reward epochs with claimable rewards.

```solidity
function getStateOfRewards(
    address _rewardOwner
) external view returns (
    struct RewardsV2Interface.RewardState[][] _rewardStates
);
```

#### Parameters

- `_rewardOwner`: Address of the reward owner.

#### Returns

- `_rewardStates`: Array of reward states.

## Structures

### RewardClaim

Struct used in Merkle tree for storing reward claims.

```solidity
struct RewardClaim {
  uint24 rewardEpochId;
  bytes20 beneficiary;
  uint120 amount;
  enum RewardsV2Interface.ClaimType claimType;
}
```

### RewardClaimWithProof

Struct used for claiming rewards with Merkle proof.

```solidity
struct RewardClaimWithProof {
  bytes32[] merkleProof;
  struct RewardsV2Interface.RewardClaim body;
}
```

### RewardState

Struct used for returning state of rewards.

```solidity
struct RewardState {
  uint24 rewardEpochId;
  bytes20 beneficiary;
  uint120 amount;
  enum RewardsV2Interface.ClaimType claimType;
  bool initialised;
}
```

## Enums

### ClaimType

Claim type enum.

```solidity
enum ClaimType {
  DIRECT,
  FEE,
  WNAT,
  MIRROR,
  CCHAIN
}
```",2025-03-08 01:27:14
IClaimSetupManager.md,"title: IClaimSetupManager
sidebar_position: 5
description: Interface for managing reward claim setup.","Interface for managing reward claim setup.

Sourced from `IClaimSetupManager.sol` on [GitLab](https://gitlab.com/flarenetwork/flare-smart-contracts/-/blob/master/contracts/userInterfaces/IClaimSetupManager.sol).

## Functions

### setAutoClaiming

Sets the addresses of executors and optionally enables (creates) delegation account.
If setting registered executors some fee must be paid to them.

```solidity
function setAutoClaiming(
    address[] _executors,
    bool _enableDelegationAccount
) external payable;
```

#### Parameters

- `_executors`: The new executors. All old executors will be deleted and replaced by these.
- `_enableDelegationAccount`:

### setClaimExecutors

Sets the addresses of executors.
If setting registered executors some fee must be paid to them.

```solidity
function setClaimExecutors(
    address[] _executors
) external payable;
```

#### Parameters

- `_executors`: The new executors. All old executors will be deleted and replaced by these.

### setAllowedClaimRecipients

Set the addresses of allowed recipients.
Apart from these, the owner is always an allowed recipient.

```solidity
function setAllowedClaimRecipients(
    address[] _recipients
) external;
```

#### Parameters

- `_recipients`: The new allowed recipients. All old recipients will be deleted and replaced by these.

### enableDelegationAccount

Enables (creates) delegation account contract,
i.e. all airdrop and ftso rewards will be send to delegation account when using automatic claiming.

```solidity
function enableDelegationAccount(
) external returns (
    contract IDelegationAccount);
```

#### Returns

- ``: Address of delegation account contract.

### disableDelegationAccount

Disables delegation account contract,
i.e. all airdrop and ftso rewards will be send to owner's account when using automatic claiming.
Automatic claiming will not claim airdrop and ftso rewards for delegation account anymore.

```solidity
function disableDelegationAccount(
) external;
```

### registerExecutor

Allows executor to register and set initial fee value.
If executor was already registered before (has fee set), only update fee after `feeValueUpdateOffset`.
Executor must pay fee in order to register - `registerExecutorFeeValueWei`.

```solidity
function registerExecutor(
    uint256 _feeValue
) external payable returns (
    uint256);
```

#### Parameters

- `_feeValue`: number representing fee value

#### Returns

- ``: Returns the reward epoch number when the setting becomes effective.

### unregisterExecutor

Allows executor to unregister.

```solidity
function unregisterExecutor(
) external returns (
    uint256);
```

#### Returns

- ``: Returns the reward epoch number when the setting becomes effective.

### updateExecutorFeeValue

Allows registered executor to set (or update last scheduled) fee value.

```solidity
function updateExecutorFeeValue(
    uint256 _feeValue
) external returns (
    uint256);
```

#### Parameters

- `_feeValue`: number representing fee value

#### Returns

- ``: Returns the reward epoch number when the setting becomes effective.

### delegate

Delegate `_bips` of voting power to `_to` from msg.sender's delegation account

```solidity
function delegate(
    address _to,
    uint256 _bips
) external;
```

#### Parameters

- `_to`: The address of the recipient
- `_bips`: The percentage of voting power to be delegated expressed in basis points (1/100 of one percent). Not cumulative - every call resets the delegation value (and value of 0 revokes delegation).

### batchDelegate

Undelegate all percentage delegations from the msg.sender's delegation account and then delegate
corresponding `_bips` percentage of voting power to each member of `_delegatees`.

```solidity
function batchDelegate(
    address[] _delegatees,
    uint256[] _bips
) external;
```

#### Parameters

- `_delegatees`: The addresses of the new recipients.
- `_bips`: The percentages of voting power to be delegated expressed in basis points (1/100 of one percent). Total of all `_bips` values must be at most 10000.

### undelegateAll

Undelegate all voting power for delegates of msg.sender's delegation account

```solidity
function undelegateAll(
) external;
```

### revokeDelegationAt

Revoke all delegation from msg.sender's delegation account to `_who` at given block.
Only affects the reads via `votePowerOfAtCached()` in the block `_blockNumber`.
Block `_blockNumber` must be in the past.
This method should be used only to prevent rogue delegate voting in the current voting block.
To stop delegating use delegate with value of 0 or undelegateAll.

```solidity
function revokeDelegationAt(
    address _who,
    uint256 _blockNumber
) external;
```

### delegateGovernance

Delegate all governance vote power of msg.sender's delegation account to `_to`.

```solidity
function delegateGovernance(
    address _to
) external;
```

#### Parameters

- `_to`: The address of the recipient

### undelegateGovernance

Undelegate governance vote power for delegate of msg.sender's delegation account

```solidity
function undelegateGovernance(
) external;
```

### withdraw

Allows user to transfer WNat to owner's account.

```solidity
function withdraw(
    uint256 _amount
) external;
```

#### Parameters

- `_amount`: Amount of tokens to transfer

### transferExternalToken

Allows user to transfer balance of ERC20 tokens owned by the personal delegation contract.
The main use case is to transfer tokens/NFTs that were received as part of an airdrop or register
as participant in such airdrop.

```solidity
function transferExternalToken(
    contract IERC20 _token,
    uint256 _amount
) external;
```

#### Parameters

- `_token`: Target token contract address
- `_amount`: Amount of tokens to transfer

### accountToDelegationAccount

Gets the delegation account of the `_owner`. Returns address(0) if not created yet.

```solidity
function accountToDelegationAccount(
    address _owner
) external view returns (
    address);
```

### getDelegationAccountData

Gets the delegation account data for the `_owner`. Returns address(0) if not created yet.

```solidity
function getDelegationAccountData(
    address _owner
) external view returns (
    contract IDelegationAccount _delegationAccount,
    bool _enabled);
```

#### Parameters

- `_owner`: owner's address

#### Returns

- `_delegationAccount`: owner's delegation account address - could be address(0)
- `_enabled`: indicates if delegation account is enabled

### claimExecutors

Get the addresses of executors.

```solidity
function claimExecutors(
    address _owner
) external view returns (
    address[]);
```

### allowedClaimRecipients

Get the addresses of allowed recipients.
Apart from these, the owner is always an allowed recipient.

```solidity
function allowedClaimRecipients(
    address _rewardOwner
) external view returns (
    address[]);
```

### isClaimExecutor

Returns info if `_executor` is allowed to execute calls for `_owner`

```solidity
function isClaimExecutor(
    address _owner,
    address _executor
) external view returns (
    bool);
```

### getRegisteredExecutors

Get registered executors

```solidity
function getRegisteredExecutors(
    uint256 _start,
    uint256 _end
) external view returns (
    address[] _registeredExecutors,
    uint256 _totalLength);
```

### getExecutorInfo

Returns some info about the `_executor`

```solidity
function getExecutorInfo(
    address _executor
) external view returns (
    bool _registered,
    uint256 _currentFeeValue);
```

#### Parameters

- `_executor`: address representing executor

#### Returns

- `_registered`: information if executor is registered
- `_currentFeeValue`: executor's current fee value

### getExecutorCurrentFeeValue

Returns the current fee value of `_executor`

```solidity
function getExecutorCurrentFeeValue(
    address _executor
) external view returns (
    uint256);
```

#### Parameters

- `_executor`: address representing executor

### getExecutorFeeValue

Returns the fee value of `_executor` at `_rewardEpoch`

```solidity
function getExecutorFeeValue(
    address _executor,
    uint256 _rewardEpoch
) external view returns (
    uint256);
```

#### Parameters

- `_executor`: address representing executor
- `_rewardEpoch`: reward epoch number

### getExecutorScheduledFeeValueChanges

Returns the scheduled fee value changes of `_executor`

```solidity
function getExecutorScheduledFeeValueChanges(
    address _executor
) external view returns (
    uint256[] _feeValue,
    uint256[] _validFromEpoch,
    bool[] _fixed);
```

#### Parameters

- `_executor`: address representing executor

#### Returns

- `_feeValue`: positional array of fee values
- `_validFromEpoch`: positional array of reward epochs the fee settings are effective from
- `_fixed`: positional array of boolean values indicating if settings are subjected to change

## Events

### DelegationAccountCreated

```solidity
event DelegationAccountCreated(
    address owner,
    contract IDelegationAccount delegationAccount
)
```

### DelegationAccountUpdated

```solidity
event DelegationAccountUpdated(
    address owner,
    contract IDelegationAccount delegationAccount,
    bool enabled
)
```

### ClaimExecutorsChanged

```solidity
event ClaimExecutorsChanged(
    address owner,
    address[] executors
)
```

### AllowedClaimRecipientsChanged

```solidity
event AllowedClaimRecipientsChanged(
    address owner,
    address[] recipients
)
```

### ClaimExecutorFeeValueChanged

```solidity
event ClaimExecutorFeeValueChanged(
    address executor,
    uint256 validFromRewardEpoch,
    uint256 feeValueWei
)
```

### ExecutorRegistered

```solidity
event ExecutorRegistered(
    address executor
)
```

### ExecutorUnregistered

```solidity
event ExecutorUnregistered(
    address executor,
    uint256 validFromRewardEpoch
)
```

### MinFeeSet

```solidity
event MinFeeSet(
    uint256 minFeeValueWei
)
```

### MaxFeeSet

```solidity
event MaxFeeSet(
    uint256 maxFeeValueWei
)
```

### RegisterExecutorFeeSet

```solidity
event RegisterExecutorFeeSet(
    uint256 registerExecutorFeeValueWei
)
```

### SetExecutorsExcessAmountRefunded

```solidity
event SetExecutorsExcessAmountRefunded(
    address owner,
    uint256 excessAmount
)
```",2025-03-08 01:27:14
IDistributionToDelegators.md,"title: IDistributionToDelegators
sidebar_position: 6
description: Interface for managing FlareDrop claims.","Interface for managing FlareDrop claims.

Sourced from `IDistributionToDelegators.sol` on [GitLab](https://gitlab.com/flarenetwork/flare-smart-contracts/-/blob/master/contracts/userInterfaces/IDistributionToDelegators.sol).

Manages the ongoing distribution of tokens from the Delegation Incentive Pool (the ""FlareDrop""). The approval of [FIP.01](https://proposals.flare.network/FIP/FIP_1) created this pool, that releases its tokens every 30 days, over a period of 36 months, to all accounts holding Wrapped FLR.

## Functions

### claim

Allows the sender to claim or wrap rewards for reward owner.
The caller does not have to be the owner, but must be approved by the owner to claim on his behalf,
this approval is done by calling `setClaimExecutors`.
It is actually safe for this to be called by anybody (nothing can be stolen), but by limiting who can
call, we allow the owner to control the timing of the calls.
Reward owner can claim to any `_recipient`, while the executor can only claim to the reward owner,
reward owners's personal delegation account or one of the addresses set by `setAllowedClaimRecipients`.

```solidity
function claim(
    address _rewardOwner,
    address _recipient,
    uint256 _month,
    bool _wrap
) external returns (
    uint256 _rewardAmount);
```

#### Parameters

- `_rewardOwner`: address of the reward owner
- `_recipient`: address to transfer funds to
- `_month`: last month to claim for
- `_wrap`: should reward be wrapped immediately

#### Returns

- `_rewardAmount`: amount of total claimed rewards

### autoClaim

Allows batch claiming for the list of '\_rewardOwners' up to given '\_month'.
If reward owner has enabled delegation account, rewards are also claimed for that delegation account and
total claimed amount is sent to that delegation account, otherwise claimed amount is sent to owner's account.
Claimed amount is automatically wrapped.
Method can be used by reward owner or executor. If executor is registered with fee > 0,
then fee is paid to executor for each claimed address from the list.

```solidity
function autoClaim(
    address[] _rewardOwners,
    uint256 _month
) external;
```

#### Parameters

- `_rewardOwners`: list of reward owners to claim for
- `_month`: last month to claim for

### optOutOfAirdrop

Method to opt-out of receiving airdrop rewards

```solidity
function optOutOfAirdrop(
) external;
```

### nextClaimableMonth

Returns the next claimable month for '\_rewardOwner'.

```solidity
function nextClaimableMonth(
    address _rewardOwner
) external view returns (
    uint256);
```

#### Parameters

- `_rewardOwner`: address of the reward owner

### getClaimableAmount

get claimable amount of wei for requesting account for specified month

```solidity
function getClaimableAmount(
    uint256 _month
) external view returns (
    uint256 _amountWei);
```

#### Parameters

- `_month`: month of interest

#### Returns

- `_amountWei`: amount of wei available for this account and provided month

### getClaimableAmountOf

get claimable amount of wei for account for specified month

```solidity
function getClaimableAmountOf(
    address _account,
    uint256 _month
) external view returns (
    uint256 _amountWei);
```

#### Parameters

- `_account`: the address of an account we want to get the claimable amount of wei
- `_month`: month of interest

#### Returns

- `_amountWei`: amount of wei available for provided account and month

### getCurrentMonth

Returns the current month

```solidity
function getCurrentMonth(
) external view returns (
    uint256 _currentMonth);
```

#### Returns

- `_currentMonth`: Current month, 0 before entitlementStartTs

### getMonthToExpireNext

Returns the month that will expire next

```solidity
function getMonthToExpireNext(
) external view returns (
    uint256 _monthToExpireNext);
```

#### Returns

- `_monthToExpireNext`: Month that will expire next, 36 when last month expired

### getClaimableMonths

Returns claimable months - reverts if none

```solidity
function getClaimableMonths(
) external view returns (
    uint256 _startMonth,
    uint256 _endMonth);
```

#### Returns

- `_startMonth`: first claimable month
- `_endMonth`: last claimable month

## Events

### UseGoodRandomSet

```solidity
event UseGoodRandomSet(
    bool useGoodRandom,
    uint256 maxWaitForGoodRandomSeconds
)
```

### EntitlementStart

```solidity
event EntitlementStart(
    uint256 entitlementStartTs
)
```

### AccountClaimed

```solidity
event AccountClaimed(
    address whoClaimed,
    address sentTo,
    uint256 month,
    uint256 amountWei
)
```

### AccountOptOut

```solidity
event AccountOptOut(
    address theAccount,
    bool confirmed
)
```",2025-03-08 01:27:14
4-solidity-reference.mdx,"title: FSP Reference
description: Solidity reference for Flare contracts.
keywords: [solidity, reference, ftso, flare-network, smart-contracts]","import Tabs from ""@theme/Tabs"";
import TabItem from ""@theme/TabItem"";
import DocCardList from ""@theme/DocCardList"";
import SolidityReference from ""@site/src/components/DataTables/SolidityReference"";

## Deployed Contracts

export const contracts = [
  ""EntityManager"",
  ""Submission"",
  ""FlareSystemsManager"",
  ""Relay"",
  ""RewardManager"",
  ""VoterRegistry"",
  ""FlareSystemsCalculator"",
  ""WNatDelegationFee"",
];

<Tabs block>
    <TabItem value=""flare"" label=""Flare Mainnet"" default>

        <SolidityReference
            network=""FlareMainnet""
            contractNames={contracts}
        />

    </TabItem>
    <TabItem value=""coston2"" label=""Flare Testnet Coston2"">

        <SolidityReference
            network=""FlareTestnetCoston2""
            contractNames={contracts}
        />

    </TabItem>
    <TabItem value=""songbird"" label=""Songbird Canary-Network"">

        <SolidityReference
            network=""SongbirdCanaryNetwork""
            contractNames={contracts}
        />

    </TabItem>
    <TabItem value=""coston"" label=""Songbird Testnet Coston"">


        <SolidityReference
            network=""SongbirdTestnetCoston""
            contractNames={contracts}
        />

    </TabItem>

</Tabs>

## Interfaces

<DocCardList />",2025-03-08 01:27:14
1-system-protocols.mdx,"title: System Protocols
description: Describes the core protocols comprising FSP.
keywords:
  [flare-network, configuration, blockchain, data, smart-contracts, wallets]","The **Flare Systems Protocol** encompasses the following core system protocols:

1. **P-chain Stake Voting Protocol**
2. **Signing Policy Definition Protocol**
3. **Validator Uptime Voting Protocol**
4. **Reward Voting Protocol**
5. **Random Number Generation Protocol** (dependent on the FTSOv2 Scaling)

Protocols with voting frequencies tied to reward epochs are implemented directly on the [`FlareSystemsManager`](/network/fsp/solidity-reference/IFlareSystemsManager) smart contract, while others operate as sub-protocols. Each sub-protocol has a unique protocol ID, except for the system protocols mentioned above.

## P-chain Stake Voting Protocol

- **Protocol ID**: 1
- **Voting Frequency**: Per voting epoch
- **Description**: Functions similarly to sub-protocols, using the Flare Systems Client to submit signatures for Merkle tree-based protocol messages. It captures stake and delegation records from the P-chain during each voting epoch.
- **Finalization**: Occurs on the Relay contract.
- **Incentives**: Rewards for timely signing and finalization come from inflation. However, mirroring weights to delegators is not incentivized.

**Infrastructure**: Utilizes a Flare P-chain indexer, requiring a specially configured observation node.

## Signing Policy Definition Protocol

- **Voting Frequency**: Per reward epoch
- **Description**: Ensures that voter weights for the next reward epoch are locked and signed by a threshold weight of current voters. This information is relayed to other EVM chains, enabling cross-chain message relaying.

  **Phases**:

  - **Random Number Acquisition**: Triggered 2 hours before the end of the reward epoch. The random number is fetched via the FTSO scaling protocol.
  - **Vote Power Block Selection**: Occurs after random number acquisition to select a block for vote power.
  - **Voter Registration**: Lasts 30 minutes, allowing self-registration based on the selected block‚Äôs weights.
  - **Signing Policy Snapshot**: Snapshots voter addresses, weights, and thresholds for the next reward epoch.
  - **Signing Policy Sign Phase**: Ends when the threshold of signatures is reached. Delays beyond 20 minutes incur penalties.

- **Finalization**: Via the `signNewSigningPolicy` function.
- **Incentives**: No direct rewards; instead, delays incur penalties by burning fee claims based on the extent of delay.

**Infrastructure**: Utilizes the Flare indexer.

## Validator Uptime Voting Protocol

- **Voting Frequency**: Per reward epoch
- **Description**: After each reward epoch, voters submit signed lists of validator NodeIDs with sufficient uptime (‚â•80%). Voting concludes when a threshold weight (e.g., 60%) is reached.
- **Finalization**: Through the `signUptimeVote` function.
- **Incentives**: Collective penalization for delays by blocking reward claims.

**Infrastructure**: Requires a connection to a local node, reusing the Flare P-chain indexer infrastructure.

## Reward Voting Protocol

- **Voting Frequency**: Per reward epoch
- **Description**: After each reward epoch, and once uptime voting is complete, voters aggregate reward claims across sub-protocols into a Merkle tree. A final Merkle root is voted on, enabling the `RewardManager` contract to verify and pay out rewards.

  **Process**:

  - Sub-protocols submit reward claims based on participation data.
  - The aggregated claims form a Merkle tree, with voting to confirm the root.

- **Finalization**: Via the `signRewards` function.
- **Incentives**: No special rewards; delays penalize all voters by blocking reward distribution.

**Infrastructure**: Uses sub-protocol-specific scripts and data from the Flare indexer.

## Random Number Generation Protocol

- **Description**: Random numbers are generated by the [FTSOv2 Scaling](/ftso/scaling/overview). These are used for masking commits and are calculated from reveals during the scaling process. The random number forms part of a Merkle tree, confirmed via the Relay contract.

## Additional Non-System Sub-Protocols

- **Protocol ID 14**: [FTSOv2 Scaling](/ftso/scaling/overview)
- **Protocol IDs 20+**: [FDC](/fdc/overview) Instances
  - Multiple instances allow scaling, lower finalization thresholds, and segregation based on maturity and security considerations.",2025-03-08 01:27:14
0-protocol-components.mdx,"title: Protocol Components
description: Defines the structure, voting, and weight calculations for FSP.
keywords:
  [flare-network, configuration, blockchain, data, smart-contracts, wallets]","## Voters

Voters are off-chain participants in Flare's protocols, responsible for threshold-weighted voting across all sub-protocols. The system anticipates **100 voters**, selected among validators with the highest vote power.

**Vote Power Sources**:

- **P-chain Stake**: Adding FLR stake to a validator node.
- **WNat Delegations**: Community members delegate vote power via the WNat smart contract.

Each voter is identified by an **identity address** (managed securely via cold wallets), used for:

- Establishing voter identity.
- Conducting admin operations (e.g., setting fees, signing addresses, delegation addresses).
- Enabling delegations to a voter's address for WNat and staking weight.

**Signing and Prioritized Addresses**:

- Voters can set a **signing address** (hot wallet) for protocol participation.
- **Prioritized submission addresses** are used for on-chain communication, defaulting to the identity address.
- Rewards are distributed either directly to the identity address or based on participation weights (delegation and node IDs).

## Voting Periods

- **Voting Epoch**: The shortest voting unit, lasting **90 seconds**. The first epoch starts at `T0` and increments by `i * 90s`.
- **Reward Epoch**: Comprises **3360 voting epochs** (approx. 3.5 days). Identified by reward epoch IDs, with each reward epoch starting after the previous one concludes. However, reward epochs may be extended due to network delays.

**Voting Rounds**:

- Sub-protocols typically vote once per voting epoch.
- System protocols may vote once per reward epoch.
- Each voting round is identified by the ID of the epoch in which it started.

## Voting Results and Finalization

Each sub-protocol aims to reach consensus on a **Merkle root** for every voting round:

- Voters independently compute candidate Merkle roots and submit signed roots on-chain.
- A root is confirmed if it surpasses a **50%+ voting weight threshold**.
- Finalization occurs when signatures exceeding the threshold are submitted to the [`Relay`](/network/fsp/solidity-reference/IRelay) contract, which verifies and stores confirmed Merkle roots. These are accessible for proof verification by other smart contracts.

**Protocol Message Structure**:

- (`pID`, `roundID`, `isSecureRandom`, `root`): Contains sub-protocol ID, voting round ID, random number status, and Merkle root.

**Random Number Inclusion**:

- Certain protocols (e.g., FTSO scaling) embed random numbers into Merkle trees, enabling secure random number generation for further use.

## Using Confirmed Voting Results

To verify data on-chain:

1. Smart contracts receive:
   - Protocol data (structured as a Solidity struct).
   - Voting round ID.
   - Merkle proof.
2. The smart contract encodes the data and applies the Merkle proof to match the confirmed root from the **Relay contract**.
3. If the roots match, the data is verified.

## Voting (Signing) Policies

Voter eligibility and weights are determined for each **reward epoch** (~3.5 days). The **Signing Policy Definition Protocol** sets the eligible voters, their weights, and the threshold required for confirmation before each reward epoch begins.

**Sources of Voting Weight**:

- **P-chain Stake ($W_P$)**: Long-term staked FLR.
- **Mirrored Stake ($W_M$)**: Roughly similar to $W_P$
- **C-chain Stake ($W_C$)**: Planned for future use.
- **WNat Delegations ($W_{WFLR}$)**: Community-delegated vote power on the WNat contract.

**Aggregated Voting Weight**:

$$
W(v, r) = A(W_{M}(v, r), W_{C}(v, r), W_{WFLR}(v, r))
$$

- **Capped WFLR**: Limited to 2.5% of total wrapped weight.
- **Total Voting Weight**: Calculated by summing up the weights of all eligible voters.

## Weight Participation and Fees

- **P-chain Stake**: Requires a node ID and declared staking fee. Delegators contribute to the weight by staking on node IDs.
- **WNat Delegations**: Voters set delegation fees on the [`EntityManager`](/network/fsp/solidity-reference/IEntityManager) contract. Community members delegate to addresses based on yields and fees.
- **C-chain Stake**: Participation logic is under development.

## Signing Policies and Thresholds

A **signing policy** includes:

- `rewardEpochId`: Reward epoch ID.
- `startVotingRoundId`: Indicates the start of a reward epoch.
- `voters`: Canonical list of voter addresses.
- `weights`: Compressed, normalized weights (2-byte values).
- `threshold`: Usually set to **50%+** of total weight.
- `seed`: Secure random seed.

**Threshold Adjustments**:

- Regular threshold: **50%+**
- In case of delays: **60%+**

## Signature Verification

Uses standard ECDSA signatures. The [`Relay`](/network/fsp/solidity-reference/IRelay) contract checks if the signing policy is supported by comparing stored hashes with the provided calldata, minimizing on-chain storage costs.

## Random Number Generation

Random numbers are generated as a byproduct of [FTSOv2 Scaling](/ftso/scaling/overview) using a commit-reveal process.",2025-03-08 01:27:14
3-rewarding.mdx,"title: Rewarding
description: Explains the structure for distributing rewards in FSP.
keywords:
  [flare-network, configuration, blockchain, data, smart-contracts, wallets]","Flare's sub-protocols utilize a uniform signing weight for decision-making; however, reward distribution is based on the delegators' participation weights. Each sub-protocol calculates rewards for various participation weight types, allowing delegators to claim rewards according to their specific contribution shares.

All rewards are managed through the [`RewardManager`](/network/fsp/solidity-reference/IRewardManager) contract and are claimable after the reward epoch concludes. Sub-protocols implement their own contracts to gather rewarding inputs, which are passed to the Reward Manager for distribution. Funding is provided by sub-protocol-specific contracts, which may also handle inflation-based rewards through automated offers.

## Claim Structure

Rewards are distributed through **reward claims**, which are data records indicating the allocation of rewards. Each claim consists of the following fields:

- `rewardEpochId`: Identifier for the reward epoch.
- `beneficiary`: The reward recipient, specified by address or node ID (20 bytes).
- `amount`: Reward amount in FLR.
- `claimType`: The category of the reward claim, which can be one of the following:
  - `direct`: Rewards directly attributed to the beneficiary (address). Used for undistributed rewards, fund providers, burn claims, or specific rewarding approaches within sub-protocols.
  - `fee`: Similar to 'direct' but specific to eligible voters. Covers delegation fees (WFLR) and node staking fees.
  - `wflr`: Rewards for eligible voters, distributed to delegators based on their participation in WWFLR.
  - `mirror`: Rewards distributed to delegators based on their participation in WM.
  - `cchain`: Rewards for eligible voters, distributed based on their share in WC.

Weight-based claims (`wflr`, `mirror`, `cchain`) represent total rewards for voters, to be distributed according to the delegators' participation in the voters' weight.

## Calculation Process

Each sub-protocol is responsible for calculating its partial reward claims for each reward epoch by:

1. **Data Input**: Determining the relevant data sources (indexers).
2. **Data Retrieval**: Querying data from indexers.
3. **Reward Calculation**: Implementing reward algorithms to produce partial reward claims.

**Partial reward claims** may have a negative amount if penalization is applied. The **Reward Voting Protocol** aggregates these partial claims into a single claim per beneficiary and type. The final claims are structured into a Merkle tree, and the Merkle root is confirmed through a voting process.

## Claiming Process

Once the Merkle root is confirmed for a reward epoch, rewards can be claimed via the **Reward Manager contract**:

- For `direct` or `fee` claims, rewards are transferred directly to the beneficiary upon proof verification.
- For **weight-based claims**, the process involves two steps:
  1. **Initialization**: Submission of a reward claim with a Merkle proof to initialize variables.
  2. **Delegator Claims**: Delegators can then claim their share without needing additional proofs.

Once initialized, delegators can claim rewards through the Reward Manager contract. The reward for a delegator `x` is calculated as:

$$
\text{reward} = \frac{U_{T,r,b}^{amount} \times w(r, T, x, b)}{U_{T,r,b}^{weight}}
$$

where:

{/* prettier-ignore */}
- $ U_{T,r,b}^{weight} $ is the unclaimed delegation weight for reward epoch $r$ and beneficiary $b$.
{/* prettier-ignore */}
- $ U_{T,r,b}^{amount} $ is the unclaimed reward amount for reward epoch $r$ and beneficiary $b$.
- $ w(r, T, x, b) $ is the weight delegated by $x$ to $b$ for weight type $T$ during reward epoch $r$.
- The claimed reward reduces the unclaimed amount and weight, and the payout is made directly to $x$.

## Incentivizing Fast Signing and Finalization

Sub-protocols are designed to encourage fast signature deposition and finalization:

1. **Finalization Rewards**:

   - The first entity to finalize a Merkle root earns the reward.
   - To avoid centralization, rewards prioritize eligible voters and distribute based on their weight.
   - A grace period (20s) allows selected data providers to finalize or attempt finalization before others.

2. **Signing Deposition Rewards**:
   - Voters submitting signatures within a grace period (10s) receive rewards.
   - Signatures submitted until the block of finalization are also rewarded if they meet weight thresholds.

### Finalization Incentives

During the **grace period** for finalization (20s), selected data providers are rewarded based on a pseudo-random selection algorithm:

- A hash value is used to determine which voters are eligible for finalization rewards based on their signing weight.
- Voters are selected in proportion to their weights, and rewards are distributed among them.

If finalization is not completed within the grace period, the first to finalize receives the full reward, provided it happens within the extended reward window (`i + 2` voting epochs).

### Claim Generation and Reward Distribution

Each sub-protocol allocates rewards for:

1. **Finalization**: Rewards for submitting sufficient signatures to finalize a Merkle root.
2. **Signing Deposition**: Rewards for voters who timely submit valid signatures.

The reward amount attributed to a voter is split into:

- **Fee Claims**: Deducted as delegation fees (WNat delegations).
- **Weight Participation Claims**: Remaining rewards are distributed among delegators and stakers based on their weights.",2025-03-08 01:27:14
2-offchain-services.mdx,"title: Offchain Services
description: Outlines the architecture of off-chain services supporting FSP.
keywords:
  [flare-network, configuration, blockchain, data, smart-contracts, wallets]","The **Flare Systems Protocol** utilizes a set of off-chain services encapsulated within the **Flare Systems Client**. These services interact with blockchain smart contracts to support various protocols. Key components include:

1. **Protocol Manager Service**: Handles periodic transactions (`submit1`, `submit2`, `submitSignatures`, and future `submit3`) for each voting round by querying protocol data providers.
2. **Reward Aggregator Service**: Submits the Merkle root of combined reward claims once per reward epoch.
3. **Signing Policy Voter Service**: Signs new signing policies after they are defined, once per reward epoch.
4. **Voter Registration Service**: Registers voters on the [`VoterRegistry`](/network/fsp/solidity-reference/IVoterRegistry) contract.
5. **Finalizer Service**: Submits finalization transactions when a voter is eligible to finalize a specific sub-protocol.
6. **Scheduler**: Coordinates transaction scheduling across services.
7. **Uptime Voting Client**: Submits validator uptime votes once per reward epoch.

Each voter runs an independent instance of the **Flare Systems Client**, which manages private keys and transaction submissions, enabling participation across multiple sub-protocols.

## Protocol Manager Service

The **Protocol Manager Service** sends the following transactions within each voting epoch:

- **submit1, submit2, submit3**: Data submission at scheduled times.
- **submitSignatures**: Submits signatures once all required data is collected.

**Data Flow**:

1. The service queries protocol data providers via API to fetch data.
2. The fetched data is processed, encoded, and sent in transaction calldata as:
   ```
   tx_data = function_selector + concatenated_data
   ```
   where each payload includes:
   - `protocolId` (1 byte)
   - `votingRoundId` (4 bytes)
   - `size` (2 bytes)
   - `payload` (encoded protocol data)

**API Endpoints for Protocol Data Providers**:

- `GET /submit1/:votingRoundId/:submitAddress`
- `GET /submit2/:votingRoundId/:submitAddress`
- `GET /submitSignatures/:votingRoundId/:submitSignaturesAddress`
- `GET /submit3/:votingRoundId/:submitAddress`

**Response Format**:

```json
{
  ""status"": ""OK"",
  ""data"": ""0x1234..."",
  ""additionalData"": ""0x5678...""
}
```

The services are voter-agnostic, requiring only `votingRoundId` and `submitAddress` as inputs.

## Reward Aggregator Service

The **Reward Aggregator Service** calculates and submits the Merkle root of reward claims at the end of each reward epoch:

- Fetches reward data from protocol reward calculators using C-chain and P-chain indexers.
- Submits the final Merkle root via `signRewards`.

**API for Reward Calculation**:

- `GET /rewards/:rewardEpochId`
- Response:
  ```json
  {
    ""status"": ""OK"",
    ""data"": ""0xabc123...""
  }
  ```

## Signing Policy Voter Service

Monitors the `SigningPolicyInitialized` event on the Relay contract:

- Signs the new policy using `signNewSigningPolicy`.
- Tracks `SigningPolicySigned` events to determine if further signatures are needed.

## Voter Registration Service

- Listens for `VotePowerBlockSelected` events.
- Registers the voter on the `VoterRegistry` contract before the `SigningPolicyInitialized` event signals the end of the registration period.

## Finalizer Service

The **Finalizer Service** handles finalizing votes:

- Collects signatures from the `submitSignatures` transaction.
- Once a sufficient weight of signatures is gathered, submits finalization data to the Relay contract.
- Prioritizes finalization during the grace period to maximize rewards.

**Finalization Strategy**:

- Finalizes within the grace period if eligible.
- Competes for first finalization if the grace period has expired.

## Data Encoding and Payloads

Data for `submitSignatures` is structured as follows:

**Version 0**:

- `type` (1 byte): Message type (0 for ECDSA).
- `message` (38 bytes):
  - `protocolId` (1 byte)
  - `votingRoundId` (4 bytes)
  - `randomQualityScore` (1 byte)
  - `merkleRoot` (32 bytes)
- `signature` (65 bytes): ECDSA signature components (`v`, `r`, `s`).
- `unsignedMessage` (optional): Additional data (e.g., revealed random number).

**Version 1**: Similar structure with adjusted payload format.

## Data Availability and Merkle Trees

Each sub-protocol assembles Merkle trees using off-chain data:

- Data is obtained via the `GET /data/:votingRoundID` endpoint.
- The API returns:
  ```json
  {
      ""status"": ""OK"",
      ""data"": [{""abiName"": ""StructName"", ""data"": {...}}]
  }
  ```
- ABI definitions are accessible via `GET /data-abis`.

## Storage and Calculation Model

**Data Sources**:

- Events emitted by smart contracts.
- Calldata from specific contract calls.
- Immutable contract values, indexed by time.

The **Flare blockchain indexer** enables querying by time intervals and event types. Voters use the indexer to fetch data and perform calculations, which are then encoded into Merkle roots.

**Benefits**:

- Supports complex calculations beyond Solidity‚Äôs capabilities.
- Reduces storage costs by storing only Merkle roots on-chain.

## Result Availability and APIs

Voters assemble Merkle roots for voting and can provide services to access confirmed data. This data can be exposed via APIs, allowing users to obtain calculation results with full Merkle proofs for on-chain verification.

## Transaction Prioritization

The **Submission Smart Contract** prioritizes key transactions (`submit1`, `submit2`, `signatureDeposit`) to subsidize gas costs. Multiple sign transactions are allowed, but only one subsidized submission is permitted per voting round.",2025-03-08 01:27:14
IVoterRegistry.md,"title: IVoterRegistry
sidebar_position: 6
description: Manages the registration of voters for upcoming reward epochs.","Manages the registration of voters for upcoming reward epochs.

Sourced from `IVoterRegistry.sol` on [GitHub](https://github.com/flare-foundation/flare-smart-contracts-v2/blob/main/contracts/userInterfaces/IVoterRegistry.sol).

## Functions

### chilledUntilRewardEpochId

In case of providing bad votes (e.g. ftso collusion), the beneficiary can be chilled for a few reward epochs.
If beneficiary is chilled, the vote power assigned to it is zero.

```solidity
function chilledUntilRewardEpochId(
    bytes20 _beneficiary
) external view returns (
    uint256 _rewardEpochId
);
```

#### Parameters

- `_beneficiary`: The beneficiary (c-chain address or node id).

#### Returns

- `_rewardEpochId`: The reward epoch id until which the voter is chilled.

### getNumberOfRegisteredVoters

Returns the number of registered voters for a given reward epoch.
Size can be zero if the reward epoch is not supported (before initial reward epoch or future reward epoch).
Size for the next reward epoch can still change until the signing policy snapshot is created.

```solidity
function getNumberOfRegisteredVoters(
    uint256 _rewardEpochId
) external view returns (
    uint256
);
```

#### Parameters

- `_rewardEpochId`: The reward epoch id.

### getRegisteredVoters

Returns the list of registered voters for a given reward epoch.
List can be empty if the reward epoch is not supported (before initial reward epoch or future reward epoch).
List for the next reward epoch can still change until the signing policy snapshot is created.

```solidity
function getRegisteredVoters(
    uint256 _rewardEpochId
) external view returns (
    address[]
);
```

#### Parameters

- `_rewardEpochId`: The reward epoch id.

### isVoterRegistered

Returns true if a voter was (is currently) registered in a given reward epoch.

```solidity
function isVoterRegistered(
    address _voter,
    uint256 _rewardEpochId
) external view returns (
    bool
);
```

#### Parameters

- `_voter`: The voter address.
- `_rewardEpochId`: The reward epoch id.

### maxVoters

Maximum number of voters in one reward epoch.

```solidity
function maxVoters(
) external view returns (
    uint256
);
```

### newSigningPolicyInitializationStartBlockNumber

Returns the block number of the start of the new signing policy initialisation for a given reward epoch.
It is a snapshot block of the voters' addresses (it is zero if the reward epoch is not supported).

```solidity
function newSigningPolicyInitializationStartBlockNumber(
    uint256 _rewardEpochId
) external view returns (
    uint256
);
```

#### Parameters

- `_rewardEpochId`: The reward epoch id.

### publicKeyRequired

Indicates if the voter must have the public key set when registering.

```solidity
function publicKeyRequired(
) external view returns (
    bool
);
```

### registerVoter

Registers a voter if the weight is high enough.

```solidity
function registerVoter(
    address _voter,
    struct IVoterRegistry.Signature _signature
) external;
```

#### Parameters

- `_voter`: The voter address.
- `_signature`: The signature.

## Events

### BeneficiaryChilled

Event emitted when a beneficiary (c-chain address or node id) is chilled.

```solidity
event BeneficiaryChilled(
    bytes20 beneficiary,
    uint256 untilRewardEpochId
)
```

### VoterRegistered

Event emitted when a voter is registered.

```solidity
event VoterRegistered(
    address voter,
    uint24 rewardEpochId,
    address signingPolicyAddress,
    address submitAddress,
    address submitSignaturesAddress,
    bytes32 publicKeyPart1,
    bytes32 publicKeyPart2,
    uint256 registrationWeight
)
```

### VoterRemoved

Event emitted when a voter is removed.

```solidity
event VoterRemoved(
    address voter,
    uint256 rewardEpochId
)
```

## Structures

### Signature

Signature data.

```solidity
struct Signature {
  uint8 v;
  bytes32 r;
  bytes32 s;
}
```",2025-03-08 01:27:14
IFlareSystemsCalculator.md,"title: IFlareSystemsCalculator
sidebar_position: 7
description: Performs calculations for weights and burn factors used by other contracts.","Performs calculations for weights and burn factors used by other contracts.

Sourced from `IFlareSystemsCalculator.sol` on [GitHub](https://github.com/flare-foundation/flare-smart-contracts-v2/blob/main/contracts/userInterfaces/IFlareSystemsCalculator.sol).

## Functions

### signingPolicySignNoRewardsDurationBlocks

Number of blocks (in addition to non-punishable blocks) after which all rewards are burned.

```solidity
function signingPolicySignNoRewardsDurationBlocks(
) external view returns (
    uint64
);
```

### signingPolicySignNonPunishableDurationBlocks

Number of non-punishable blocks to sign new signing policy.

```solidity
function signingPolicySignNonPunishableDurationBlocks(
) external view returns (
    uint64
);
```

### signingPolicySignNonPunishableDurationSeconds

Non-punishable time to sign new signing policy.

```solidity
function signingPolicySignNonPunishableDurationSeconds(
) external view returns (
    uint64
);
```

### wNatCapPPM

WNat cap used in signing policy weight.

```solidity
function wNatCapPPM(
) external view returns (
    uint24
);
```

## Events

### VoterRegistrationInfo

Event emitted when the registration weight of a voter is calculated.

```solidity
event VoterRegistrationInfo(
    address voter,
    uint24 rewardEpochId,
    address delegationAddress,
    uint16 delegationFeeBIPS,
    uint256 wNatWeight,
    uint256 wNatCappedWeight,
    bytes20[] nodeIds,
    uint256[] nodeWeights
)
```",2025-03-08 01:27:14
ISubmission.md,"title: ISubmission
sidebar_position: 2
description: Manages prioritized and subsidized submissions for protocols.","Manages prioritized and subsidized submissions for protocols.

Sourced from `ISubmission.sol` on [GitHub](https://github.com/flare-foundation/flare-smart-contracts-v2/blob/main/contracts/userInterfaces/ISubmission.sol).

## Functions

### getCurrentRandom

Returns current random number. Method reverts if random number was not generated securely.

```solidity
function getCurrentRandom(
) external view returns (
    uint256 _randomNumber
);
```

#### Returns

- `_randomNumber`: Current random number.

### getCurrentRandomWithQuality

Returns current random number and a flag indicating if it was securely generated.
It is up to the caller to decide whether to use the returned random number or not.

```solidity
function getCurrentRandomWithQuality(
) external view returns (
    uint256 _randomNumber,
    bool _isSecureRandom
);
```

#### Returns

- `_randomNumber`: Current random number.
- `_isSecureRandom`: Indicates if current random number is secure.

### getCurrentRandomWithQualityAndTimestamp

Returns current random number, a flag indicating if it was securely generated and its timestamp.
It is up to the caller to decide whether to use the returned random number or not.

```solidity
function getCurrentRandomWithQualityAndTimestamp(
) external view returns (
    uint256 _randomNumber,
    bool _isSecureRandom,
    uint256 _randomTimestamp
);
```

#### Returns

- `_randomNumber`: Current random number.
- `_isSecureRandom`: Indicates if current random number is secure.
- `_randomTimestamp`: Random timestamp.

### submit1

Submit1 method. Used in multiple protocols (i.e. as FTSO commit method).

```solidity
function submit1(
) external returns (
    bool
);
```

### submit2

Submit2 method. Used in multiple protocols (i.e. as FTSO reveal method).

```solidity
function submit2(
) external returns (
    bool
);
```

### submit3

Submit3 method. Future usage.

```solidity
function submit3(
) external returns (
    bool
);
```

### submitAndPass

SubmitAndPass method. Future usage.

```solidity
function submitAndPass(
    bytes _data
) external returns (
    bool
);
```

#### Parameters

- `_data`: The data to pass to the submitAndPassContract.

### submitSignatures

SubmitSignatures method. Used in multiple protocols (i.e. as FTSO submit signature method).

```solidity
function submitSignatures(
) external returns (
    bool
);
```

## Events

### NewVotingRoundInitiated

Event emitted when a new voting round is initiated.

```solidity
event NewVotingRoundInitiated(
)
```",2025-03-08 01:27:14
IEntityManager.md,"title: IEntityManager
sidebar_position: 1
description: Manages voter entities, including addresses and node IDs.","Manages voter entities, including addresses and node IDs.

Sourced from `IEntityManager.sol` on [GitHub](https://github.com/flare-foundation/flare-smart-contracts-v2/blob/main/contracts/userInterfaces/IEntityManager.sol).

## Functions

### confirmDelegationAddressRegistration

Confirms a delegation address registration (called by the delegation address).

```solidity
function confirmDelegationAddressRegistration(
    address _voter
) external;
```

#### Parameters

- `_voter`: Voter address.

### confirmSigningPolicyAddressRegistration

Confirms a signing policy address registration (called by the signing policy address).

```solidity
function confirmSigningPolicyAddressRegistration(
    address _voter
) external;
```

#### Parameters

- `_voter`: Voter address.

### confirmSubmitAddressRegistration

Confirms a submit address registration (called by the submit address).

```solidity
function confirmSubmitAddressRegistration(
    address _voter
) external;
```

#### Parameters

- `_voter`: Voter address.

### confirmSubmitSignaturesAddressRegistration

Confirms a submit signatures address registration (called by the submit signatures address).

```solidity
function confirmSubmitSignaturesAddressRegistration(
    address _voter
) external;
```

#### Parameters

- `_voter`: Voter address.

### getDelegationAddressOf

Gets the delegation address of a voter at the current block number.

```solidity
function getDelegationAddressOf(
    address _voter
) external view returns (
    address
);
```

#### Parameters

- `_voter`: Voter address.

#### Returns

- ``: Public key.

### getDelegationAddressOfAt

Gets the delegation address of a voter at a specific block number.

```solidity
function getDelegationAddressOfAt(
    address _voter,
    uint256 _blockNumber
) external view returns (
    address
);
```

#### Parameters

- `_voter`: Voter address.
- `_blockNumber`: Block number.

#### Returns

- ``: Public key.

### getNodeIdsOf

Gets the node ids of a voter at the current block number.

```solidity
function getNodeIdsOf(
    address _voter
) external view returns (
    bytes20[]
);
```

#### Parameters

- `_voter`: Voter address.

#### Returns

- ``: Node ids.

### getNodeIdsOfAt

Gets the node ids of a voter at a specific block number.

```solidity
function getNodeIdsOfAt(
    address _voter,
    uint256 _blockNumber
) external view returns (
    bytes20[]
);
```

#### Parameters

- `_voter`: Voter address.
- `_blockNumber`: Block number.

#### Returns

- ``: Node ids.

### getPublicKeyOf

Gets the public key of a voter at the current block number.

```solidity
function getPublicKeyOf(
    address _voter
) external view returns (
    bytes32,
    bytes32
);
```

#### Parameters

- `_voter`: Voter address.

#### Returns

- ``: Public key.
- ``:

### getPublicKeyOfAt

Gets the public key of a voter at a specific block number.

```solidity
function getPublicKeyOfAt(
    address _voter,
    uint256 _blockNumber
) external view returns (
    bytes32,
    bytes32
);
```

#### Parameters

- `_voter`: Voter address.
- `_blockNumber`: Block number.

#### Returns

- ``: Public key.
- ``:

### getVoterAddresses

Gets voter's addresses at the current block number.

```solidity
function getVoterAddresses(
    address _voter
) external view returns (
    struct IEntityManager.VoterAddresses _addresses
);
```

#### Parameters

- `_voter`: Voter address.

#### Returns

- `_addresses`: Voter addresses.

### getVoterAddressesAt

Gets voter's addresses at a specific block number.

```solidity
function getVoterAddressesAt(
    address _voter,
    uint256 _blockNumber
) external view returns (
    struct IEntityManager.VoterAddresses _addresses
);
```

#### Parameters

- `_voter`: Voter address.
- `_blockNumber`: Block number.

#### Returns

- `_addresses`: Voter addresses.

### getVoterForDelegationAddress

Gets voter's address for a delegation address at a specific block number.

```solidity
function getVoterForDelegationAddress(
    address _delegationAddress,
    uint256 _blockNumber
) external view returns (
    address _voter
);
```

#### Parameters

- `_delegationAddress`: Delegation address.
- `_blockNumber`: Block number.

#### Returns

- `_voter`: Voter address.

### getVoterForNodeId

Gets voter's address for a node id at a specific block number.

```solidity
function getVoterForNodeId(
    bytes20 _nodeId,
    uint256 _blockNumber
) external view returns (
    address _voter
);
```

#### Parameters

- `_nodeId`: Node id.
- `_blockNumber`: Block number.

#### Returns

- `_voter`: Voter address.

### getVoterForPublicKey

Gets voter's address for a public key at a specific block number.

```solidity
function getVoterForPublicKey(
    bytes32 _part1,
    bytes32 _part2,
    uint256 _blockNumber
) external view returns (
    address _voter
);
```

#### Parameters

- `_part1`: First part of the public key.
- `_part2`: Second part of the public key.
- `_blockNumber`: Block number.

#### Returns

- `_voter`: Voter address.

### getVoterForSigningPolicyAddress

Gets voter's address for a signing policy address at a specific block number.

```solidity
function getVoterForSigningPolicyAddress(
    address _signingPolicyAddress,
    uint256 _blockNumber
) external view returns (
    address _voter
);
```

#### Parameters

- `_signingPolicyAddress`: Signing policy address.
- `_blockNumber`: Block number.

#### Returns

- `_voter`: Voter address.

### getVoterForSubmitAddress

Gets voter's address for a submit address at a specific block number.

```solidity
function getVoterForSubmitAddress(
    address _submitAddress,
    uint256 _blockNumber
) external view returns (
    address _voter
);
```

#### Parameters

- `_submitAddress`: Submit address.
- `_blockNumber`: Block number.

#### Returns

- `_voter`: Voter address.

### getVoterForSubmitSignaturesAddress

Gets voter's address for a submit signatures address at a specific block number.

```solidity
function getVoterForSubmitSignaturesAddress(
    address _submitSignaturesAddress,
    uint256 _blockNumber
) external view returns (
    address _voter
);
```

#### Parameters

- `_submitSignaturesAddress`: Submit signatures address.
- `_blockNumber`: Block number.

#### Returns

- `_voter`: Voter address.

### proposeDelegationAddress

Proposes a delegation address (called by the voter).

```solidity
function proposeDelegationAddress(
    address _delegationAddress
) external;
```

#### Parameters

- `_delegationAddress`: Delegation address.

### proposeSigningPolicyAddress

Proposes a signing policy address (called by the voter).

```solidity
function proposeSigningPolicyAddress(
    address _signingPolicyAddress
) external;
```

#### Parameters

- `_signingPolicyAddress`: Signing policy address.

### proposeSubmitAddress

Proposes a submit address (called by the voter).

```solidity
function proposeSubmitAddress(
    address _submitAddress
) external;
```

#### Parameters

- `_submitAddress`: Submit address.

### proposeSubmitSignaturesAddress

Proposes a submit signatures address (called by the voter).

```solidity
function proposeSubmitSignaturesAddress(
    address _submitSignaturesAddress
) external;
```

#### Parameters

- `_submitSignaturesAddress`: Submit signatures address.

### registerNodeId

Registers a node id.

```solidity
function registerNodeId(
    bytes20 _nodeId,
    bytes _certificateRaw,
    bytes _signature
) external;
```

#### Parameters

- `_nodeId`: Node id.
- `_certificateRaw`: Certificate in raw format.
- `_signature`: Signature.

### registerPublicKey

Registers a public key.

```solidity
function registerPublicKey(
    bytes32 _part1,
    bytes32 _part2,
    bytes _verificationData
) external;
```

#### Parameters

- `_part1`: First part of the public key.
- `_part2`: Second part of the public key.
- `_verificationData`: Additional data used to verify the public key.

### unregisterNodeId

Unregisters a node id.

```solidity
function unregisterNodeId(
    bytes20 _nodeId
) external;
```

#### Parameters

- `_nodeId`: Node id.

### unregisterPublicKey

Unregisters a public key.

```solidity
function unregisterPublicKey(
) external;
```

## Events

### DelegationAddressProposed

Event emitted when a delegation address is proposed.

```solidity
event DelegationAddressProposed(
    address voter,
    address delegationAddress
)
```

### DelegationAddressRegistrationConfirmed

Event emitted when a delegation address registration is confirmed.

```solidity
event DelegationAddressRegistrationConfirmed(
    address voter,
    address delegationAddress
)
```

### MaxNodeIdsPerEntitySet

Event emitted when the maximum number of node ids per entity is set.

```solidity
event MaxNodeIdsPerEntitySet(
    uint256 maxNodeIdsPerEntity
)
```

### NodeIdRegistered

Event emitted when a node id is registered.

```solidity
event NodeIdRegistered(
    address voter,
    bytes20 nodeId
)
```

### NodeIdUnregistered

Event emitted when a node id is unregistered.

```solidity
event NodeIdUnregistered(
    address voter,
    bytes20 nodeId
)
```

### PublicKeyRegistered

Event emitted when a public key is registered.

```solidity
event PublicKeyRegistered(
    address voter,
    bytes32 part1,
    bytes32 part2
)
```

### PublicKeyUnregistered

Event emitted when a public key is unregistered.

```solidity
event PublicKeyUnregistered(
    address voter,
    bytes32 part1,
    bytes32 part2
)
```

### SigningPolicyAddressProposed

Event emitted when a signing policy address is proposed.

```solidity
event SigningPolicyAddressProposed(
    address voter,
    address signingPolicyAddress
)
```

### SigningPolicyAddressRegistrationConfirmed

Event emitted when a signing policy address registration is confirmed.

```solidity
event SigningPolicyAddressRegistrationConfirmed(
    address voter,
    address signingPolicyAddress
)
```

### SubmitAddressProposed

Event emitted when a submit address is proposed.

```solidity
event SubmitAddressProposed(
    address voter,
    address submitAddress
)
```

### SubmitAddressRegistrationConfirmed

Event emitted when a submit address registration is confirmed.

```solidity
event SubmitAddressRegistrationConfirmed(
    address voter,
    address submitAddress
)
```

### SubmitSignaturesAddressProposed

Event emitted when a submit signatures address is proposed.

```solidity
event SubmitSignaturesAddressProposed(
    address voter,
    address submitSignaturesAddress
)
```

### SubmitSignaturesAddressRegistrationConfirmed

Event emitted when a submit signatures address registration is confirmed.

```solidity
event SubmitSignaturesAddressRegistrationConfirmed(
    address voter,
    address submitSignaturesAddress
)
```

## Structures

### VoterAddresses

Voter addresses.

```solidity
struct VoterAddresses {
  address submitAddress;
  address submitSignaturesAddress;
  address signingPolicyAddress;
}
```",2025-03-08 01:27:14
IWNatDelegationFee.md,"title: IWNatDelegationFee
description: Manages the delegation fees set by voters for WFLR delegations.
sidebar_position: 8","Manages the delegation fees set by voters for WFLR delegations.

Sourced from `IWNatDelegationFee.sol` on [GitHub](https://github.com/flare-foundation/flare-smart-contracts-v2/blob/main/contracts/userInterfaces/IWNatDelegationFee.sol).

## Functions

### defaultFeePercentageBIPS

The default fee percentage value.

```solidity
function defaultFeePercentageBIPS(
) external view returns (
    uint16
);
```

### feePercentageUpdateOffset

The offset in reward epochs for the fee percentage value to become effective.

```solidity
function feePercentageUpdateOffset(
) external view returns (
    uint24
);
```

### getVoterCurrentFeePercentage

Returns the current fee percentage of `_voter`.

```solidity
function getVoterCurrentFeePercentage(
    address _voter
) external view returns (
    uint16
);
```

#### Parameters

- `_voter`: Voter address.

### getVoterFeePercentage

Returns the fee percentage of `_voter` for given reward epoch id.

```solidity
function getVoterFeePercentage(
    address _voter,
    uint256 _rewardEpochId
) external view returns (
    uint16
);
```

#### Parameters

- `_voter`: Voter address.
- `_rewardEpochId`: Reward epoch id. **NOTE:** fee percentage might still change for the `current + feePercentageUpdateOffset` reward epoch id

### getVoterScheduledFeePercentageChanges

Returns the scheduled fee percentage changes of `_voter`.

```solidity
function getVoterScheduledFeePercentageChanges(
    address _voter
) external view returns (
    uint256[] _feePercentageBIPS,
    uint256[] _validFromEpochId,
    bool[] _fixed
);
```

#### Parameters

- `_voter`: Voter address.

#### Returns

- `_feePercentageBIPS`: Positional array of fee percentages in BIPS.
- `_validFromEpochId`: Positional array of reward epoch ids the fee settings are effective from.
- `_fixed`: Positional array of boolean values indicating if settings are subjected to change.

### setVoterFeePercentage

Allows voter to set (or update last) fee percentage.

```solidity
function setVoterFeePercentage(
    uint16 _feePercentageBIPS
) external returns (
    uint256
);
```

#### Parameters

- `_feePercentageBIPS`: Number representing fee percentage in BIPS.

#### Returns

- ``: Returns the reward epoch number when the value becomes effective.

## Events

### FeePercentageChanged

Event emitted when a voter fee percentage value is changed.

```solidity
event FeePercentageChanged(
    address voter,
    uint16 value,
    uint24 validFromEpochId
)
```",2025-03-08 01:27:14
IRelay.md,"title: IRelay
sidebar_position: 4
description: Stores confirmed Merkle roots and signing policies.","Stores confirmed Merkle roots and signing policies.

Sourced from `IRelay.sol` on [GitHub](https://github.com/flare-foundation/flare-smart-contracts-v2/blob/main/contracts/userInterfaces/IRelay.sol).

## Functions

### feeCollectionAddress

Returns fee collection address.

```solidity
function feeCollectionAddress(
) external view returns (
    address payable
);
```

### getRandomNumber

Returns the current random number, its timestamp and the flag indicating if it is secure.

```solidity
function getRandomNumber(
) external view returns (
    uint256 _randomNumber,
    bool _isSecureRandom,
    uint256 _randomTimestamp
);
```

#### Returns

- `_randomNumber`: The current random number.
- `_isSecureRandom`: The flag indicating if the random number is secure.
- `_randomTimestamp`: The timestamp of the random number.

### getRandomNumberHistorical

Returns the historical random number for a given \_votingRoundId,
its timestamp and the flag indicating if it is secure.
If no finalization in the \_votingRoundId, the function reverts.

```solidity
function getRandomNumberHistorical(
    uint256 _votingRoundId
) external view returns (
    uint256 _randomNumber,
    bool _isSecureRandom,
    uint256 _randomTimestamp
);
```

#### Parameters

- `_votingRoundId`: The voting round id.

#### Returns

- `_randomNumber`: The current random number.
- `_isSecureRandom`: The flag indicating if the random number is secure.
- `_randomTimestamp`: The timestamp of the random number.

### getVotingRoundId

Returns the voting round id for given timestamp.

```solidity
function getVotingRoundId(
    uint256 _timestamp
) external view returns (
    uint256 _votingRoundId
);
```

#### Parameters

- `_timestamp`: The timestamp.

#### Returns

- `_votingRoundId`: The voting round id.

### governanceFeeSetup

Checks the relay message for sufficient weight of signatures of the hash of the \_config data.
If the check is successful, the relay contract is configured with the new \_config data, which
in particular means that fee configurations are updated.
Otherwise the function reverts.

```solidity
function governanceFeeSetup(
    bytes _relayMessage,
    struct IRelay.RelayGovernanceConfig _config
) external;
```

#### Parameters

- `_relayMessage`: The relay message.
- `_config`: The new relay configuration.

### isFinalized

Returns true if there is finalization for a given protocol id and voting round id.

```solidity
function isFinalized(
    uint256 _protocolId,
    uint256 _votingRoundId
) external view returns (
    bool
);
```

#### Parameters

- `_protocolId`: The protocol id.
- `_votingRoundId`: The voting round id.

### lastInitializedRewardEpochData

Returns last initialized reward epoch data.

```solidity
function lastInitializedRewardEpochData(
) external view returns (
    uint32 _lastInitializedRewardEpoch,
    uint32 _startingVotingRoundIdForLastInitializedRewardEpoch
);
```

#### Returns

- `_lastInitializedRewardEpoch`: Last initialized reward epoch.
- `_startingVotingRoundIdForLastInitializedRewardEpoch`: Starting voting round id for it.

### merkleRoots

Returns the Merkle root for given protocol id and voting round id.
The function is reverted if signingPolicySetter is set, hence on all
deployments where the contract is used as a pure relay.

```solidity
function merkleRoots(
    uint256 _protocolId,
    uint256 _votingRoundId
) external view returns (
    bytes32 _merkleRoot
);
```

#### Parameters

- `_protocolId`: The protocol id.
- `_votingRoundId`: The voting round id.

#### Returns

- `_merkleRoot`: The Merkle root.

### protocolFeeInWei

Returns fee in wei for one verification of a given protocol id.

```solidity
function protocolFeeInWei(
    uint256 _protocolId
) external view returns (
    uint256
);
```

#### Parameters

- `_protocolId`: The protocol id.

### relay

Finalization function for new signing policies and protocol messages.
It can be used as finalization contract on Flare chain or as relay contract on other EVM chain.
Can be called in two modes. It expects calldata that is parsed in a custom manner.
Hence the transaction calls should assemble relevant calldata in the 'data' field.
Depending on the data provided, the contract operations in essentially two modes:
(1) Relaying signing policy. The structure of the calldata is:
function signature (4 bytes) + active signing policy + 0 (1 byte) + new signing policy,
total of exactly 4423 bytes.
(2) Relaying signed message. The structure of the calldata is:
function signature (4 bytes) + signing policy + signed message (38 bytes) + ECDSA signatures with indices (67 bytes each)
This case splits into two subcases: - protocolMessageId = 1: Message id must be of the form (protocolMessageId, 0, 0, merkleRoot).
The validity of the signatures of sufficient weight is checked and if
successful, the merkleRoot from the message is returned (32 bytes) and the
reward epoch id of the signing policy as well (additional 3 bytes) - protocolMessageId > 1: The validity of the signatures of sufficient weight is checked and if
it is valid, the merkleRoot is published for protocolId and votingRoundId.
Reverts if relaying is not successful.

```solidity
function relay(
) external returns (
    bytes
);
```

### startingVotingRoundIds

Returns the start voting round id for given reward epoch id.

```solidity
function startingVotingRoundIds(
    uint256 _rewardEpochId
) external view returns (
    uint256 _startingVotingRoundId
);
```

#### Parameters

- `_rewardEpochId`: The reward epoch id.

#### Returns

- `_startingVotingRoundId`: The start voting round id.

### toSigningPolicyHash

Returns the signing policy hash for given reward epoch id.
The function is reverted if signingPolicySetter is set, hence on all
deployments where the contract is used as a pure relay.

```solidity
function toSigningPolicyHash(
    uint256 _rewardEpochId
) external view returns (
    bytes32 _signingPolicyHash
);
```

#### Parameters

- `_rewardEpochId`: The reward epoch id.

#### Returns

- `_signingPolicyHash`: The signing policy hash.

### verify

Verifies the leaf (or intermediate node) with the Merkle proof against the Merkle root
for given protocol id and voting round id.
A fee may need to be paid. It is protocol specific.
**NOTE:** Overpayment is not refunded.

```solidity
function verify(
    uint256 _protocolId,
    uint256 _votingRoundId,
    bytes32 _leaf,
    bytes32[] _proof
) external payable returns (
    bool
);
```

#### Parameters

- `_protocolId`: The protocol id.
- `_votingRoundId`: The voting round id.
- `_leaf`: The leaf (or intermediate node) to verify.
- `_proof`: The Merkle proof.

#### Returns

- ``: True if the verification is successful.

### verifyCustomSignature

Checks the relay message for sufficient weight of signatures for the \_messageHash
signed for protocol message Merkle root of the form (1, 0, 0, \_messageHash).
If the check is successful, reward epoch id of the signing policy is returned.
Otherwise the function reverts.

```solidity
function verifyCustomSignature(
    bytes _relayMessage,
    bytes32 _messageHash
) external returns (
    uint256 _rewardEpochId
);
```

#### Parameters

- `_relayMessage`: The relay message.
- `_messageHash`: The hash of the message.

#### Returns

- `_rewardEpochId`: The reward epoch id of the signing policy.

## Events

### ProtocolMessageRelayed

```solidity
event ProtocolMessageRelayed(
    uint8 protocolId,
    uint32 votingRoundId,
    bool isSecureRandom,
    bytes32 merkleRoot
)
```

### SigningPolicyInitialized

```solidity
event SigningPolicyInitialized(
    uint24 rewardEpochId,
    uint32 startVotingRoundId,
    uint16 threshold,
    uint256 seed,
    address[] voters,
    uint16[] weights,
    bytes signingPolicyBytes,
    uint64 timestamp
)
```

### SigningPolicyRelayed

```solidity
event SigningPolicyRelayed(
    uint256 rewardEpochId
)
```

## Structures

### FeeConfig

```solidity
struct FeeConfig {
  uint8 protocolId;
  uint256 feeInWei;
}
```

### RelayGovernanceConfig

```solidity
struct RelayGovernanceConfig {
  bytes32 descriptionHash;
  uint256 chainId;
  struct IRelay.FeeConfig[] newFeeConfigs;
}
```

### RelayInitialConfig

```solidity
struct RelayInitialConfig {
  uint32 initialRewardEpochId;
  uint32 startingVotingRoundIdForInitialRewardEpochId;
  bytes32 initialSigningPolicyHash;
  uint8 randomNumberProtocolId;
  uint32 firstVotingRoundStartTs;
  uint8 votingEpochDurationSeconds;
  uint32 firstRewardEpochStartVotingRoundId;
  uint16 rewardEpochDurationInVotingEpochs;
  uint16 thresholdIncreaseBIPS;
  uint32 messageFinalizationWindowInRewardEpochs;
  address payable feeCollectionAddress;
  struct IRelay.FeeConfig[] feeConfigs;
}
```",2025-03-08 01:27:14
IRewardManager.md,"title: IRewardManager
sidebar_position: 5
description: Facilitates the claiming and distribution of rewards to voters, delegators, and stakers.","Facilitates the claiming and distribution of rewards to voters, delegators, and stakers.

Sourced from `IRewardManager.sol` on [GitHub](https://github.com/flare-foundation/flare-smart-contracts-v2/blob/main/contracts/userInterfaces/IRewardManager.sol).

## Functions

### active

Indicates if the contract is active - claims are enabled.

```solidity
function active(
) external view returns (
    bool
);
```

### autoClaim

Claim rewards for `_rewardOwners` and their PDAs.
Rewards are deposited to the WNat (to reward owner or PDA if enabled).
It can be called by reward owner or its authorized executor.
Only claiming from weight based claims is supported.

```solidity
function autoClaim(
    address[] _rewardOwners,
    uint24 _rewardEpochId,
    struct RewardsV2Interface.RewardClaimWithProof[] _proofs
) external;
```

#### Parameters

- `_rewardOwners`: Array of reward owners.
- `_rewardEpochId`: Id of the reward epoch up to which the rewards are claimed.
- `_proofs`: Array of reward claims with merkle proofs.

### claim

Claim rewards for `_rewardOwner` and transfer them to `_recipient`.
It can be called by reward owner or its authorized executor.

```solidity
function claim(
    address _rewardOwner,
    address payable _recipient,
    uint24 _rewardEpochId,
    bool _wrap,
    struct RewardsV2Interface.RewardClaimWithProof[] _proofs
) external returns (
    uint256 _rewardAmountWei
);
```

#### Parameters

- `_rewardOwner`: Address of the reward owner.
- `_recipient`: Address of the reward recipient.
- `_rewardEpochId`: Id of the reward epoch up to which the rewards are claimed.
- `_wrap`: Indicates if the reward should be wrapped (deposited) to the WNat contract.
- `_proofs`: Array of reward claims with merkle proofs.

#### Returns

- `_rewardAmountWei`: Amount of rewarded native tokens (wei).

### cleanupBlockNumber

Get the current cleanup block number.

```solidity
function cleanupBlockNumber(
) external view returns (
    uint256
);
```

#### Returns

- ``: The currently set cleanup block number.

### firstClaimableRewardEpochId

The first reward epoch id that was claimable.

```solidity
function firstClaimableRewardEpochId(
) external view returns (
    uint24
);
```

### getCurrentRewardEpochId

Returns current reward epoch id.

```solidity
function getCurrentRewardEpochId(
) external view returns (
    uint24
);
```

### getInitialRewardEpochId

Returns initial reward epoch id.

```solidity
function getInitialRewardEpochId(
) external view returns (
    uint256
);
```

### getNextClaimableRewardEpochId

Returns the next claimable reward epoch for a reward owner.

```solidity
function getNextClaimableRewardEpochId(
    address _rewardOwner
) external view returns (
    uint256
);
```

#### Parameters

- `_rewardOwner`: Address of the reward owner to query.

### getRewardEpochIdToExpireNext

Returns the reward epoch id that will expire next once a new reward epoch starts.

```solidity
function getRewardEpochIdToExpireNext(
) external view returns (
    uint256
);
```

### getRewardEpochIdsWithClaimableRewards

Returns the start and the end of the reward epoch range for which the reward is claimable.

```solidity
function getRewardEpochIdsWithClaimableRewards(
) external view returns (
    uint24 _startEpochId,
    uint24 _endEpochId
);
```

#### Returns

- `_startEpochId`: The oldest epoch id that allows reward claiming.
- `_endEpochId`: The newest epoch id that allows reward claiming.

### getRewardEpochTotals

Returns reward epoch totals.

```solidity
function getRewardEpochTotals(
    uint24 _rewardEpochId
) external view returns (
    uint256 _totalRewardsWei,
    uint256 _totalInflationRewardsWei,
    uint256 _initialisedRewardsWei,
    uint256 _claimedRewardsWei,
    uint256 _burnedRewardsWei
);
```

#### Parameters

- `_rewardEpochId`: Reward epoch id.

#### Returns

- `_totalRewardsWei`: Total rewards (inflation + community) for the epoch (wei).
- `_totalInflationRewardsWei`: Total inflation rewards for the epoch (wei).
- `_initialisedRewardsWei`: Initialised rewards of all claim types for the epoch (wei).
- `_claimedRewardsWei`: Claimed rewards for the epoch (wei).
- `_burnedRewardsWei`: Burned rewards for the epoch (wei).

### getStateOfRewards

Returns the state of rewards for a given address for all unclaimed reward epochs with claimable rewards.

```solidity
function getStateOfRewards(
    address _rewardOwner
) external view returns (
    struct RewardsV2Interface.RewardState[][] _rewardStates
);
```

#### Parameters

- `_rewardOwner`: Address of the reward owner.

#### Returns

- `_rewardStates`: Array of reward states.

### getStateOfRewardsAt

Returns the state of rewards for a given address at a specific reward epoch.

```solidity
function getStateOfRewardsAt(
    address _rewardOwner,
    uint24 _rewardEpochId
) external view returns (
    struct RewardsV2Interface.RewardState[] _rewardStates
);
```

#### Parameters

- `_rewardOwner`: Address of the reward owner.
- `_rewardEpochId`: Reward epoch id.

#### Returns

- `_rewardStates`: Array of reward states.

### getTotals

Returns totals.

```solidity
function getTotals(
) external view returns (
    uint256 _totalRewardsWei,
    uint256 _totalInflationRewardsWei,
    uint256 _totalClaimedWei,
    uint256 _totalBurnedWei
);
```

#### Returns

- `_totalRewardsWei`: Total rewards (wei).
- `_totalInflationRewardsWei`: Total inflation rewards (wei).
- `_totalClaimedWei`: Total claimed rewards (wei).
- `_totalBurnedWei`: Total burned rewards (wei).

### getUnclaimedRewardState

Gets the unclaimed reward state for a beneficiary, reward epoch id and claim type.

```solidity
function getUnclaimedRewardState(
    address _beneficiary,
    uint24 _rewardEpochId,
    enum RewardsV2Interface.ClaimType _claimType
) external view returns (
    struct IRewardManager.UnclaimedRewardState _state
);
```

#### Parameters

- `_beneficiary`: Address of the beneficiary to query.
- `_rewardEpochId`: Id of the reward epoch to query.
- `_claimType`: Claim type to query.

#### Returns

- `_state`: Unclaimed reward state.

### initialiseWeightBasedClaims

Initialises weight based claims.

```solidity
function initialiseWeightBasedClaims(
    struct RewardsV2Interface.RewardClaimWithProof[] _proofs
) external;
```

#### Parameters

- `_proofs`: Array of reward claims with merkle proofs.

### noOfInitialisedWeightBasedClaims

Returns the number of weight based claims that have been initialised.

```solidity
function noOfInitialisedWeightBasedClaims(
    uint256 _rewardEpochId
) external view returns (
    uint256
);
```

#### Parameters

- `_rewardEpochId`: Reward epoch id.

## Events

### RewardClaimed

Emitted when rewards are claimed.

```solidity
event RewardClaimed(
    address beneficiary,
    address rewardOwner,
    address recipient,
    uint24 rewardEpochId,
    enum RewardsV2Interface.ClaimType claimType,
    uint120 amount
)
```

#### Parameters

- `beneficiary`: Address of the beneficiary (voter or node id) that accrued the reward.
- `rewardOwner`: Address that was eligible for the rewards.
- `recipient`: Address that received the reward.
- `rewardEpochId`: Id of the reward epoch where the reward was accrued.
- `claimType`: Claim type
- `amount`: Amount of rewarded native tokens (wei).

### RewardClaimsEnabled

Emitted when reward claims have been enabled.

```solidity
event RewardClaimsEnabled(
    uint256 rewardEpochId
)
```

#### Parameters

- `rewardEpochId`: First claimable reward epoch.

### RewardClaimsExpired

Unclaimed rewards have expired and are now inaccessible.

`getUnclaimedRewardState()` can be used to retrieve more information.

```solidity
event RewardClaimsExpired(
    uint256 rewardEpochId
)
```

#### Parameters

- `rewardEpochId`: Id of the reward epoch that has just expired.

## Structures

### RewardClaim

Struct used in Merkle tree for storing reward claims.

```solidity
struct RewardClaim {
  uint24 rewardEpochId;
  bytes20 beneficiary;
  uint120 amount;
  enum RewardsV2Interface.ClaimType claimType;
}
```

### RewardClaimWithProof

Struct used for claiming rewards with Merkle proof.

```solidity
struct RewardClaimWithProof {
  bytes32[] merkleProof;
  struct RewardsV2Interface.RewardClaim body;
}
```

### RewardState

Struct used for returning state of rewards.

```solidity
struct RewardState {
  uint24 rewardEpochId;
  bytes20 beneficiary;
  uint120 amount;
  enum RewardsV2Interface.ClaimType claimType;
  bool initialised;
}
```

### UnclaimedRewardState

Struct used for storing unclaimed reward data.

```solidity
struct UnclaimedRewardState {
  bool initialised;
  uint120 amount;
  uint128 weight;
}
```",2025-03-08 01:27:14
IFlareSystemsManager.md,"title: IFlareSystemsManager
sidebar_position: 3
description: Manages system protocols like Signing Policy Definition, Uptime Voting, and Reward Voting.","Manages system protocols like the Signing Policy Definition, Uptime Voting, and Reward Voting.

Sourced from `IFlareSystemsManager.sol` on [GitHub](https://github.com/flare-foundation/flare-smart-contracts-v2/blob/main/contracts/userInterfaces/IFlareSystemsManager.sol).

## Functions

### firstRewardEpochStartTs

Timestamp when the first reward epoch started, in seconds since UNIX epoch.

```solidity
function firstRewardEpochStartTs(
) external view returns (
    uint64
);
```

### firstVotingRoundStartTs

Timestamp when the first voting epoch started, in seconds since UNIX epoch.

```solidity
function firstVotingRoundStartTs(
) external view returns (
    uint64
);
```

### getCurrentRewardEpoch

Returns the current reward epoch id (backwards compatibility).

```solidity
function getCurrentRewardEpoch(
) external view returns (
    uint256
);
```

### getCurrentRewardEpochId

Returns the current reward epoch id.

```solidity
function getCurrentRewardEpochId(
) external view returns (
    uint24
);
```

### getCurrentVotingEpochId

Returns the current voting epoch id.

```solidity
function getCurrentVotingEpochId(
) external view returns (
    uint32
);
```

### getSeed

Returns the seed for given reward epoch id.

```solidity
function getSeed(
    uint256 _rewardEpochId
) external view returns (
    uint256
);
```

### getStartVotingRoundId

Returns the start voting round id for given reward epoch id.

```solidity
function getStartVotingRoundId(
    uint256 _rewardEpochId
) external view returns (
    uint32
);
```

### getThreshold

Returns the threshold for given reward epoch id.

```solidity
function getThreshold(
    uint256 _rewardEpochId
) external view returns (
    uint16
);
```

### getVotePowerBlock

Returns the vote power block for given reward epoch id.

```solidity
function getVotePowerBlock(
    uint256 _rewardEpochId
) external view returns (
    uint64 _votePowerBlock
);
```

### getVoterRegistrationData

Returns voter rgistration data for given reward epoch id.

```solidity
function getVoterRegistrationData(
    uint256 _rewardEpochId
) external view returns (
    uint256 _votePowerBlock,
    bool _enabled
);
```

#### Parameters

- `_rewardEpochId`: Reward epoch id.

#### Returns

- `_votePowerBlock`: Vote power block.
- `_enabled`: Indicates if voter registration is enabled.

### isVoterRegistrationEnabled

Indicates if voter registration is currently enabled.

```solidity
function isVoterRegistrationEnabled(
) external view returns (
    bool
);
```

### rewardEpochDurationSeconds

Duration of reward epoch, in seconds.

```solidity
function rewardEpochDurationSeconds(
) external view returns (
    uint64
);
```

### signNewSigningPolicy

Method for collecting signatures for the new signing policy.

```solidity
function signNewSigningPolicy(
    uint24 _rewardEpochId,
    bytes32 _newSigningPolicyHash,
    struct IFlareSystemsManager.Signature _signature
) external;
```

#### Parameters

- `_rewardEpochId`: Reward epoch id of the new signing policy.
- `_newSigningPolicyHash`: New signing policy hash.
- `_signature`: Signature.

### signRewards

Method for collecting signatures for the rewards.

```solidity
function signRewards(
    uint24 _rewardEpochId,
    struct IFlareSystemsManager.NumberOfWeightBasedClaims[] _noOfWeightBasedClaims,
    bytes32 _rewardsHash,
    struct IFlareSystemsManager.Signature _signature
) external;
```

#### Parameters

- `_rewardEpochId`: Reward epoch id of the rewards.
- `_noOfWeightBasedClaims`: Number of weight based claims list.
- `_rewardsHash`: Rewards hash.
- `_signature`: Signature.

### signUptimeVote

Method for collecting signatures for the uptime vote.

```solidity
function signUptimeVote(
    uint24 _rewardEpochId,
    bytes32 _uptimeVoteHash,
    struct IFlareSystemsManager.Signature _signature
) external;
```

#### Parameters

- `_rewardEpochId`: Reward epoch id of the uptime vote.
- `_uptimeVoteHash`: Uptime vote hash.
- `_signature`: Signature.

### submitUptimeVote

Method for submitting node ids with high enough uptime.

```solidity
function submitUptimeVote(
    uint24 _rewardEpochId,
    bytes20[] _nodeIds,
    struct IFlareSystemsManager.Signature _signature
) external;
```

#### Parameters

- `_rewardEpochId`: Reward epoch id of the uptime vote.
- `_nodeIds`: Node ids with high enough uptime.
- `_signature`: Signature.

### votingEpochDurationSeconds

Duration of voting epoch, in seconds.

```solidity
function votingEpochDurationSeconds(
) external view returns (
    uint64
);
```

## Events

### RandomAcquisitionStarted

Event emitted when random acquisition phase starts.

```solidity
event RandomAcquisitionStarted(
    uint24 rewardEpochId,
    uint64 timestamp
)
```

### RewardEpochStarted

Event emitted when reward epoch starts.

```solidity
event RewardEpochStarted(
    uint24 rewardEpochId,
    uint32 startVotingRoundId,
    uint64 timestamp
)
```

### RewardsSigned

Event emitted when rewards are signed.

```solidity
event RewardsSigned(
    uint24 rewardEpochId,
    address signingPolicyAddress,
    address voter,
    bytes32 rewardsHash,
    struct IFlareSystemsManager.NumberOfWeightBasedClaims[] noOfWeightBasedClaims,
    uint64 timestamp,
    bool thresholdReached
)
```

### SignUptimeVoteEnabled

Event emitted when it is time to sign uptime vote.

```solidity
event SignUptimeVoteEnabled(
    uint24 rewardEpochId,
    uint64 timestamp
)
```

### SigningPolicySigned

Event emitted when signing policy is signed.

```solidity
event SigningPolicySigned(
    uint24 rewardEpochId,
    address signingPolicyAddress,
    address voter,
    uint64 timestamp,
    bool thresholdReached
)
```

### UptimeVoteSigned

Event emitted when uptime vote is signed.

```solidity
event UptimeVoteSigned(
    uint24 rewardEpochId,
    address signingPolicyAddress,
    address voter,
    bytes32 uptimeVoteHash,
    uint64 timestamp,
    bool thresholdReached
)
```

### UptimeVoteSubmitted

Event emitted when uptime vote is submitted.

```solidity
event UptimeVoteSubmitted(
    uint24 rewardEpochId,
    address signingPolicyAddress,
    address voter,
    bytes20[] nodeIds,
    uint64 timestamp
)
```

### VotePowerBlockSelected

Event emitted when vote power block is selected.

```solidity
event VotePowerBlockSelected(
    uint24 rewardEpochId,
    uint64 votePowerBlock,
    uint64 timestamp
)
```

## Structures

### NumberOfWeightBasedClaims

Number of weight based claims structure

```solidity
struct NumberOfWeightBasedClaims {
  uint256 rewardManagerId;
  uint256 noOfWeightBasedClaims;
}
```

### Signature

Signature structure

```solidity
struct Signature {
  uint8 v;
  bytes32 r;
  bytes32 s;
}
```",2025-03-08 01:27:14
secure-random-numbers.mdx,"slug: secure-random-numbers
title: Secure Random Numbers
tags: [quickstart, solidity, javascript, python, rust, go]
authors: [dineshpinto, horiamagureanu, charlesgrover]
description: Use Flare's secure randomness in your application.
keywords:
  [
    solidity,
    javascript,
    python,
    rust,
    go,
    randomness,
    randomn-number,
    flare-time-series-oracle,
    flare-network,
  ]
sidebar_position: 6","import TabItem from ""@theme/TabItem"";
import Tabs from ""@theme/Tabs"";
import Remix from ""@site/src/components/remix"";
import CodeBlock from ""@theme/CodeBlock"";
import SecureRandomConsumer from ""!!raw-loader!/examples/developer-hub-solidity/SecureRandomConsumer.sol"";
import SetEvmVersionRemix from ""/static/img/set-evm-version-remix.png"";
import SecureRandomWeb3Js from ""!!raw-loader!/examples/developer-hub-javascript/secure_random_coston2_web3.js"";
import SecureRandomEthersJs from ""!!raw-loader!/examples/developer-hub-javascript/secure_random_coston2_ethers.js"";
import SecureRandomWeb3Py from ""!!raw-loader!/examples/developer-hub-python/secure_random_coston2.py"";
import SecureRandomRust from ""!!raw-loader!/examples/developer-hub-rust/src/bin/secure_random_coston2.rs"";
import SecureRandomGo from ""!!raw-loader!/examples/developer-hub-go/coston2/secure_random.go"";
import RandomNumberV2Lottery from ""!!raw-loader!/examples/developer-hub-solidity/RandomNumberV2Lottery.sol"";

This guide explains how to obtain secure random numbers on Flare. Secure randomness is generated by the [Scaling](/ftso/scaling/overview) protocol, which leverages a decentralized network of approximately 100 data providers who generate random numbers every 90 seconds.

The protocol aggregates these individual random numbers to produce a final random number that is both uniform and resistant to manipulation. The uniformity of this random number is ensured as long as at least one of the data providers remains honest, i.e. 1-of-N.
The protocol has an in-built security mechanism to detect manipulation attempts, and will warn the end user if such an attempt is detected.

<details>
<summary>**Understand the mechanism behind secure random numbers on Flare.**</summary>

As described in the [FTSOv2 whitepaper](https://flare.network/wp-content/uploads/FTSOv2-White-Paper.pdf), the Scaling protocol consists of the following phases:

1. **Commit:** During the Commit phase, data providers prepare their submissions for each of the data feeds and encode them into a 4-byte vector. Then, each data provider publishes on chain a hash commitment obtained as:

   `Hash(address, voting_epoch_id, random_number, price_data)`

   - **Random Number**: This commit includes a locally generated random number.
   - **Purpose**: The random number blinds the commit hash of the user from a search attack and is used later (once revealed) to contribute to onchain randomness.

2. **Reveal:** During the Reveal phase, each data provider reveals all inputs to their hash commitment. As such, all locally produced random numbers become available onchain.

3. **Signing:** After the Reveal phase, data providers perform a number of local computations relevant to the Scaling protocol, which include:

   - Computing the weighted median prices
   - Calculating the rewards

   All these are packaged into a Merkle root, which is published onchain together with a signature of the root.

4. **Finalization:** Once enough signatures for the same Merkle root are gathered, the process is finalized.

**Secure Random Numbers**

For each voting epoch (90 seconds), an overall random number is generated from the local random numbers:

$$
R = \sum_{i} r_i \pmod{N}
$$

where $r_i$ is the local random number generated by the $i^{th}$ data provider, and $ N = 2^n $ denotes the maximum possible size of the individual $n$-bit random numbers.
This mechanism ensures that the resultant $R$ is a uniformly generated random number as long as at least any one of the inputs was an honestly generated uniformly random number.

Importantly, the Merkle root published by the data providers contains a Boolean value that tracks whether the generated random number for the current voting epoch is secure.

**Security Mechanism**

The security mechanism behind the random number generator protects the protocol against withholding attacks. An adversary could wait until all submissions are known and then choose whether or not to reveal their own commit data to influence the final result. This security mechanism measures the quality of the random number as follows:

- **True**: If there are no omissions of reveals for the commits provided by the data providers.
- **False**: If any omission exists, or if a reveal does not match the committed value.

If a data provider causes an omission (or false reveal), they will be penalized, and their random number will not be included in the random number calculation for a number of voting rounds.

</details>

## Use secure random onchain

:::tip

You can integrate secure random numbers into your application on Flare for no cost (not even gas!).

:::

<CodeBlock language=""solidity"" title=""SecureRandomConsumer.sol"">
  {SecureRandomConsumer}
</CodeBlock>

{/* prettier-ignore */}
<Remix fileName=""SecureRandomConsumer.sol"">Open in Remix</Remix>
<br></br>

In addition to the `randomNumber` itself, two other variables are retrieved:

- `isSecure`: A boolean flag indicating whether the random number was generated securely. If the protocol detects any attempt to manipulate the random number, this flag is set to `false`.

- `timestamp`: The UNIX timestamp marking the end of the voting epoch during which data was collected from data providers to generate the specific number. Each voting epoch lasts for a fixed 90-second window.

:::warning[Set EVM Version to London]

- **Using Remix:** Set EVM version to `london` in the **Advanced Configurations** section of the **Solidity Compiler** tab:

  <img src={SetEvmVersionRemix} style={{ width: 300 }} />

- **Using Hardhat or Foundry:** Set EVM version to `london` in [hardhat.config.ts](https://github.com/flare-foundation/flare-hardhat-starter/blob/master/hardhat.config.ts#L34) or [foundry.toml](https://github.com/flare-foundation/flare-foundry-starter/blob/master/foundry.toml).

- **Using Standard Solidity JSON:** Set `evmVersion` to `london`:

  ```json
  {
    ""settings"": {
      ""optimizer"": {
        /* ... */
      },
      ""evmVersion"": ""london""
    }
  }
  ```

- **Using `solc` CLI:** Set `--evm-version` to `london`:

  ```bash
  solc --evm-version london <args>
  ```

:::

### Example lottery application

This contract implements an example simple lottery system that utilizes a secure random number to select a winner.
Participants can enter the lottery, and the winner is drawn using the secure random number generated by `RandomNumberV2`.

<CodeBlock language=""solidity"" title=""RandomNumberV2Lottery.sol"">
  {RandomNumberV2Lottery}
</CodeBlock>

{/* prettier-ignore */}
<Remix fileName=""RandomNumberV2Lottery.sol"">Open in Remix</Remix>
<br></br>

## Use secure random offchain

To obtain a secure random number offchain, you need two key pieces of information:

1. **RPC Endpoint URL:** The RPC Endpoint URL determines which network your code will interact with. You can use a node provider service or point to your [own RPC node](/run-node/rpc-node). A comprehensive list of public and private RPC endpoints for all Flare networks is available on the [Network Configuration](/network/overview#configuration) page.

2. **Contract Address:** The address for the `RandomNumberV2` contract varies by network. You can obtain this address in two ways:

   - **From the Solidity Reference page:** Find the `RandomNumberV2` address for each network on the [Solidity Reference](/network/solidity-reference) page.

     **OR**

   - **Query the FlareContractRegistry Contract:** The `FlareContractRegistry` contract has the same address across all networks. You can query it to get the `RandomNumberV2` contract address. Refer to the specific language guides for examples:
     - [JavaScript](/network/guides/flare-for-javascript-developers#make-query)
     - [Python](/network/guides/flare-for-python-developers#make-query)
     - [Rust](/network/guides/flare-for-rust-developers#make-query)
     - [Go](/network/guides/flare-for-go-developers#make-query)

:::tip

All examples in this guide are available at [developer-hub/examples](https://github.com/flare-foundation/developer-hub/tree/main/examples).

:::

<Tabs block>
  <TabItem value=""web3js"" label=""web3.js"" default>
    
    This example uses [web3.js](https://github.com/web3/web3.js) to retrieve a secure random number on Flare Testnet Coston2.

    ```bash
    npm install web3
    ```

    <CodeBlock language=""javascript"" title=""secure_random.js"">
      {SecureRandomWeb3Js}
    </CodeBlock>

  </TabItem>
  <TabItem value=""ethersjs"" label=""ethers.js"">
    
    This example uses [ethers.js](https://github.com/ethers-io/ethers.js/) to retrieve a secure random number on Flare Testnet Coston2.

    ```bash
    npm install ethers
    ```

    <CodeBlock language=""javascript"" title=""secure_random.js"">
      {SecureRandomEthersJs}
    </CodeBlock>

  </TabItem>
  <TabItem value=""web3py"" label=""web3.py"">

    This example uses [web3.py](https://github.com/ethereum/web3.py) to retrieve a secure random number on Flare Testnet Coston2.

    <Tabs groupId=""python"">
      <TabItem value=""uv"" label=""uv"" default>

        ```bash
        uv add web3
        ```

      </TabItem>
      <TabItem value=""pip"" label=""pip"">

        ```bash
        pip install web3
        ```

      </TabItem>
    </Tabs>

    <CodeBlock language=""python"" title=""secure_random.py"">
      {SecureRandomWeb3Py}
    </CodeBlock>

  </TabItem>
  <TabItem value=""alloyrs"" label=""alloy-rs"">

    This example uses [alloy-rs](https://github.com/alloy-rs) to retrieve a secure random number on Flare Testnet Coston2.

    ```bash
    cargo add alloy eyre tokio --features alloy/full,tokio/rt,tokio/rt-multi-thread,tokio/macros
    ```
    <CodeBlock language=""rust"" title=""secure_random.rs"">
      {SecureRandomRust}
    </CodeBlock>

  </TabItem>
  <TabItem value=""goethereum"" label=""go-ethereum"">
    This example uses the Go API from [Geth](https://geth.ethereum.org) to retrieve FTSOv2 feed data for FLR/USD, BTC/USD, and ETH/USD from Flare Testnet Coston2.

    ```bash
    go get github.com/ethereum/go-ethereum/ethclient
    ```
    The project structure should look like:

    ```plaintext
    developer-hub-go/
    ‚îú‚îÄ‚îÄ coston2/
    ‚îÇ   ‚îî‚îÄ‚îÄ *.go
    ‚îú‚îÄ‚îÄ flare/
    ‚îÇ   ‚îî‚îÄ‚îÄ *.go
    ‚îú‚îÄ‚îÄ main.go
    ‚îú‚îÄ‚îÄ go.mod
    ‚îî‚îÄ‚îÄ go.sum
    ```

    With Go, you need to manually fetch the contract's ABI and generate the Go bindings.
    Copy the [RandomNumberV2 ABI](https://api.routescan.io/v2/network/testnet/evm/114/etherscan/api?module=contract&action=getabi&address=0x5CdF9eAF3EB8b44fB696984a1420B56A7575D250&format=raw) and paste it into a file named `RandomNumberV2.abi`, located in the root of your project, i.e. same level as `go.mod`. Then using [abigen](https://geth.ethereum.org/docs/tools/abigen), generate the Go bindings.

    ```bash
    abigen --abi RandomNumberV2.abi --pkg coston2 --type RandomNumberV2 --out coston2/RandomNumberV2.go
    ```

    <CodeBlock language=""go"" title=""coston2/secure_random.go"">
      {SecureRandomGo}
    </CodeBlock>

  </TabItem>
</Tabs>",2025-03-08 01:27:14
flare-for-rust-developers.mdx,"slug: flare-for-rust-developers
title: Flare for Rust Devs
authors: [dineshpinto]
description: Learn how to interact with Flare using alloy-rs.
tags: [rust, quickstart, solidity]
keywords: [rust, alloy-rs, quickstart, solidity, smart-contract, flare-network]
sidebar_position: 4","import Tabs from ""@theme/Tabs"";
import TabItem from ""@theme/TabItem"";
import CodeBlock from ""@theme/CodeBlock"";
import FtsoV2FeedConsumerNoImports from ""!!raw-loader!/examples/developer-hub-solidity/FtsoV2FeedConsumer_no_imports.sol"";
import ChainIdCoston2 from ""!!raw-loader!/examples/developer-hub-rust/src/bin/chain_id_coston2.rs"";
import ChainIdFlare from ""!!raw-loader!/examples/developer-hub-rust/src/bin/chain_id_flare.rs"";
import CreateAccount from ""!!raw-loader!/examples/developer-hub-rust/src/bin/create_account.rs"";
import MakeQueryCoston2 from ""!!raw-loader!/examples/developer-hub-rust/src/bin/make_query_coston2.rs"";
import MakeQueryFlare from ""!!raw-loader!/examples/developer-hub-rust/src/bin/make_query_flare.rs"";
import DeployContractCoston2 from ""!!raw-loader!/examples/developer-hub-rust/src/bin/deploy_contract_coston2.rs"";
import DeployContractFlare from ""!!raw-loader!/examples/developer-hub-rust/src/bin/deploy_contract_flare.rs"";
import Config from ""!!raw-loader!/examples/developer-hub-rust/config.json"";

This guide is for developers who want to interact with Flare using Rust. In this guide, using Rust, you will learn how to:

- Query a contract on Flare using [alloy-rs](https://github.com/alloy-rs), an async library for interacting with Ethereum-like chains.
- Compile a Solidity contract using the CLI interface of [solc](https://github.com/ethereum/solidity), the Solidity compiler.
- Deploy your compiled contract on Flare.

:::tip

All examples in this guide are available at [developer-hub/examples](https://github.com/flare-foundation/developer-hub/tree/main/examples).

:::

## Getting started

Install the Solidity compiler by following the instructions in the [Solidity documentation](https://docs.soliditylang.org/en/latest/installing-solidity.html#linux-packages). The main commands are provided here:

<Tabs>
  <TabItem value=""macos"" label=""MacOS via Homebrew"" default>

    ```bash
    brew tap ethereum/ethereum
    brew install solidity
    ```

  </TabItem>
  <TabItem value=""ubuntu"" label=""Ubuntu via PPAs"">
  
    ```bash 
    sudo add-apt-repository -y ppa:ethereum/ethereum
    sudo apt update
    sudo apt install solc
    ```
    
  </TabItem>
</Tabs>

Install the following dependencies:

```bash
cargo add alloy eyre tokio --features alloy/full,tokio/rt,tokio/rt-multi-thread,tokio/macros
```

### Usage

You need to connect to testnet or mainnet via an RPC, any RPC listed on the [Network Configuration](/network/overview#configuration) page will work. For this guide, you can use the Public RPC.

<Tabs groupId=""network"">
  <TabItem value=""coston2"" label=""Flare Testnet Coston2"" default>

    <CodeBlock language=""rust"" title=""src/bin/chain_id.rs"">
      {ChainIdCoston2}
    </CodeBlock>

    </TabItem>
    <TabItem value=""flare"" label=""Flare Mainnet"">

    <CodeBlock language=""rust"" title=""src/bin/chain_id.rs"">
      {ChainIdFlare}
    </CodeBlock>

  </TabItem>
</Tabs>

```bash
cargo run --bin chain_id
```

## Querying a contract

To query a contract, two pieces of information are required:

- Contract address
- Contract ABI (Application Binary Interface)

For this example, you can use the `FlareContractRegistry` contract which has the same address `0xaD67FE66660Fb8dFE9d6b1b4240d8650e30F6019` across both testnet and mainnet.

### Fetch ABI

To fetch a contract's ABI, copy the [FlareContractRegistry ABI](https://api.routescan.io/v2/network/testnet/evm/114/etherscan/api?module=contract&action=getabi&address=0xaD67FE66660Fb8dFE9d6b1b4240d8650e30F6019&format=raw), and paste it into a file named `FlareContractRegistry.json`, located in the root of your project, i.e. same level as `Cargo.toml`.

### Make query

You can now query the `FlareContractRegistry` contract to get the addresses of other Flare contracts.

For example, querying it for the address of the `WNat` contract:

<Tabs groupId=""network"">
  <TabItem value=""coston2"" label=""Flare Testnet Coston2"" default>

    <CodeBlock language=""rust"" title=""src/bin/make_query.rs"">
      {MakeQueryCoston2}
    </CodeBlock>

  </TabItem>
  <TabItem value=""flare"" label=""Flare Mainnet"">

    <CodeBlock language=""rust"" title=""src/bin/make_query.rs"">
      {MakeQueryFlare}
    </CodeBlock>

  </TabItem>
</Tabs>

```bash
cargo run --bin make_query
```

## Compiling a contract

For this example, you can use the `FtsoV2FeedConsumer` contract to query the FTSOv2 feeds. Copy the `FtsoV2FeedConsumer` sample contract code given below, and save the `.sol` file in the same folder as your `Cargo.toml`.

<details>
<summary>`FtsoV2FeedConsumer` sample contract</summary>

Note that the contract interface dependencies have been inlined to avoid any import issues.

<CodeBlock language=""solidity"" title=""FtsoV2FeedConsumer.sol"">
  {FtsoV2FeedConsumerNoImports}
</CodeBlock>

</details>

### Compile with solc

To compile the contract using the Solidity CLI compiler, create a file named `config.json`:

<CodeBlock language=""json"" title=""config.json"">
  {Config}
</CodeBlock>

```bash
solc --standard-json config.json  > FtsoV2FeedConsumer.json
```

This will generate a `FtsoV2FeedConsumer.json` file with the contract's ABI and bytecode.

### Modify format

Things get a bit annoying here, as the alloy-rs `solc!()` macro expects a specific format for the JSON, which is not the same as the output from the Solidity compiler. To fix this, in the generated `FtsoV2FeedConsumer.json`, remove the top-level JSON fields, after you are done, the JSON should look like:

```json title=""FtsoV2FeedConsumer.json""
{
  ""abi"": [
    ...
  ],
  ""evm"": {
    ...
  }
  ""metadata"": ""...""
}
```

## Create account

Before deploying a contract, you need to have an account with some testnet or mainnet gas tokens. You can create a new Flare account using `create_account.rs`:

<CodeBlock language=""rust"" title=""src/bin/create_account.rs"">
  {CreateAccount}
</CodeBlock>

```bash
cargo run --bin create_account
```

This will output a new private key and an account pair.

:::danger

- Never share your private keys.
- Never put your private keys in source code.
- Never commit private keys to a Git repository.

:::

You can save the account and private key into environment variables `ACCOUNT` and `ACCOUNT_PRIVATE_KEY` respectively.

:::note

You can also import the raw hex private key to MetaMask and any other wallet - the private key can be shared between your Rust code and any number of wallets.

:::

- For testnet, you can get free testnet C2FLR on the [Coston2 Faucet](https://faucet.flare.network/coston2).
- For mainnet you will need to fund the account with FLR. You can buy FLR with regular currency in places like centralized exchanges, crypto on-ramps, or swap other tokens for FLR on decentralized exchanges.

## Deploying with alloy-rs

With the account ready, you can now deploy the contract. In a `deploy_contract.rs` file, you can define the following code to deploy the contract:

<Tabs groupId=""network"">
  <TabItem value=""coston2"" label=""Flare Testnet Coston2"" default>

    <CodeBlock language=""rust"" title=""src/bin/deploy_contract.rs"">
      {DeployContractCoston2}
    </CodeBlock>

  </TabItem>
  <TabItem value=""flare"" label=""Flare Mainnet"">

    <CodeBlock language=""rust"" title=""src/bin/deploy_contract.rs"">
      {DeployContractFlare}
    </CodeBlock>

  </TabItem>
</Tabs>

You can now run the `deploy_contract.rs` script to deploy the contract. The contract address will be printed once the deployment is successful. You can check the contract address on a Flare Blockchain explorer, linked on the [Network Configuration](/network/overview#configuration) page.

```bash
cargo run --bin deploy_contract
```

Congratulations! You have now successfully deployed a contract on Flare using ü¶Ä.

:::tip[What's next?]

Learn how to interact with Flare's enshrined oracle [FTSOv2 using Rust](/ftso/guides/read-feeds-offchain).

:::",2025-03-08 01:27:14
flare-for-go-developers.mdx,"slug: flare-for-go-developers
title: Flare for Go Devs
authors: [dineshpinto]
tags: [go, quickstart, solidity]
description: Learn how to interact with Flare using geth.
keywords: [go, quickstart, solidity, smart-contract, flare-network]
sidebar_position: 5","import Tabs from ""@theme/Tabs"";
import TabItem from ""@theme/TabItem"";
import CodeBlock from ""@theme/CodeBlock"";
import FtsoV2FeedConsumerNoImports from ""!!raw-loader!/examples/developer-hub-solidity/FtsoV2FeedConsumer_no_imports.sol"";
import ChainIdCoston2 from ""!!raw-loader!/examples/developer-hub-go/coston2/chain_id.go"";
import ChainIdFlare from ""!!raw-loader!/examples/developer-hub-go/flare/chain_id.go"";
import MakeQueryCoston2 from ""!!raw-loader!/examples/developer-hub-go/coston2/make_query.go"";
import MakeQueryFlare from ""!!raw-loader!/examples/developer-hub-go/flare/make_query.go"";
import CreateAccount from ""!!raw-loader!/examples/developer-hub-go/create_account.go"";
import DeployContractCoston2 from ""!!raw-loader!/examples/developer-hub-go/coston2/deploy_contract.go"";
import DeployContractFlare from ""!!raw-loader!/examples/developer-hub-go/flare/deploy_contract.go"";

This guide is for developers who want to interact with Flare using Go. In this guide, using Go, you will learn how to:

- Query a contract on Flare using the Go API for [Geth](https://github.com/ethereum/go-ethereum), a client that implements the full Ethereum JSON-RPC API.
- Compile a Solidity contract using the CLI interface of [solc](https://github.com/ethereum/solidity), the Solidity compiler.
- Deploy your compiled contract on Flare.

:::tip

All examples in this guide are available at [developer-hub/examples](https://github.com/flare-foundation/developer-hub/tree/main/examples).

:::

## Getting started

Install Geth by following the instructions in the [Geth documentation](https://geth.ethereum.org/docs/getting-started/installing-geth). Also install the Solidity compiler by following the instructions in the [Solidity documentation](https://docs.soliditylang.org/en/latest/installing-solidity.html#linux-packages). The main commands are provided here:

<Tabs>
  <TabItem value=""macos"" label=""MacOS via Homebrew"" default>

    ```bash
    brew tap ethereum/ethereum
    brew install ethereum solidity
    ```

  </TabItem>
  <TabItem value=""ubuntu"" label=""Ubuntu via PPAs"">
  
    ```bash 
    sudo add-apt-repository -y ppa:ethereum/ethereum
    sudo apt update
    sudo apt install ethereum solc
    ```
    
  </TabItem>
</Tabs>

Add the `ethclient` and `keystore` packages to your Go project:

```bash
go get github.com/ethereum/go-ethereum/ethclient
go get github.com/ethereum/go-ethereum/accounts/keystore
```

The folder structure of your Go project should look like:

```plaintext
developer-hub-go/
‚îú‚îÄ‚îÄ coston2/
‚îÇ   ‚îî‚îÄ‚îÄ *.go
‚îú‚îÄ‚îÄ flare/
‚îÇ   ‚îî‚îÄ‚îÄ *.go
‚îú‚îÄ‚îÄ main.go
‚îú‚îÄ‚îÄ go.mod
‚îî‚îÄ‚îÄ go.sum
```

### Usage

You need to connect to testnet or mainnet via an RPC, any RPC listed on the [Network Configuration](/network/overview#configuration) page will work. For this guide, you can use the Public RPC.

<Tabs groupId=""network"">
  <TabItem value=""coston2"" label=""Flare Testnet Coston2"" default>

    <CodeBlock language=""go"" title=""coston2/chain_id.go"">
      {ChainIdCoston2}
    </CodeBlock>

  </TabItem>
  <TabItem value=""flare"" label=""Flare Mainnet"">

    <CodeBlock language=""go"" title=""flare/chain_id.go"">
      {ChainIdFlare}
    </CodeBlock>

  </TabItem>
</Tabs>

## Querying a contract

To query a contract, two pieces of information are required:

- Contract address
- Contract ABI (Application Binary Interface)

For this example, you can use the `FlareContractRegistry` contract which has the same address `0xaD67FE66660Fb8dFE9d6b1b4240d8650e30F6019` across both testnet and mainnet.

### Fetch ABI

To fetch a contract's ABI, copy the [FlareContractRegistry ABI](https://api.routescan.io/v2/network/testnet/evm/114/etherscan/api?module=contract&action=getabi&address=0xaD67FE66660Fb8dFE9d6b1b4240d8650e30F6019&format=raw), and paste it into a file named `FlareContractRegistry.abi`, located in the root of your project, i.e. same level as `go.mod`.

To generate the ABI bindings, which will be saved to `FlareContractRegistry.go`:

<Tabs groupId=""network"">
  <TabItem value=""coston2"" label=""Flare Testnet Coston2"" default>

    ```bash
    abigen --abi FlareContractRegistry.abi --pkg coston2 --type FlareContractRegistry --out coston2/FlareContractRegistry.go
    ```

  </TabItem>
  <TabItem value=""flare"" label=""Flare Mainnet"">

    ```bash
    abigen --abi FlareContractRegistry.abi --pkg flare --type FlareContractRegistry --out flare/FlareContractRegistry.go
    ```

  </TabItem>
</Tabs>

### Make query

You can now query the `FlareContractRegistry` contract to get the addresses of other Flare contracts.

For example, querying it for the address of the `WNat` contract:

<Tabs groupId=""network"">
  <TabItem value=""coston2"" label=""Flare Testnet Coston2"" default>

    <CodeBlock language=""go"" title=""coston2/make_query.go"">
      {MakeQueryCoston2}
    </CodeBlock>

  </TabItem>
  <TabItem value=""flare"" label=""Flare Mainnet"">
    
    <CodeBlock language=""go"" title=""flare/make_query.go"">
      {MakeQueryFlare}
    </CodeBlock>

  </TabItem>
</Tabs>

## Compiling with solc

For this example, you can use the `FtsoV2FeedConsumer` contract to query the FTSOv2 feeds. Copy the `FtsoV2FeedConsumer` sample contract code given below, and save the `.sol` file in the same folder as your `go.mod`.

<details>
<summary>`FtsoV2FeedConsumer` sample contract</summary>

Note that the contract interface dependencies have been inlined to avoid any import issues.

<CodeBlock language=""solidity"" title=""FtsoV2FeedConsumer.sol"">
  {FtsoV2FeedConsumerNoImports}
</CodeBlock>

</details>

To compile the contract, use the Solidity compiler:

```bash
solc --evm-version london --abi --bin FtsoV2FeedConsumer.sol -o build
```

The compiled contract will be saved in the `build/` folder.

## Create account

Before deploying a contract, you need an account. You can create an account using the following code:

<CodeBlock language=""go"" title=""create_account.go"">
  {CreateAccount}
</CodeBlock>

This will generate a new account and save the keystore file in the current directory. The account address will be printed to the console.

:::danger

- Never share your private keys.
- Never put your private keys in source code.
- Never commit private keys to a Git repository.

:::

- For testnet, you can get free testnet C2FLR on the [Coston2 Faucet](https://faucet.flare.network/coston2).
- For mainnet you will need to fund the account with FLR. You can buy FLR with regular currency in places like centralized exchanges, crypto on-ramps, or swap other tokens for FLR on decentralized exchanges.

## Deploying with geth

To deploy the contract, you need to first generate the contract bindings:

<Tabs groupId=""network"">
  <TabItem value=""coston2"" label=""Flare Testnet Coston2"" default>

    ```bash
    abigen --bin=build/FtsoV2FeedConsumer.bin --abi=build/FtsoV2FeedConsumer.abi --pkg coston2 --type FtsoV2FeedConsumer --out coston2/FtsoV2FeedConsumer.go
    ```

  </TabItem>
  <TabItem value=""flare"" label=""Flare Mainnet"">
    
    ```bash
    abigen --bin=build/FtsoV2FeedConsumer.bin --abi=build/FtsoV2FeedConsumer.abi --pkg flare --type FtsoV2FeedConsumer --out flare/FtsoV2FeedConsumer.go
    ```

  </TabItem>
</Tabs>

This will generate the `FtsoV2FeedConsumer.go` file, with the function `DeployFtsoV2FeedConsumer`.

Copy the contents of the generated keystore file into the `key` constant in the following code:

<Tabs groupId=""network"">
  <TabItem value=""coston2"" label=""Flare Testnet Coston2"" default>

    <CodeBlock language=""go"" title=""deploy_contract.go"">
      {DeployContractCoston2}
    </CodeBlock>

  </TabItem>
  <TabItem value=""flare"" label=""Flare Mainnet"">

    <CodeBlock language=""go"" title=""deploy_contract.go"">
      {DeployContractFlare}
    </CodeBlock>

</TabItem>

</Tabs>

Congratulations! You have now successfully deployed a contract on Flare using Go.

:::tip[What's next?]

Learn how to interact with Flare's enshrined oracle [FTSOv2 using Go](/ftso/guides/read-feeds-offchain).

:::",2025-03-08 01:27:14
hardhat-foundry-starter-kit.mdx,"slug: hardhat-foundry-starter-kit
title: Hardhat and Foundry Starter Kit
sidebar_label: Hardhat & Foundry Starter Kit
tags: [quickstart, hardhat, foundry, solidity]
authors: [filipkoprivec]
description: Integrate Flare into Hardhat and Foundry.
keywords:
  [hardhat, foundry, quickstart, solidity, smart-contract, flare-network]
sidebar_position: 1","import Tabs from ""@theme/Tabs"";
import TabItem from ""@theme/TabItem"";

The starter kit includes a basic setup for configuring Hardhat and Foundry, along with examples on how to compile, test and deploy smart contracts on Flare.

## Hardhat

### Getting Started

If you're new to Hardhat, review Hardhat's documentation on [Getting Started with Hardhat](https://hardhat.org/hardhat-runner/docs/getting-started#overview).

Install the following prerequisites:

- [Node.js](https://nodejs.org/en) v18.0 or higher
- [npm](https://nodejs.org/en/learn/getting-started/an-introduction-to-the-npm-package-manager) or [yarn](https://yarnpkg.com)

:::tip

[Hardhat for Visual Studio Code](https://hardhat.org/hardhat-vscode) is the official Hardhat extension that adds advanced support for Solidity to VSCode. If you use VSCode, give it a try!

:::

:::info

OpenZeppelin version `4.x` is used for this Starter Kit, ensure you refer to the correct version of the [OpenZeppelin documentation](https://docs.openzeppelin.com/contracts/4.x/).

:::

### Setup

#### Cloning and installing dependencies

Clone the [template repository](https://github.com/flare-foundation/flare-hardhat-starter) and navigate into the project directory.

```bash
git clone https://github.com/flare-foundation/flare-hardhat-starter.git
cd flare-hardhat-starter
```

Install the project dependencies.

<Tabs groupId=""jsmanager"">
  <TabItem value=""npm"" label=""npm"" default>

    ```bash
    npm install
    ```

  </TabItem>
  <TabItem value=""yarn"" label=""yarn"">

    ```bash
    yarn
    ```

    </TabItem>

</Tabs>

#### Setting up environment variables

Copy the example environment file and update it with your settings.

```bash
cp .env.example .env
```

Open the `.env` file and set your `PRIVATE_KEY`.

```text
PRIVATE_KEY=your_private_key_here
```

:::danger

- Never share your private keys.
- Never put your private keys in source code.
- Never commit private keys to a Git repository.

:::

### Compile, test and deploy

Compile the smart contracts to generate the necessary artifacts.

<Tabs groupId=""jsmanager"">
  <TabItem value=""npm"" label=""npm"" default>

    ```bash
    npx hardhat compile
    ```

  </TabItem>
  <TabItem value=""yarn"" label=""yarn"">

    ```bash
    yarn hardhat compile
    ```

  </TabItem>
</Tabs>

This command compiles all `.sol` files in the `/contracts` folder and generates artifacts needed for testing.

#### Testing your contracts

Run the provided test suite to ensure everything is set up correctly.

<Tabs groupId=""jsmanager"">
  <TabItem value=""npm"" label=""npm"" default>

    ```bash
    npx hardhat test
    ```

  </TabItem>
  <TabItem value=""yarn"" label=""yarn"">

    ```bash
    yarn hardhat test
    ```

  </TabItem>
</Tabs>

#### Deploying your contracts

Review and modify `hardhat.config.ts` to specify the networks you want to deploy to. The details for Flare Mainnet, Flare Testnet Coston2, Songbird Canary-Network and Songbird Testnet Coston are already included.

Optionally you can add the API keys for either [Flarescan](https://flarescan.com) or [Flare Explorer](https://flarescan.com) in the `.env` file.

<Tabs groupId=""jsmanager"">
  <TabItem value=""npm"" label=""npm"" default>

    ```bash
    npx hardhat run scripts/tryDeployment.ts
    ```

  </TabItem>
  <TabItem value=""yarn"" label=""yarn"">
  
    ```bash
    yarn npx hardhat run scripts/tryDeployment.ts
    ```

  </TabItem>
</Tabs>

## Foundry

### Getting Started

If you're new to Foundry, review Foundry's documentation on [Getting Started with Foundry](https://book.getfoundry.sh).

Install the following prerequisites:

- [Foundry](https://book.getfoundry.sh/getting-started/installation.html)

### Setup

#### Cloning and installing dependencies

Clone the [flare-foundry-starter](https://github.com/flare-foundation/flare-foundry-starter) and navigate into the project directory.

```bash
git clone https://github.com/flare-foundation/flare-foundry-starter.git
cd flare-foundry-starter
```

Install the project dependencies.

```bash
forge soldeer install
```

You might need to modify `remappings.txt` so `/src` paths are read correctly, e.g.:

```bash
@openzeppelin-contracts/=dependencies/@openzeppelin-contracts-5.2.0-rc.1/
flare-periphery/=dependencies/flare-periphery-0.0.1/
forge-std/=dependencies/forge-std-1.9.5/src/
forge-std/=dependencies/forge-std-1.9.5/
surl/=dependencies/surl-0.0.0/src/
surl/=dependencies/surl-0.0.0/
```

#### Setting up environment variables

Copy `.env.example` to `.env` and update it with your settings.

Add `PRIVATE_KEY` to your environment variables.

```text
PRIVATE_KEY=your_private_key_here
```

:::danger

- Never share your private keys.
- Never put your private keys in source code.
- Never commit private keys to a Git repository.

:::

You now need to add the information from the `.env` file to your bash profile:

```bash
source .env
```

You need to do this every time you open a new terminal or change the `.env` file.

### Compile, test and deploy

Compile the smart contracts to generate the necessary artifacts.

```bash
forge build
```

This command compiles all `.sol` files in the `/src` folder and generates artifacts needed for testing.

#### Testing contracts

Run the provided test suite to ensure everything is set up correctly.

```bash
forge test
```

#### Deploying your contracts

Run the deployment script using Foundry:

```bash
forge script script/Counter.s.sol --broadcast --private-key $PRIVATE_KEY --rpc-url <RPC_URL>
```

Replace `<RPC_URL>` with the RPC endpoint of the network you are deploying to. A list of RPC endpoints for Flare networks can be found in Flare's [Network Configuration](/network/overview#configuration).",2025-03-08 01:27:14
manage-flaredrops.mdx,"slug: manage-flaredrops
title: Manage FlareDrops
tags: [intermediate, solidity]
authors: [dineshpinto]
description: Manage FlareDrop functionality in applications.
keywords: [intermediate, solidity, smart-contract, flare-network]
sidebar_position: 7","[FlareDrops](https://flare.network/flaredrop-guide/) are a series of 36 monthly drops totalling 24.2 billion FLR can be claimed by active Flare community members who have wrapped their Flare tokens.
This guide explains how to manage FlareDrop functionality in applications.

<details>
<summary>**Understanding Personal Delegation Accounts (PDAs).**</summary>

Differences between PDAs and regular accounts:

- A PDA cannot have another PDA of its own.
- PDA addresses cannot participate in governance directly, but their owners can transfer all their votes to another address (their main account or someone else's).
- A PDA automatically converts any FLR tokens transferred to it to wrapped Flare tokens (WFLR), which are more useful for functions such as delegation.
- Only the owner of the main account can transfer funds from the PDA and only to the main account.
- When an executor is configured, it will claim rewards both from the main account and the PDA, and send them to the PDA.

</details>

<details>
<summary>**Understanding the Registered Claim Process.**</summary>

Registration allows accounts to list themselves onchain as registered executors and post their service fees. This simplifies the process for both users and executors: users can easily find a suitable executor, and executors benefit from automatic fee transfers when user rewards are claimed. Users pay a fee to set an executor for claiming their rewards, which are then claimed automatically without user intervention. All agreements with a registered executor occur onchain.

Here is how the registered claiming process works, with applications performing these actions on behalf of executors and users:

1. Executors who want to be publicly available to users register as executors by paying a registration fee, which is then burned.
2. Registered executors post their fees for claiming rewards.
3. Users with accrued rewards who want an executor to claim on their behalf can choose from the list of registered executors.
4. Users pay a setup fee to enable a registered executor to claim their rewards, and this fee is sent to the executor.
5. Executors claim rewards for one or more users, with their fees automatically deducted from the claimed rewards.
6. Executors notify users offchain if they discontinue providing this service.

Throughout the process:

- Users and executors can view reports on which addresses executors are claiming for and which executors are registered.
- Registered executors can change their fees or unregister, while users can change the registered executor claiming on their behalf or disable automatic claiming.

</details>

## Contracts

Working with the FlareDrop requires interacting with these contracts:

- `DistributionToDelegators` ([address](/network/solidity-reference), [interface](/network/solidity-reference/IDistributionToDelegators)): Manages FlareDrop claims.
- `ClaimSetupManager` ([address](/network/solidity-reference), [interface](/network/solidity-reference/IClaimSetupManager)): Automating reward claiming.

## Basic Claiming

The [`claim`](/network/solidity-reference/IDistributionToDelegators#claim) method on `DistributionToDelegators` allows claiming the FlareDrop one account at a time.
It transfers the FlareDrop rewards accrued by account `_rewardOwner` during the specified `_month` to the specified `_recipient`. `_wrap` controls whether the reward is transferred in native FLR tokens or wrapped in WFLR tokens.
You can use [`getCurrentMonth()`](/network/solidity-reference/IDistributionToDelegators#getcurrentmonth) to find out the current month (starting at 0), or [`getClaimableMonths()`](/network/solidity-reference/IDistributionToDelegators#getclaimablemonths) to get the interval of months which are currently available for claiming.

```solidity
function claim(
    address _rewardOwner,
    address _recipient,
    uint256 _month,
    bool _wrap
) external returns(
    uint256 _rewardAmount
);
```

:::note

Use [`getClaimableAmount()`](/network/solidity-reference/IDistributionToDelegators#getclaimableamount) or [`getClaimableAmountOf()`](/network/solidity-reference/IDistributionToDelegators#getclaimableamountof) to find out if a given address has pending rewards on any given month.

:::

The `claim()` function returns the amount of claimed rewards. Two modes of operation are supported:

- **Self-Claiming**: When `msg.sender` matches `_rewardOwner`

  Here, the caller is claiming its own rewards, and the `_recipient` can be any address.

- **Claiming on behalf of another account**: When `msg.sender` does not match `_rewardOwner`

  Here, the caller must be a claim executor, claiming on behalf of `_rewardOwner`. If `_msg.sender` is not in the authorized list of executors for `_rewardOwner`, the call will revert.
  Authorized executors must be set beforehand by `_rewardOwner` using [`setClaimExecutors()`](/network/solidity-reference/IClaimSetupManager#setclaimexecutors).
  The `_recipient` must either be `_rewardOwner`, its PDA, or any of the authorized recipients previously set by `_rewardOwner` using the [`setAllowedClaimRecipients()`](/network/solidity-reference/IClaimSetupManager#setallowedclaimrecipients) on `ClaimSetupManager`.
  The call will revert otherwise.

## Batched Claiming

The [`autoClaim()`](/network/solidity-reference/IDistributionToDelegators#autoclaim) method allows claiming the FlareDrop for an arbitrary amount of accounts in a single call, with convenient default values.
It claims the rewards accrued by all the accounts in the `_rewardOwners` array during the specified `_month`.
If an account does not have an enabled PDA, the rewards are sent to the same account.
However, if an account does have an enabled PDA, the rewards are sent to the PDA account.
Any rewards accrued by the PDA account are also claimed and sent to the PDA.
Rewards claimed with this method are always wrapped.

```solidity
function autoClaim(
    address[] calldata _rewardOwners,
    uint256 _month
) external;
```

If the executor is a registered executor with a nonzero fee, the fee is automatically deducted from each claimed reward and sent to the executor account (unwrapped).
If rewards are claimed for both an address and its PDA, the fee is deducted only once.

The call reverts if:

- `msg.sender` is not in the authorized list of executors for any of the `_rewardOwners`.
- The total claimed rewards for any of the `_rewardOwners` is not high enough to cover the executor's fee.",2025-03-08 01:27:14
using-flare-stake-tool.mdx,"title: Using Flare Stake Tool
tags: [intermediate, solidity]
authors: [dineshpinto]
description: Stake FLR using flare-stake-tool CLI.
keywords: [intermediate, solidity, smart-contract, flare-network]
sidebar_position: 8","Staking works by locking funds for a period of time to support a specific network validator. The guide details out how to stake using the [flare-stake-tool](https://github.com/flare-foundation/flare-stake-tool) CLI.

<details>
<summary>Understand staking on Flare.</summary>

When validator owners stake to their own nodes they **self-bond**, whereas all other participants are said to **delegate** their stake to that validator.
Note that delegating your stake to a validator is different from FTSO delegation.

Participants choose how much to stake and for how long their stake will be locked.
The minimum values are:

|                  | Self-bond | Delegation |
| ---------------- | --------: | ---------: |
| Minimum amount   |    1M FLR |    50K FLR |
| Minimum duration |   60 days |    14 days |

At the end of every reward epoch (i.e. 3.5 days on Flare Mainnet), participants are rewarded according to how well their chosen validator performed in that period.

**Limits**

The amount that you can stake and the rewards you can gain by staking are restricted by these limits:

- **Delegation factor**: Limits the total amount that can be staked to a validator to its self-bond, which is the amount validators stake to their own nodes, times the delegation factor, which is 15.
  For example, if a validator has a self-bond stake of 1M FLR, the total sum of all stakes, including delegations, cannot exceed 15M FLR.
  This limit allows for 14M FLR of delegations.

- **Staking cap**: Limits the reward performance of individual validators to **5% of the total staked amount**.
  If you stake your funds on a validator with more than 5% of the total staked amount, you receive less FLR in reward.
  To maximize your reward, delegate your staking funds to a validator with less than 5% of the total staked amount of FLR.

- **Maximum number of validators**: You can stake to any number of validators, but rewards, FlareDrops, and governance vote power only apply for up to 3 different validators.

Given that the Flare network uses two independent underlying chains, there is one extra step that must be considered.
Funds must be transferred from the C-chain, where smart contracts run, to the P-chain, where staking happens.
After the staking period expires and funds are unlocked, they can be transferred back to the C-chain.

</details>

## Prerequisites

Install the following tools:

- [npm](https://docs.npmjs.com/downloading-and-installing-node-js-and-npm)

## Setup

1. Install the `flare-stake-tool` CLI:

   ```bash
   npm install @flarenetwork/flare-stake-tool -g
   ```

2. Verify installation:

   ```bash
   flare-stake-tool
   ```

   The tool's banner is displayed:

   ```text
   _____ _                  ____  _        _           ____ _     ___
   |  ___| | __ _ _ __ ___  / ___|| |_ __ _| | _____   / ___| |   |_ _|
   | |_  | |/ _` | '__/ _ \ \___ \| __/ _` | |/ / _ \ | |   | |    | |
   |  _| | | (_| | | |  __/  ___) | || (_| |   <  __/ | |___| |___ | |
   |_|   |_|\__,_|_|  \___| |____/ \__\__,_|_|\_\___|  \____|_____|___|

   Version: 3.0.2
   ```

3. You can specify the account from which staking will take place in different ways. Choose one of the following two options:

<details>
<summary> Ledger setup (recommended). </summary>

**Install the Avalanche Application**

1. **Connect & Unlock:**

   - Connect your Ledger device to your computer.
   - Unlock it using your PIN code.

2. **Open Ledger Live:**

   - Launch the [Ledger Live](https://www.ledger.com/ledger-live) application.
   - Navigate to the **My Ledger** tab and ensure your device firmware is up-to-date.

3. **Install Avalanche App:**
   - In the **App Catalog** tab, search for **Avalanche**.
   - Click **Install**.

**Note:** The Avalanche app requires 138 KB of space on a **Ledger Nano S**. You may need to remove other apps if space is insufficient.

**Select Your Desired Account**

1. **Close Conflicting Applications:**

   - Exit Ledger Live.
   - Ensure the device is not connected to other applications like MetaMask.

2. **Open the Avalanche App:**

   - On the device, open the Avalanche app. The screen should display **""Avalanche Ready""**.

3. **Start the Staking Tool:**

   - Open a terminal and run:

     ```bash
     flare-stake-tool interactive
     ```

   - This starts the staking tool in interactive mode.

4. **Connect Your Wallet:**

   - After the welcome banner, the tool asks how to connect your wallet:

     ```text
     ? How do you want to connect your wallet? (Use arrow keys)
     > Ledger
     Public Key
     Private Key (not recommended)
     ```

   - Select **Ledger** and press **Enter**.

5. **Choose Network:**

   - Next, choose the desired network:

     ```text
     ? Which network do you want to connect to? (Use arrow keys)
     > Flare (Mainnet)
     Coston2 (Testnet)
     LocalHost (for development only)
     ```

   - Select **Flare (Mainnet)** and press **Enter**.

   - A **""Fetching Addresses...""** message appears briefly.

6. **Select an Address:**

   - A list of addresses linked to the Ledger device is displayed.
   - Select the desired address and press **Enter**.

**Important:** Ensure this address has a positive `$FLR` balance for transaction fees and staking. Funds can be transferred later if needed.

7. **Access the Main Menu:**

   - The main menu appears:

     ```text
     ? What do you want to do? (Use arrow keys)
         View chain addresses
     >   Check on-chain balance
         Get network info
         Get validator info
         Move assets from C-chain to P-chain
         Move assets from P-chain to C-chain
         Add a validator node
     ```

   - As an example, select **Check on-chain balance** and press **Enter**.

   - The tool displays the C-chain and P-chain balances before exiting.

**Account Persistence:** - After completing the setup, a `ctx.json` file is created in the current folder. - This file stores the selected account details, allowing you to skip the setup process on subsequent uses from the same folder.

</details>

<details>
<summary>Private key setup (not recommended).</summary>

If you **do not have a Ledger device**, you can still use your private key for staking. However, this method is **significantly less secure** and should be used only when no other option is available. Proceed with caution and ensure maximum file security.

**Create a Secure Text File**

1. **Create a Text File:**

   - Create a text file in a **secure folder** accessible only to you.
   - Use any file name you prefer.

2. **Add Your Private Key:**

   - Open the file and insert one of the following lines based on your private key format:

     ```text
     PRIVATE_KEY_CB58=""""
     PRIVATE_KEY_HEX=""""
     ```

   - **CB58 Format:** Use this if your key is in [CB58](https://support.avax.network/en/articles/4587395-what-is-cb58) format.
   - **HEX Format:** Use this if your key contains 64 hexadecimal characters.

   - **Important:** Paste your private key **inside the quotes** and save the file.

**Verify Private Key Access**

1. **Launch the Staking Tool:**

   - Open a terminal and run the following command:

     ```bash
     flare-stake-tool interactive
     ```

   - This starts the staking tool in interactive mode, prompting you with configuration questions.

**Connect Your Wallet**

1. **Select Connection Type:**

   - After the welcome banner, the following prompt appears:

     ```text
     ? How do you want to connect your wallet? (Use arrow keys)
         Ledger
         Public Key
     >   Private Key (not recommended)
     ```

   - Select **Private Key** using the arrow keys and press **Enter**.

2. **Enter File Path:**

   - You'll see a security warning:

     ```text
     Warning: You are connecting using your private key which is not recommended
     ? Enter Path to Private Key file (E.g. /home/wallet/pvtKeyFile):
     ```

   - Enter the full file path where your private key file is stored and press **Enter**.

**Choose Network**

- The following prompt appears:

  ```text
  ? Which network do you want to connect to? (Use arrow keys)
  > Flare (Mainnet)
      Coston2 (Testnet)
      LocalHost (for development only)
  ```

- Select **Flare (Mainnet)** and press **Enter**.

**Access the Main Menu**

- The main menu appears:

  ```text
  ? What do you want to do? (Use arrow keys)
      View chain addresses
  >   Check on-chain balance
      Get network info
      Get validator info
      Move assets from C-chain to P-chain
      Move assets from P-chain to C-chain
      Add a validator node
  ```

- As an example, select **Check on-chain balance** and press **Enter**.

- The tool will display your account balance for both the **C-chain** and **P-chain**, then exit.

**Security Reminder:**

- Using a private key stored in a plain text file is inherently **insecure**.
- Consider switching to a **Ledger device** or another secure method whenever possible.
- **Never share your private key** or expose it to untrusted applications.

</details>

4. Note down the **node ID** of the validator you want to stake to:

   - If you created the validator, retrieve its node ID by running:

     ```bash
     curl --location 'http://localhost:9650/ext/info' --header 'Content-Type: application/json' --data '{ ""jsonrpc"":""2.0"", ""id"":1, ""method"":""info.getNodeID"" }'
     ```

   - If you want to stake to somebody else's validator, get a JSON list of all validators by running:

     ```bash
     flare-stake-tool info validators
     ```

5. Note down the desired staking **start time** and **end time**: When staking to an existing validator, both these times must be inside the period when the validator is active. If you specify a period when the validator is inactive, your transaction on the P-chain reverts.
   To find the period when the validator is active:

   ```bash
   flare-stake-tool info validators
   ```

## Move funds to P-chain

1. Check your C-chain and P-chain balances by selecting the **Check on-chain balance** option when executing:

   ```bash
   flare-stake-tool interactive
   ```

   Your currently available funds on the C-chain and P-chain are shown in the last lines. Funds currently staked are locked and are not reflected in the P-chain balance.
   They will become automatically available when the staking period expires.

   ```plaintext
   ? How do you want to connect your wallet? Ledger
   You already have an existing Ctx file with the following parameters -
   Public Key: ‚óè‚óè‚óè‚óè‚óè‚óè‚óè‚óè‚óè‚óè‚óè‚óè‚óè‚óè‚óè‚óè
   Network: flare
   Eth Address: 0x‚óè‚óè‚óè‚óè‚óè‚óè‚óè‚óè
   ? Do you wish to continue with this? yes
   ? What do you want to do? Check on-chain balance
   Using network: flare
   Balances on the network ""flare""
   // highlight-next-line
   C-chain 0x‚óè‚óè‚óè‚óè‚óè‚óè‚óè‚óè: 100000.0 FLR
   // highlight-next-line
   P-chain P-flare‚óè‚óè‚óè‚óè‚óè‚óè‚óè‚óè: 50000.0 FLR
   ```

   If you already have funds on the P-chain, skip the next step.

2. Select the **Move assets from C-chain to P-chain** option when executing:

   ```bash
   flare-stake-tool interactive
   ```

   You are asked the amount of FLR you want to transfer:

   ```plaintext
   ? What do you want to do? Move assets from C-chain to P-chain
   ? Enter amount (in FLR): 50000
   ```

   :::warning[Transaction Fees]

   When transferring from the C-chain to the P-chain, transaction fees are wholly paid from the C-chain.
   Make sure you leave enough funds on the C-chain after the transfer, or it will fail.

   :::

3. Transfers between chains are made of two operations: an **export** from the C-chain followed by an **import** to the P-chain. Therefore, you are asked to confirm two transactions.

   ```plaintext
   // highlight-next-line
   Please approve export transaction
   Using network: flare
   Fetching account from ledger...
   Creating export transaction...
   Using fee of 0.00028075 FLR
   Please review and sign the transaction on your ledger device...
   Sending transaction to the node...
   Transaction with id ‚óè‚óè‚óè‚óè‚óè‚óè‚óè‚óè sent to the node
   // highlight-next-line
   Please approve import transaction
   Using network: flare
   Fetching account from ledger...
   Creating export transaction...
   Please review and sign the transaction on your ledger device...
   Sending transaction to the node...
   Transaction with id ‚óè‚óè‚óè‚óè‚óè‚óè‚óè‚óè sent to the node
   Finished execution
   ```

If you encounter any issues during this process, refer to the [Troubleshooting](#troubleshooting) section.

## Stake

1. After you have funds on the P-chain, execute the following command and select the appropriate option:

   ```bash
   flare-stake-tool interactive
   ```

   - If you are going to delegate to your own node (self-bonding), select **Add a validator node**.

   - If you are going to stake to another node (delegation), select **Delegate to a validator node** (You may need to scroll down to see this option).

   :::info[First-time address registration.]

   The first time you use the **Add a validator node** or **Delegate to a validator node** options you are asked to sign an additional transaction. This step is required so that staking rewards accrued on the P-chain can be claimed on the C-chain and participate in the wider ecosystem. This procedure only needs to be done once per P-chain address and it progresses like this:

   ```plaintext
   Checking Address Registration...
   No address found for key 0x‚óè‚óè‚óè‚óè‚óè‚óè‚óè‚óè
   Note: You need to register your wallet address before you can delegate your funds
   // highlight-next-line
   Please complete this registration transaction to proceed
   Submitting txn to the chain
   ```

   :::

2. You then need to provide the following information:

   - **amount**: Amount must be provided in FLR units.
   - **node ID**, **start time** and **end time**: Use the values noted down from the [setup](#setup).

3. If you selected **Add a validator node**, you have to set the **delegation fee**. This is the percentage of all rewards that the node owner keeps.
   The rest is split proportionally between the self-bond and all delegators that contributed stake. 10 means 10%, so the maximum value is 100.

   ```plaintext
   ? What do you want to do? Add a validator node
   ? Enter amount (in FLR): 50000
   ? Enter Node NodeId (E.g. NodeID-FQKTLuZHEsjCxPeFTFgsojsucmdyNDsz1): NodeID-‚óè‚óè‚óè‚óè‚óè‚óè‚óè‚óè
   ? Enter start time(E.g. 1693185095): ‚óè‚óè‚óè‚óè‚óè‚óè‚óè‚óè
   ? Enter end time(E.g. 1693185095): ‚óè‚óè‚óè‚óè‚óè‚óè‚óè‚óè
   ? Enter delegation fee(E.g. 10): 10
   ```

4. You are then asked to confirm the staking transaction on your hardware wallet.

   ```plaintext
   Using network: flare
   Fetching account from ledger...
   Creating export transaction...
   // highlight-next-line
   Please review and sign the transaction on your ledger device...
   Sending transaction to the node...
   Transaction with id ‚óè‚óè‚óè‚óè‚óè‚óè‚óè‚óè sent to the node
   Finished execution
   ```

   Your stake is now locked and will start accruing rewards after the configured start time arrives.
   When the end time arrives, the funds will be automatically unlocked.

If you encounter any issues during this process, refer to the [Troubleshooting](#troubleshooting) section.

## Check Stake

1. You can now double-check that the operation has been properly registered by looking at the current list of validators:

   ```bash
   flare-stake-tool info validators > validators.txt
   ```

   This creates a file called `validators.txt`. Open it and search for the line containing the **P-chain address** of your account. If you don't remember your address run:

   ```bash
   flare-stake-tool info addresses
   ```

2. If your account has stake on any node, you will find a section similar to:

   ```json
   {
     ""txID"": ""28Yf5yQ3xt9yaMvfZ1RP5jkCkT4y2pfD86UheZUHFVng2tFcWd"",
     ""startTime"": ""1688569201"",
     ""endTime"": ""1696345201"",
     ""stakeAmount"": ""16750000000000000"",
     ""nodeID"": ""NodeID-C6i8mruq11VdxGQ7tiUBgrRqoLBot86df"",
     ""rewardOwner"": {
       ""locktime"": ""0"",
       ""threshold"": ""1"",
       ""addresses"": [
         // highlight-next-line
         ""P-flare19c8zfml39x6efnw5j90nl85dmwdqhluwhrxz9g""
       ]
     },
   },
   ```

   Check that the `stakeAmount` (in wei), `nodeID`, `startTime`, and `endTime` match the values you configured. If you have multiple active stakes, your address will show up multiple times.

## Move funds back to C-Chain

1. Finally, you also have the option to move your P-chain funds back to the C-chain where they can participate in the wider ecosystem. You can only transfer P-chain funds that are not currently locked in any stake. Select the **Move assets from P-chain to C-chain** option when executing:

   ```bash
   flare-stake-tool interactive
   ```

2. You are asked the amount of FLR you want to transfer:

   ```plaintext
   ? What do you want to do? Move assets from P-chain to C-chain
   ? Enter amount (in FLR): 50000
   ```

   :::warning[Transaction Fees]

   When transferring from the P to the C-chain, transaction fees are paid from BOTH chains.
   Make sure you leave enough funds on both chains after the transfer, or it will fail.

   :::

3. Again, the transfer between the two chains require you to confirm two transactions.

   ```plaintext
   // highlight-next-line
   Please approve export transaction
   Using network: flare
   Fetching account from ledger...
   Creating export transaction...
   Please review and sign the transaction on your ledger device...
   Sending transaction to the node...
   Transaction with id ‚óè‚óè‚óè‚óè‚óè‚óè‚óè‚óè sent to the node
   // highlight-next-line
   Please approve import transaction
   Using network: flare
   Fetching account from ledger...
   Creating export transaction...
   Using fee of 0.00028075 FLR
   Please review and sign the transaction on your ledger device...
   Sending transaction to the node...
   Transaction with id ‚óè‚óè‚óè‚óè‚óè‚óè‚óè‚óè sent to the node
   Finished execution
   ```

If you encounter any problem, see the [Troubleshooting](#troubleshooting) section.

## Claiming rewards

At the end of every reward epoch, participants are rewarded according to how well their chosen validator performed in that period, but these rewards are not claimable yet. Every 4 reward epochs, rewards are accumulated in a dedicated smart contract and can then be claimed from the Flare Stake CLI tool:

1. Select the **Claim Rewards** option when executing:

   ```bash
   flare-stake-tool interactive
   ```

   You are shown the amount of pending rewards (in wei) and are asked how much you want to claim (in FLR):

   ```plaintext
   ? What do you want to do? Claim Rewards
   Checking your Rewards status...
   You have unclaimed rewards worth 1000000000000000000
   ? Enter amount to claim (in FLR): 1
   ```

2. Select **Receive with another wallet** and enter the C-chain address where you want the rewards to be sent.
   This can be the same address from where you are staking.

   ```plaintext
   ? Where do you want to receive your rewards? Receive with another wallet
   ? Please enter the C-address where you want to receive your rewards: 0x‚óè‚óè‚óè‚óè‚óè‚óè‚óè‚óè
   ```

   You are then asked to confirm the staking transaction on your hardware wallet.

   ```text hl_lines=""1""
   Please sign the transaction on your ledger
   Submitting txn to the chain
   Rewards successfully claimed
   Finished execution
   ```

## Troubleshooting

- **Cannot connect to Ledger device, No Device, Cannot retrieve addresses, or similar**

  Make sure:

  - The device is connected, the Avalanche app is opened, and it shows the ""Avalanche Ready"" message.
  - No other application like Ledger Live or MetaMask is connected to the device.
  - The device is not in stand-by mode.
  - You are not running on Windows from a Linux terminal (WSL). Use a native Windows console instead.

- **Insufficient funds**

  Make sure enough funds will remain after a transaction to pay for the transaction fees. If too much time has elapsed between the transaction's creation and its confirmation on the Ledger, the calculated fee might be incorrect.
  Try the operation again. The network might be congested and the calculated fees might not be high enough. Try the operation again after a while.

- **Import transaction failed and the funds have vanished**

  Transfer operations require [an export and an import transaction](#move-funds-to-p-chain).
  If the export succeeds, but then the import fails, it looks like the funds have disappeared from both chains, but they are still retrievable.

  Repeat the failed import operation manually:

  - If you are moving funds from the C-chain to the P-chain:

    ```bash
    flare-stake-tool transaction importCP --ledger --blind
    ```

  - If you are moving funds from the P-chain to the C-chain:

    ```bash
    flare-stake-tool transaction importPC --ledger --blind
    ```

- **Unsupported digital routines**

  If you get the following error message:

  ```text
  E: Error: error:0308010C:digital envelope routines::unsupported
  ```

  Make sure you are using the correct Node.js version, as advised in the [Prerequisites section](#prerequisites).

  You can find out the version of Node.js you are running with the following command:

  ```bash
  node --version
  ```

- **Manual registration using the block explorer**

  - Retrieve the public key that generated the accounts you want to use.
    From a terminal, run `flare-stake-tool info addresses` and copy the long hexadecimal string starting with `0x` in the last line.

    ```plaintext
    Using network: flare
    Addresses on the network ""flare""
    P-chain address: P-flare‚óè‚óè‚óè‚óè‚óè‚óè‚óè‚óè
    C-chain address hex: 0x‚óè‚óè‚óè‚óè‚óè‚óè‚óè‚óè
    // highlight-next-line
    secp256k1 public key: 0x‚óè‚óè‚óè‚óè‚óè‚óè‚óè‚óè‚óè‚óè‚óè‚óè‚óè‚óè‚óè‚óè
    ```

  - You need to interact with the `AddressBinder` smart contract, so you must retrieve its address from the `FlareContractRegistry`.
  - Enter the address of the `AddressBinder` contract in the block explorer, and go to the **Write Contract** tab.
  - Click on **Connect Wallet**. You do not need to use the same account as the one you are binding.
  - Locate the `registerPublicKey` method and paste the public key from step 1 into the `_publicKey` field.
  - Click on **Write** and confirm the transaction from your wallet.

  If the transaction is successful, your account's P-chain and C-chain addresses are now bound.

- **Manual Reward Claiming**

  Rewards can also be claimed directly from the `ValidatorRewardManager` contract that accumulates them:

  - You need to interact with the `ValidatorRewardManager` smart contract, so you must retrieve its address from the `FlareContractRegistry`.
  - Enter the address of the `ValidatorRewardManager` contract in the block explorer, and go to the **Write Contract** tab.
  - Click on **Connect Wallet**.
    You need to connect the account for which you are claiming.
  - Locate the `claim` method and enter the following information:

    - `_rewardOwner`: C-chain address that accrued the rewards.
    - `_recipient`: Address where the rewards must be sent.
    - `_rewardAmount`: Amount to claim. Find the pending amount using the `getStateOfRewards` method in the **Read Contract** tab.
    - `_wrap`: Whether the rewards should be also wrapped, as a convenience.

  - Click on **Write** and confirm the transaction from your wallet.

  If the transaction is successful, the reward is transferred to the specified recipient.",2025-03-08 01:27:14
flare-for-python-developers.mdx,"slug: flare-for-python-developers
title: Flare for Python Devs
authors: [dineshpinto]
description: Learn how to interact with Flare using web3.py.
tags: [python, quickstart, solidity]
keywords: [python, web3.py, quickstart, solidity, smart-contract, flare-network]
sidebar_position: 3","import Tabs from ""@theme/Tabs"";
import TabItem from ""@theme/TabItem"";
import CodeBlock from ""@theme/CodeBlock"";
import FtsoV2FeedConsumerNoImports from ""!!raw-loader!/examples/developer-hub-solidity/FtsoV2FeedConsumer_no_imports.sol"";
import ChainIdCoston2 from ""!!raw-loader!/examples/developer-hub-python/chain_id_coston2.py"";
import ChainIdFlare from ""!!raw-loader!/examples/developer-hub-python/chain_id_flare.py"";
import FetchAbiCoston2 from ""!!raw-loader!/examples/developer-hub-python/fetch_abi_coston2.py"";
import FetchAbiFlare from ""!!raw-loader!/examples/developer-hub-python/fetch_abi_flare.py"";
import MakeQueryCoston2 from ""!!raw-loader!/examples/developer-hub-python/make_query_coston2.py"";
import MakeQueryFlare from ""!!raw-loader!/examples/developer-hub-python/make_query_flare.py"";
import CreateAccount from ""!!raw-loader!/examples/developer-hub-python/create_account.py"";
import DeployContractCoston2 from ""!!raw-loader!/examples/developer-hub-python/deploy_contract_coston2.py"";
import DeployContractFlare from ""!!raw-loader!/examples/developer-hub-python/deploy_contract_flare.py"";
import Utils from ""!!raw-loader!/examples/developer-hub-python/utils.py"";
import CompileContract from ""!!raw-loader!/examples/developer-hub-python/compile_contract.py"";

This guide is for developers who want to interact with Flare using Python. In this guide, using Python, you will learn how to:

- Query a contract on Flare using [web3.py](https://github.com/ethereum/web3.py), an async/sync library for interacting with Ethereum-like chains.
- Compile a Solidity contract using [py-solc-x](https://github.com/ApeWorX/py-solc-x), a wrapper around the Solidity compiler.
- Deploy your compiled contract on Flare.

:::tip

All examples in this guide are available at [developer-hub/examples](https://github.com/flare-foundation/developer-hub/tree/main/examples).

:::

## Getting started

<Tabs groupId=""python"">
  <TabItem value=""uv"" label=""uv"" default>

    ```bash
    uv add web3 py-solc-x
    ```

  </TabItem>
  <TabItem value=""pip"" label=""pip"">
  
    ```bash
    pip install web3 py-solc-x
    ```

  </TabItem>
</Tabs>

### Usage

You need to connect to testnet or mainnet via an RPC, any RPC listed on the [Network Configuration](/network/overview#configuration) page will work. For this guide, you can use the Public RPC.

<Tabs groupId=""network"">
  <TabItem value=""coston2"" label=""Flare Testnet Coston2"" default>

    <CodeBlock language=""python"" title=""chain_id.py"">
      {ChainIdCoston2}
    </CodeBlock>

  </TabItem>
  <TabItem value=""flare"" label=""Flare Mainnet"">

    <CodeBlock language=""python"" title=""chain_id.py"">
      {ChainIdFlare}
    </CodeBlock>

  </TabItem>
</Tabs>

## Querying a contract

To query a contract, two pieces of information are required:

- Contract address
- Contract ABI (Application Binary Interface)

For this example, you can query the `FlareContractRegistry` contract which has the same address `0xaD67FE66660Fb8dFE9d6b1b4240d8650e30F6019` across both testnet and mainnet.

### Fetch ABI

To fetch a contract's ABI programmatically, you can query the [Flare Blockchain Explorer API](https://flare-explorer.flare.network/api-docs):

<Tabs groupId=""network"">
  <TabItem value=""coston2"" label=""Flare Testnet Coston2"" default>

    <CodeBlock language=""python"" title=""fetch_abi.py"">
      {FetchAbiCoston2}
    </CodeBlock>

  </TabItem>
  <TabItem value=""flare"" label=""Flare Mainnet"">
 
    <CodeBlock language=""python"" title=""fetch_abi.py"">
      {FetchAbiFlare}
    </CodeBlock>

  </TabItem>
</Tabs>

### Make query

You can now query the `FlareContractRegistry` contract to get the addresses of other Flare contracts.

For example, querying it for the address of the `WNat` contract:

<Tabs groupId=""network"">
  <TabItem value=""coston2"" label=""Flare Testnet Coston2"" default>
 
    <CodeBlock language=""python"" title=""make_query.py"">
      {MakeQueryCoston2}
    </CodeBlock>

  </TabItem>
  <TabItem value=""flare"" label=""Flare Mainnet"">

    <CodeBlock language=""python"" title=""make_query.py"">
      {MakeQueryFlare}
    </CodeBlock>

  </TabItem>
</Tabs>

## Compiling a contract

For this example, you can use the `FtsoV2FeedConsumer` contract to query the FTSOv2 feeds. Copy the `FtsoV2FeedConsumer` sample contract code given below, and save the `.sol` file in the same folder as your Python script.

<details>
<summary>`FtsoV2FeedConsumer` sample contract</summary>

Note that the contract interface dependencies have been inlined to avoid any import issues.

<CodeBlock language=""solidity"" title=""FtsoV2FeedConsumer.sol"">
  {FtsoV2FeedConsumerNoImports}
</CodeBlock>

</details>

### Set up utils

To compile the contracts, you need to first set up some basic helper functions to read the `.sol` file and write the compiled output to a `.json` file. In a `utils.py` file, you can define the following functions:

<CodeBlock language=""python"" title=""utils.py"">
  {Utils}
</CodeBlock>

### Compile with py-solc-x

With these functions ready, you can now compile the contract. In a `compile_contract.py` file, you can define the following code to install the correct version of the Solidity compiler and compile the contract:

<CodeBlock language=""python"" title=""compile_contract.py"">
  {CompileContract}
</CodeBlock>

You can now run the `compile_contract.py` script to compile the contract. The compiled output will be saved to `FtsoV2FeedConsumer.json`.

<Tabs groupId=""python"">
  <TabItem value=""uv"" label=""uv"" default>

    ```bash
    uv run compile_contract.py
    ```

  </TabItem>
  <TabItem value=""pip"" label=""pip"">
    ```bash 
    python compile_contract.py 
    ```

  </TabItem>
</Tabs>

## Create account

Before deploying a contract, you need to have an account with some testnet or mainnet gas tokens. You can create a new Flare account from the CLI:

<CodeBlock language=""python"" title=""create_account.py"">
  {CreateAccount}
</CodeBlock>

This will output a new private key and an account pair.

:::danger

- Never share your private keys.
- Never put your private keys in source code.
- Never commit private keys to a Git repository.

:::

You can save the account and private key into environment variables `ACCOUNT` and `ACCOUNT_PRIVATE_KEY` respectively.

```bash
export ACCOUNT=<address above>
export ACCOUNT_PRIVATE_KEY=<private key above>
```

:::note

You can also import the raw hex private key to MetaMask and any other wallet - the private key can be shared between your Python code and any number of wallets.

:::

- For testnet, you can get free testnet C2FLR on the [Coston2 Faucet](https://faucet.flare.network/coston2).
- For mainnet you will need to fund the account with FLR. You can buy FLR with regular currency in places like centralized exchanges, crypto on-ramps, or swap other tokens for FLR on decentralized exchanges.

## Deploying with web3.py

With the functions and account ready, you can now deploy the contract. In a `deploy_contract.py` file, you can define the following code to deploy the contract:

<Tabs groupId=""network"">
  <TabItem value=""coston2"" label=""Flare Testnet Coston2"" default>

    <CodeBlock language=""python"" title=""deploy_contract.py"">
      {DeployContractCoston2}
    </CodeBlock>

  </TabItem>
  <TabItem value=""flare"" label=""Flare Mainnet"">

    <CodeBlock language=""python"" title=""deploy_contract.py"">
      {DeployContractFlare}
    </CodeBlock>

  </TabItem>
</Tabs>

You can now run the `deploy_contract.py` script to deploy the contract. The contract address will be printed once the deployment is successful. You can check the contract address on a Flare Blockchain Explorer, linked on the [Network Configuration](/network/overview#configuration) page.

<Tabs groupId=""python"">
  <TabItem value=""uv"" label=""uv"" default>
    ```bash 
    uv run deploy_contract.py 
    ```

  </TabItem>
  <TabItem value=""pip"" label=""pip"">
    ```bash 
    python deploy_contract.py 
    ```
    
  </TabItem>
</Tabs>

Congratulations! You have now successfully deployed a contract on Flare using Python üêç.

:::tip[What's next?]

Learn how to interact with Flare's enshrined oracle [FTSOv2 using Python](/ftso/guides/read-feeds-offchain).

:::",2025-03-08 01:27:14
flare-for-javascript-developers.mdx,"slug: flare-for-javascript-developers
title: Flare for JavaScript Devs
authors: [dineshpinto]
description: Learn how to interact with Flare using web3.js.
tags: [javascript, quickstart, solidity]
keywords:
  [
    javascript,
    web3.js,
    ethers.js,
    quickstart,
    solidity,
    smart-contract,
    flare-network,
  ]
sidebar_position: 2","import Tabs from ""@theme/Tabs"";
import TabItem from ""@theme/TabItem"";
import CodeBlock from ""@theme/CodeBlock"";
import FtsoV2FeedConsumerNoImports from ""!!raw-loader!/examples/developer-hub-solidity/FtsoV2FeedConsumer_no_imports.sol"";
import ChainIdCoston2 from ""!!raw-loader!/examples/developer-hub-javascript/chain_id_coston2.js"";
import ChainIdFlare from ""!!raw-loader!/examples/developer-hub-javascript/chain_id_flare.js"";
import FetchAbiCoston2 from ""!!raw-loader!/examples/developer-hub-javascript/fetch_abi_coston2.js"";
import FetchAbiFlare from ""!!raw-loader!/examples/developer-hub-javascript/fetch_abi_flare.js"";
import MakeQueryCoston2 from ""!!raw-loader!/examples/developer-hub-javascript/make_query_coston2.js"";
import MakeQueryFlare from ""!!raw-loader!/examples/developer-hub-javascript/make_query_flare.js"";
import CreateAccount from ""!!raw-loader!/examples/developer-hub-javascript/create_account.js"";
import DeployContractCoston2 from ""!!raw-loader!/examples/developer-hub-javascript/deploy_contract_coston2.js"";
import DeployContractFlare from ""!!raw-loader!/examples/developer-hub-javascript/deploy_contract_flare.js"";

This guide is for developers who want to interact with Flare using JavaScript. In this guide, using JavaScript, you will learn how to:

- Query a contract on Flare using [web3.js](https://github.com/web3/web3.js), an async/sync library for interacting with Ethereum-like chains.
- Compile a Solidity contract using the CLI interface of [solc](https://github.com/ethereum/solidity), the Solidity compiler.
- Deploy your compiled contract on Flare.

:::tip

All examples in this guide are available at [developer-hub/examples](https://github.com/flare-foundation/developer-hub/tree/main/examples).

:::

## Getting started

Install the Solidity compiler by following the instructions in the [Solidity documentation](https://docs.soliditylang.org/en/latest/installing-solidity.html#linux-packages). The main commands are provided here:

<Tabs>
  <TabItem value=""macos"" label=""MacOS via Homebrew"" default>

    ```bash
    brew tap ethereum/ethereum
    brew install solidity
    ```

  </TabItem>
  <TabItem value=""ubuntu"" label=""Ubuntu via PPAs"">

    ```bash
    sudo add-apt-repository -y ppa:ethereum/ethereum
    sudo apt update
    sudo apt install solc
    ```

  </TabItem>
</Tabs>

Install web3.js using either `npm` or `yarn`:

<Tabs groupId=""js"">
  <TabItem value=""npm"" label=""npm"" default>

    ```bash
    npm install web3
    ```

  </TabItem>
  <TabItem value=""yarn"" label=""yarn"">
  
    ```bash
    yarn add web3
    ```

  </TabItem>
</Tabs>

### Usage

You need to connect to testnet or mainnet via an RPC, any RPC listed on the [Network Configuration](/network/overview#configuration) page will work. For this guide, you can use the Public RPC.

<Tabs groupId=""network"">
  <TabItem value=""coston2"" label=""Flare Testnet Coston2"" default>

    <CodeBlock language=""javascript"" title=""chainId.js"">
      {ChainIdCoston2}
    </CodeBlock>

  </TabItem>
  <TabItem value=""flare"" label=""Flare Mainnet"">

    <CodeBlock language=""javascript"" title=""chainId.js"">
      {ChainIdFlare}
    </CodeBlock>

  </TabItem>
</Tabs>

## Querying a contract

To query a contract, two pieces of information are required:

- Contract address
- Contract ABI (Application Binary Interface)

For this example, you can query the `FlareContractRegistry` contract which has the same address `0xaD67FE66660Fb8dFE9d6b1b4240d8650e30F6019` across both testnet and mainnet.

### Fetch ABI

To fetch a contract's ABI programmatically, you can query the [Flare Blockchain Explorer API](https://flare-explorer.flare.network/api-docs):

<Tabs groupId=""network"">
  <TabItem value=""coston2"" label=""Flare Testnet Coston2"" default>

    <CodeBlock language=""javascript"" title=""fetchAbi.js"">
      {FetchAbiCoston2}
    </CodeBlock>

  </TabItem>
  <TabItem value=""flare"" label=""Flare Mainnet"">

    <CodeBlock language=""javascript"" title=""fetchAbi.js"">
      {FetchAbiFlare}
    </CodeBlock>

  </TabItem>
</Tabs>

### Make query

You can now query the `FlareContractRegistry` contract to get the addresses of other Flare contracts.

For example, querying it for the address of the `WNat` contract:

<Tabs groupId=""network"">
  <TabItem value=""coston2"" label=""Flare Testnet Coston2"" default>

    <CodeBlock language=""javascript"" title=""makeQuery.js"">
      {MakeQueryCoston2}
    </CodeBlock>

  </TabItem>
  <TabItem value=""flare"" label=""Flare Mainnet"">

    <CodeBlock language=""javascript"" title=""makeQuery.js"">
      {MakeQueryFlare}
    </CodeBlock>

  </TabItem>
</Tabs>

## Compiling with solc

For this example, you can use the `FtsoV2FeedConsumer` contract to query the FTSOv2 feeds. Copy the `FtsoV2FeedConsumer` sample contract code given below, and save the `.sol` file in the same folder as your `package.json`.

<details>
<summary>`FtsoV2FeedConsumer` sample contract</summary>

Note that the contract interface dependencies have been inlined to avoid any import issues.

<CodeBlock language=""solidity"" title=""FtsoV2FeedConsumer.sol"">
  {FtsoV2FeedConsumerNoImports}
</CodeBlock>

</details>

```bash
solc --evm-version london FtsoV2FeedConsumer.sol --abi --bin -o build
```

This will generate two files `build/FtsoV2FeedConsumer.abi` and `build/FtsoV2FeedConsumer.bin` files with the contract's ABI and bytecode. Rename `FtsoV2FeedConsumer.abi` to `FtsoV2FeedConsumer.json`.

## Create account

Before deploying a contract, you need to have an account with some testnet or mainnet gas tokens. You can create a new Flare account using `createAccount.js`:

<CodeBlock language=""javascript"" title=""createAccount.js"">
  {CreateAccount}
</CodeBlock>

This will output a new private key and an account pair.

:::danger

- Never share your private keys.
- Never put your private keys in source code.
- Never commit private keys to a Git repository.

:::

You can save the account and private key into environment variables `ACCOUNT` and `ACCOUNT_PRIVATE_KEY` respectively.

:::note

You can also import the raw hex private key to MetaMask and any other wallet - the private key can be shared between your JavaScript code and any number of wallets.

:::

- For testnet, you can get free testnet C2FLR on the [Coston2 Faucet](https://faucet.flare.network/coston2).
- For mainnet you will need to fund the account with FLR. You can buy FLR with regular currency in places like centralized exchanges, crypto on-ramps, or swap other tokens for FLR on decentralized exchanges.

## Deploying with web3.js

With the account ready, you can now deploy the contract. In a `deployContract.js` file, you can define the following code to deploy the contract:

<Tabs groupId=""network"">
  <TabItem value=""coston2"" label=""Flare Testnet Coston2"" default>

    <CodeBlock language=""javascript"" title=""deployContract.js"">
      {DeployContractCoston2}
    </CodeBlock>

    </TabItem>

  <TabItem value=""flare"" label=""Flare Mainnet"">

    <CodeBlock language=""javascript"" title=""deployContract.js"">
      {DeployContractFlare}
    </CodeBlock>

  </TabItem>
</Tabs>

You can now run the `deployContract.js` script to deploy the contract. The contract address will be printed once the deployment is successful. You can check the contract address on a Flare Blockchain Explorer, linked on the [Network Configuration](/network/overview#configuration) page.

Congratulations! You have now successfully deployed a contract on Flare using JavaScript.

:::tip[What's next?]

Learn how to interact with Flare's enshrined oracle [FTSOv2 using JavaScript](/ftso/guides/read-feeds-offchain).

:::",2025-03-08 01:27:14
0-onboarding.mdx,"sidebar_position: 1
unlisted: false
slug: onboarding
title: Onboarding
description: Step-by-step guide for setting up infrastructure, credentials, and cloud instances for the Verifiable AI Hackathon.
keywords: [flare, ai, confidential-compute, hackathon, google-cloud, onboarding]","import ThemedImage from ""@theme/ThemedImage"";
import useBaseUrl from ""@docusaurus/useBaseUrl"";
import AccessGranted from ""/static/img/verifiable-ai-hackathon/access-granted.png"";
import ChooseTemplate from ""/static/img/verifiable-ai-hackathon/choose-template.png"";
import GeminiKey from ""/static/img/verifiable-ai-hackathon/gemini-key.png"";
import OnboardingChecklist from ""@site/src/components/hackathon/OnboardingChecklist"";
import CreateKey from ""/static/img/verifiable-ai-hackathon/create-key.png"";
import PackageSetting from ""/static/img/verifiable-ai-hackathon/package-setting.png"";
import PackageView from ""/static/img/verifiable-ai-hackathon/package-view.png"";
import ChangeVisibility from ""/static/img/verifiable-ai-hackathon/change-visibility.png"";

# Onboarding

Welcome to the **Verifiable AI Hackathon**! üéâ

This guide walks you through the **four-step setup** to ensure you have the necessary access and tools to start building.

<OnboardingChecklist />

## Before You Begin

- **Estimated Time:** ~15-20 minutes
- **Need Help?** Join our [Telegram Support Group](https://t.me/+StI5VEIvtIg2ODlh)

## Step 1: Set up your Google account

### Prerequisites

- A Google account (existing or newly created) - this will be your access point for all hackathon resources

### Registration & access

1. Submit your Google account email during hackathon registration (i.e. the Google Form you submitted)
2. Access to the `verifiable-ai-hackathon` Google Cloud project will be granted on **March 6th** (i.e. one day before the hackathon)
3. Verify your access by visiting the [Google Cloud Console](https://console.cloud.google.com/welcome?project=verifiable-ai-hackathon), when access is granted you will see the following confirmation:

   <img src={AccessGranted} style={{ width: 600 }} />

## Step 2: Set up API credentials

### Gemini API Keys

1. Log into your registered Google account after you receive access to the `verifiable-ai-hackathon` Google Cloud project
2. Visit the [Get a Gemini API key](https://aistudio.google.com/app/apikey) page
3. Click on **Create API key** and select `verifiable-ai-hackathon` from the dropdown

   <img src={GeminiKey} style={{ width: 600 }} />

4. Click **Create API key in existing project**

   <img src={CreateKey} style={{ width: 600 }} />

5. **Store your API key securely**

<details>
<summary>OpenRouter API Keys (Consensus Learning Track Only)</summary>

If you're participating in the Consensus Learning track:

1. Visit [OpenRouter](https://openrouter.ai) and create a free account
2. Navigate to the [Settings page](https://openrouter.ai/settings/keys) to generate your free API keys
3. **Need higher limits?** Contact the Flare team on [Telegram](https://t.me/+StI5VEIvtIg2ODlh) with your team and VM instance name

</details>

## Step 3: Install & configure gcloud CLI

### Install gcloud CLI

1. Follow the [gcloud CLI installation guide](https://cloud.google.com/sdk/docs/install) for Windows, macOS, or Linux.

2. **Check installation:**

   ```bash
   gcloud version
   ```

### Authenticate & verify access

1. **Authenticate your CLI**

   Authenticate using the same Google account used for hackathon registration:

   ```bash
   gcloud auth login
   ```

2. **Verify project access:**

   ```bash
   gcloud projects list
   ```

   The output should include `verifiable-ai-hackathon`

## Step 4: Select your track template

### Prerequisites

Ensure you have the following tools installed:

- [git](https://git-scm.com/downloads)
- [uv](https://docs.astral.sh/uv/getting-started/installation/) (Python dependency management)
- [Docker](https://www.docker.com) (for containerization)
- [npm](https://nodejs.org/en/download) (for Social AI Agents & AI x DeFi tracks only)

### Choose your template

| Track              | Template Repository                                                                         |
| ------------------ | ------------------------------------------------------------------------------------------- |
| Social AI Agents   | [`flare-foundation/flare-ai-social`](https://github.com/flare-foundation/flare-ai-social)   |
| RAG Knowledge      | [`flare-foundation/flare-ai-rag`](https://github.com/flare-foundation/flare-ai-rag)         |
| AI x DeFi (DeFAI)  | [`flare-foundation/flare-ai-defai`](https://github.com/flare-foundation/flare-ai-defai)     |
| Consensus Learning | [`flare-research/flare-ai-consensus`](https://github.com/flare-research/flare-ai-consensus) |

### Clone & start building

1. Navigate to the template, and click on **Use this template** ‚Üí **Create a new repository**

   <img src={ChooseTemplate} style={{ width: 300 }} />

2. After creating a new repository, wait for package build to complete (a few minutes). Then click on the built package in the right sidebar:

   <img src={PackageView} style={{ width: 300 }} />

3. Click **Package Settings** in the right sidebar:

   <img src={PackageSetting} style={{ width: 300 }} />

4. Under **Danger Zone**, click **Change Visibility** and set to **Public**:

   <img src={ChangeVisibility} style={{ width: 800 }} />

5. **Clone the repo:**

   ```bash
   git clone https://github.com/YOUR_REPO
   cd YOUR_REPO
   ```

6. Follow the **README** in your chosen template for track-specific setup instructions

**Happy building!**

:::danger[Using hackathon compute resources]

VM instances in `verifiable-ai-hackathon` are continuously monitored.

**Any attempt** to use compute resources for activities outside the hackathon will result in immediate instance termination and possible suspension or permanent ban of account access privileges.

:::

## Troubleshooting

- **Unable to create Gemini API Key in `verifiable-ai-hackathon`:**

  - Ensure you're logged into the exact Google account you registered with (i.e. the Google Form you submitted)
  - Wait 5-10 minutes after receiving project access before attempting
  - Clear browser cache or try in a private/incognito window

- **gcloud CLI Authentication Problems:**

  - If the browser auth flow fails:

    ```bash
    gcloud auth login --no-launch-browser
    ```

  - Check if you have multiple Google accounts in your browser and select the correct one

- **Windows-specific gcloud issues**

  - On Windows, when installing the gcloud CLI, gcloud installs its own basic shell as well.
  - We recommend using [git BASH](https://gitforwindows.org) for access to a full set of linux commands.

- **Multiple GCP Projects**

  - Set `verifiable-ai-hackathon` as default GCP project:

    ```bash
    gcloud config set project verifiable-ai-hackathon
    ```

  - Set quota to use `verifiable-ai-hackathon`:

    ```bash
    gcloud auth application-default set-quota-project verifiable-ai-hackathon
    ```

## Need Help?

If you're stuck, reach out to the Flare team on [Telegram](https://t.me/+StI5VEIvtIg2ODlh). Include:

- Your **team name**
- Your **VM instance name**
- Screenshots of errors
- Steps you've already attempted",2025-03-08 01:27:14
1-cookbook.mdx,"sidebar_position: 2
unlisted: false
title: Cookbook
description: Cookbook commands for managing Confidential VMs.
keywords: [flare, ai, confidential-compute, hackathon, google-cloud, onboarding]","import ConfidentialVMBuilder from ""@site/src/components/hackathon/ConfidentialVMBuilder"";

Reference for commands you will encounter when interacting with Confidential VMs.

## Confidential Space command builder

Use this interactive builder to generate the exact Confidential Space VM deploy command you need.

:::warning[Source your .env file]

Before running the following gcloud command don't forget to source your `.env` file:

```bash
source .env
```

:::

<ConfidentialVMBuilder />

## Restarting VMs

During testing, you often need to restart a VM to pull updated docker images.

Use the following two commands (ensure you have the `gcloud` CLI installed and configured):

1. **Stop the VM:**

   ```bash
   gcloud compute instances stop $INSTANCE_NAME
   ```

2. **Start the VM:**

   ```bash
   gcloud compute instances start $INSTANCE_NAME
   ```

   - Replace `$INSTANCE_NAME` with the actual name of your VM instance.

## Reading logs

When you need to read logs for a single Google Compute Engine (GCE) VM instance using the `gcloud` CLI, you'll primarily interact with Cloud Logging. Here's how you can do it, combining filtering with the appropriate `gcloud` commands:

```bash
gcloud logging read ""resource.type=gce_instance AND resource.labels.instance_id=YOUR_INSTANCE_ID"" --project=verifiable-ai-hackathon
```

- Replace `YOUR_INSTANCE_ID` with the actual instance ID of your VM.
- Replace `YOUR_VM_NAME` with the name of your VM.
- Replace `YOUR_ZONE` with the zone your VM is in.

:::tip[Using GCP Console]

You can also view logs in the Google Cloud Console by navigating to the Logging section and selecting your project.

:::

## Deploying on AMD SEV

This command creates a Confidential Space VM instance using AMD SEV ([Secure Encrypted Virtualization](https://www.amd.com/content/dam/amd/en/documents/epyc-business-docs/white-papers/memory-encryption-white-paper.pdf)), with a specific image, network configuration, and security settings.
The metadata section is critical for configuring the Trusted Execution Environment (TEE).
The command is broken down in the following sections.

```bash
# highlight-next-line
gcloud compute instances create $INSTANCE_NAME \
  --project=verifiable-ai-hackathon \
  --zone=us-central1-c \
  --machine-type=n2d-standard-2 \
  --network-interface=network-tier=PREMIUM,nic-type=GVNIC,stack-type=IPV4_ONLY,subnet=default \
  # highlight-next-line
  --metadata=tee-image-reference=$TEE_IMAGE_REFERENCE,\
  # highlight-next-line
  tee-container-log-redirect=true,\
  # highlight-next-line
  tee-env-<ENV_VAR_NAME1>=<ENV_VAR_VALUE1>,tee-env-<ENV_VAR_NAME2>=<ENV_VAR_VALUE2>\
  --maintenance-policy=MIGRATE \
  --provisioning-model=STANDARD \
  --service-account=confidential-sa@flare-network-sandbox.iam.gserviceaccount.com \
  --scopes=https://www.googleapis.com/auth/cloud-platform \
  --min-cpu-platform=""AMD Milan"" \
  --tags=flare-ai-core,http-server,https-server \
  --create-disk=auto-delete=yes,boot=yes,\
  device-name=$INSTANCE_NAME,\
  # highlight-next-line
  image=projects/confidential-space-images/global/images/confidential-space-debug-250100,mode=rw,size=11,type=pd-standard \
  --shielded-secure-boot \
  --shielded-vtpm \
  --shielded-integrity-monitoring \
  --labels=goog-ec-src=vm_add-gcloud \
  --reservation-affinity=any \
  # highlight-next-line
  --confidential-compute-type=SEV
```

### Core command & instance name

```bash
gcloud compute instances create $INSTANCE_NAME \
```

- `gcloud compute instances create`: This is the base command for creating a new Compute Engine virtual machine (VM) instance.
- `$INSTANCE_NAME`: You need to replace this with the desired name for your VM instance.

### Project and zone

```bash
  --project=verifiable-ai-hackathon \
  --zone=us-central1-c \
```

- `--project=verifiable-ai-hackathon`: Specifies the Google Cloud project where the VM will be created.
- `--zone=us-central1-c`: Defines the zone within the `us-central1` region where the instance will reside. Choosing a zone is important for latency and resource availability.

### Machine type & network configuration

```bash
  --machine-type=n2d-standard-2 \
  --network-interface=network-tier=PREMIUM,nic-type=GVNIC,stack-type=IPV4_ONLY,subnet=default \
```

- `--machine-type=n2d-standard-2`: Selects the machine type, which determines the CPU, memory, and other hardware resources allocated to the VM. `n2d-standard-2` indicates a machine with 2 vCPUs and a balanced amount of memory, using AMD processors.
- `--network-interface=network-tier=PREMIUM,nic-type=GVNIC,stack-type=IPV4_ONLY,subnet=default`: Configures the network interface:
  - `network-tier=PREMIUM`: Uses Google's premium network tier for better performance.
  - `nic-type=GVNIC`: Uses Google Virtual NIC for better network performance.
  - `stack-type=IPV4_ONLY`: Specifies that the instance will use IPv4 only.
  - `subnet=default`: Attaches the instance to the default subnet in the specified zone's VPC network.

### Metadata (crucial for Confidential Computing)

```bash
  --metadata=tee-image-reference=$TEE_IMAGE_REFERENCE,tee-container-log-redirect=true,tee-env-<ENV_VAR_NAME1>=<ENV_VAR_VALUE1>,tee-env-<ENV_VAR_NAME2>=<ENV_VAR_VALUE2>\
```

- This section is very important for Confidential Computing. Metadata is used to pass configuration data to the VM.
  - `tee-image-reference=$TEE_IMAGE_REFERENCE`: Specifies the URL of the Trusted Execution Environment (TEE) image. This is essential for enabling confidential computing. Replace `$TEE_IMAGE_REFERENCE` with the actual image URL.
  - `tee-container-log-redirect=true`: Enables redirecting container logs to both Cloud Logging and serial logging, which can be helpful for debugging.
  - `tee-env-<ENV_VAR_NAME1>=<ENV_VAR_VALUE1>,tee-env-<ENV_VAR_NAME2>=<ENV_VAR_VALUE2>`: Sets environment variables within the TEE environment. Replace `<ENV_VAR_NAME1>`, `<ENV_VAR_VALUE1>`, `<ENV_VAR_NAME2>`, and `<ENV_VAR_VALUE2>` with your desired environment variable names and values. This is how you would pass secrets or other configuration data to the application running inside the TEE.

### Other instance settings

```bash
  --maintenance-policy=MIGRATE \
  --provisioning-model=STANDARD \
  --service-account=confidential-sa@flare-network-sandbox.iam.gserviceaccount.com \
  --scopes=https://www.googleapis.com/auth/cloud-platform \
  --min-cpu-platform=""AMD Milan"" \
  --tags=flare-ai-core,http-server,https-server \
```

- `--maintenance-policy=MIGRATE`: Specifies that the VM should be migrated to another host during maintenance events.
- `--provisioning-model=STANDARD`: Uses the standard provisioning model for the VM.
- `--service-account=confidential-sa@flare-network-sandbox.iam.gserviceaccount.com`: Attaches a service account to the VM, granting it specific permissions.
- `--scopes=https://www.googleapis.com/auth/cloud-platform`: Grants the VM full access to all Google Cloud Platform APIs. **Use with caution** and prefer more granular scopes if possible.
- `--min-cpu-platform=""AMD Milan""`: Ensures that the VM runs on a host with an AMD Milan CPU, which is required for Confidential Computing with SEV.
- `--tags=flare-ai-core,http-server,https-server`: Applies network tags to the VM, which can be used for firewall rules and network routing.

### Boot disk configuration

```bash
  --create-disk=auto-delete=yes,boot=yes,\
  device-name=$INSTANCE_NAME,\
  image=projects/confidential-space-images/global/images/confidential-space-debug-250100,mode=rw,size=11,type=pd-standard \
```

- `--create-disk=...`: Configures the boot disk for the VM.
  - `auto-delete=yes`: The disk will be deleted when the VM is deleted.
  - `boot=yes`: This is the boot disk.
  - `device-name=<INSTANCE_NAME>`: Sets the device name of the disk to the instance name.
  - `image=projects/confidential-space-images/global/images/confidential-space-debug-250100`: Specifies the image to use for the boot disk. This is a confidential space image.
  - `mode=rw`: The disk is mounted in read-write mode.
  - `size=11`: The disk size is 11 GB.
  - `type=pd-standard`: Uses a standard persistent disk.

### Shielded VM options

```bash
  --shielded-secure-boot \
  --shielded-vtpm \
  --shielded-integrity-monitoring \
```

- These options enable Shielded VM features, which enhance the security of the VM.
  - `--shielded-secure-boot`: Enables secure boot.
  - `--shielded-vtpm`: Enables virtual Trusted Platform Module (vTPM).
  - `--shielded-integrity-monitoring`: Enables integrity monitoring.

### Labels, reservation affinity, and confidential compute

```bash
  --labels=goog-ec-src=vm_add-gcloud \
  --reservation-affinity=any \
  --confidential-compute-type=SEV
```

- `--labels=goog-ec-src=vm_add-gcloud`: Adds a label to the VM for tracking purposes.
- `--reservation-affinity=any`: If you have reservations, this allows the VM to use any available reservation.
- `--confidential-compute-type=SEV`: Enables AMD SEV (Secure Encrypted Virtualization) Confidential Computing. This is the core flag that makes this instance a confidential VM.

## Deploying on Intel TDX

This command creates a Confidential Space VM instance using Intel TDX ([Trust Domain Extensions](https://www.intel.com/content/www/us/en/developer/tools/trust-domain-extensions/documentation.html)), with a specific image, network configuration, and security settings.
The command instructions differing from [Deploying AMD SEV Confidential VMs](#deploying-on-amd-sev) are highlighted.

```bash
gcloud compute instances create $INSTANCE_NAME \
  --project=verifiable-ai-hackathon \
  --zone=us-central1-a \
  # highlight-next-line
  --machine-type=c3-standard-4 \
  --network-interface=network-tier=PREMIUM,nic-type=GVNIC,stack-type=IPV4_ONLY,subnet=default \
  --metadata=tee-image-reference=$TEE_IMAGE_REFERENCE,\
  tee-container-log-redirect=true,\
  tee-env-<ENV_VAR_NAME1>=<ENV_VAR_VALUE1>,tee-env-<ENV_VAR_NAME2>=<ENV_VAR_VALUE2>\
  # highlight-next-line
  --maintenance-policy=TERMINATE \
  --provisioning-model=STANDARD \
  --service-account=confidential-sa@verifiable-ai-hackathon.iam.gserviceaccount.com \
  --scopes=https://www.googleapis.com/auth/cloud-platform \
  --tags=flare-ai,http-server,https-server \
  --create-disk=auto-delete=yes,\
boot=yes,\
device-name=$INSTANCE_NAME,\
# highlight-next-line
image=projects/confidential-space-images/global/images/confidential-space-debug-0-tdxpreview-c38b622,\
mode=rw,\
size=11,\
# highlight-next-line
type=pd-balanced \
  --shielded-secure-boot \
  --shielded-vtpm \
  --shielded-integrity-monitoring \
  --reservation-affinity=any \
  # highlight-next-line
  --confidential-compute-type=TDX
```

**Differences:**

- Use the `c3-standard-*` series of machines running on Intel Sapphire Rapids
- Set the maintenance policy to `TERMINATE`, as TDX does not support migration
- Use the preview TDX images of Confidential Space, to see all Confidential Space images run:

  ```bash
  gcloud compute images list --project=confidential-space-images --no-standard-images
  ```

- Set the boot disk to `pd-balanced` as required by `c3-standard-*` series of machines
- Set the confidential compute type to `TDX`

## Setting Up a Static IP for Your Instance

For any questions or assistance with setting up a static IP, please reach out to the Flare team on [Telegram](https://t.me/+StI5VEIvtIg2ODlh).",2025-03-08 01:27:14
whitepapers.mdx,"slug: whitepapers
title: Whitepapers
description: Explore Flare's whitepapers, research, and analytics to gain deeper insights into its technology.
keywords: [whitepaper, research, flare-network, analytics, ftso]
hide_table_of_contents: true","import WhitepapersGrid from ""@site/src/components/WhitepapersGrid"";

Explore Flare's whitepapers, research, and analytics to gain deeper insights into its technology.

<WhitepapersGrid />",2025-03-08 01:27:14
terminology.mdx,"slug: terminology
title: Terminology
description: Definitions of key terms used in the Flare network.
keywords: [terminology, flare-network, definitions]","## Account

An account is a record in the Flare ledger that holds data and facilitates the sending and receiving of tokens. Each account is identified by a unique address derived from a public key. An account can be either an [externally owned account (EOA)](#externally-owned-account-eoa) or a [smart contract](#smart-contract).

## Address

A unique identifier representing an account on the Flare network. Addresses are derived from public keys and are used to send and receive tokens.

## API

Application Programming Interface. A set of rules and protocols that allow different software applications to communicate with each other, enabling integration and interaction.

## Block

A collection of transactions bundled together and added to the blockchain. Blocks are created by validators and are used to record transactions on the network.

## Blockchain

A distributed ledger that records transactions across multiple computers in a secure and tamper-proof way. Each block in the blockchain contains a list of transactions and a reference to the previous block, creating a continuous chain of blocks.

## Bridge

A protocol that connects independent blockchains, enabling interoperability and the transfer of assets and information between them.

## Canary

A network used for testing features under ‚Äúreal fire‚Äù conditions before deploying them on the mainnet. Users of the canary network are real users but are aware of the experimental nature of the platform. The term originates from the practice of using canaries in mines to detect poisonous gas. Flare's canary network is called Songbird.

## Consensus

The process by which a network of nodes agrees on the validity of transactions and the state of the ledger. Consensus mechanisms secure the network and prevent double-spending.

## Delegated Proof of Stake (DPoS)

A consensus mechanism in which token holders vote for validators to secure the network and validate transactions. Validators are elected based on the number of votes they receive from token holders.

## Enshrined Oracle

Enshrining involves incorporating essential middleware components directly into the core protocol of a blockchain network. For a component to be considered enshrined, it **must** require a network hard-fork to be altered (refer to Vitalik's article on [enshrinement](https://vitalik.eth.limo/general/2023/09/30/enshrinement.html)).

Enshrining can be seen as a stronger form of restaking, a concept popularized by protocols like [EigenLayer](http://eigenlayer.xyz). Unlike restaking, where only a fraction of the network stake is used to secure middleware, enshrining leverages the entire network stake.

An enshrined oracle is an oracle that is integrated into the core protocol of a blockchain network. These oracles inherit the full security of the network, meaning that compromising the safety or liveness of the oracle would necessitate compromising the entire network.

## EVM

Ethereum Virtual Machine. A virtual machine that runs smart contracts on the Ethereum network. The EVM is a Turing-complete machine that executes code written in Solidity or other programming languages.

## Externally Owned Account (EOA)

An account controlled by a private key and can send transactions on the network. EOAs are typically used by individuals to manage their tokens.

## Fork

A change in the protocol of a blockchain network that results in two separate chains. Forks can be caused by software updates, consensus rule changes, or network upgrades.

## Gas

A unit of measurement representing the computational work required to execute a transaction on the network. Gas is used to pay for transaction fees and prevent spam.

## Hard Fork

A type of fork that is not backward-compatible with the existing protocol. Hard forks require all nodes to upgrade to the new protocol to continue participating in the network.

## Node

A computer that participates in the Flare network by running software that validates transactions and maintains a copy of the blockchain. Nodes can be validators, data providers, or regular network participants.

## Oracle

A service that provides offchain data to smart contracts on the blockchain. Oracles bring real-world data, such as price feeds, weather information, and sports scores, to the blockchain.

## Smart Contract

An account controlled by code that can send transactions on the network. Smart contracts are self-executing contracts with the terms of the agreement directly written into lines of code.

## Token

A digital asset representing ownership of a physical or virtual asset. Tokens can represent a wide range of assets, including cryptocurrencies, real estate, and intellectual property.

## Transaction

A record of a transfer of tokens or data on the blockchain. Transactions are signed by the sender and include information such as the recipient's address, the amount of tokens transferred, and the gas fee.

## Validator

A node that participates in the consensus process and validates transactions on the network. Validators are responsible for creating new blocks and securing the network.

## Wallet

A software application that allows users to store, send, and receive tokens. Wallets can manage multiple accounts and interact with decentralized applications on the blockchain.",2025-03-08 01:27:14
audits.mdx,"slug: audits
title: Audits
description: Security audits of the Flare Network and its components.
keywords: [audits, security, smart-contracts, flare-network]
hide_table_of_contents: true","| **Auditor** | **Date**  | **Report**                                                                                                                                                             |
| ----------- | --------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Coinspect   | Feb 2025  | [FTSOv2 Custom Feeds](@site/static/pdf/audits/20250205-Coinspect-SmartContractAudit-Flare-FTSOv2CustomFeedsDiffReview-v240210.pdf)                                     |
| Coinspect   | Jan 2025  | [Smart Contract Preregistration](@site/static/pdf/audits/20250101-Coinspect-SmartContractAudit-Flare-Pre-Register&FTSOManagement-v250109.pdf)                          |
| Coinspect   | Dec 2024  | [FAssets Smart Contract Audit V2 Updates](@site/static/pdf/audits/20241215-Coinspect-SmartContractAudit-Flare-FAssetV2Updates-v241217.pdf)                             |
| FYEO        | Oct 2024  | [FlareDA Layer (FTSO & FDC)](@site/static/pdf/audits/20241001-FLARE-SecurityCodeReviewFLAREDataAvailabilityv1.0_Public.pdf)                                            |
| Coinspect   | Oct 2024  | [Verifier servers and FDC updates](@site/static/pdf/audits/20241001-Coinspect-SourceCodeAudit-Flare-FDCv2-v250113.pdf)                                                 |
| Coinspect   | Sep 2024  | [FAssets Smart Contract Audit](@site/static/pdf/audits/20240901-Coinspect-SmartContractAudit-Flare-FassetUpdate-v240910.pdf)                                           |
| Coinspect   | Aug 2024  | [FDC Client](@site/static/pdf/audits/20240801-Coinspect-Source_Code_Audit-Flare-FDCv1-v241004.pdf)                                                                     |
| Coinspect   | June 2024 | [rNat (rFLR) smart contracts](@site/static/pdf/audits/20240601-Coinspect-SmartContractSecurityReview-Flare-RNatContracts-v240701.pdf)                                  |
| FYEO        | June 2024 | [Lowering gas limit for Songbird](@site/static/pdf/audits/20240601-FYEO-Flare-Ongoing_Songbird_June_20th_1.0_Public.docx.pdf)                                          |
| FYEO        | June 2024 | [Flare upgrade to Avalanche 1.9.0](@site/static/pdf/audits/20240601-FYEO-Flare-Ongoing_Songbird_June_10th_1.0_Public.pdf)                                              |
| FYEO        | May 2024  | [Songbird codebase integration into Flare](@site/static/pdf/audits/20240501-FYEO-FlareOngoingSongbird1.0_Public.pdf)                                                   |
| Coinspect   | May 2024  | [Voter Registry Fix](@site/static/pdf/audits/20240501-Coinspect-Flare-SecurityReview-VoterRegistryFix-v240603.pdf)                                                     |
| Halborn     | May 2024  | [FTSO fast updates implementation](@site/static/pdf/audits/20240501-Halborn-FastUpdatesAudit.pdf)                                                                      |
| Halborn     | May 2024  | [FTSO Fast updates protocol](@site/static/pdf/audits/20240501-Halborn-FTSOFastUpdatesprotocolAudit.pdf)                                                                |
| Coinspect   | Apr 2024  | [Flare Smart Contract V2 Audit 1](@site/static/pdf/audits/20230401-Coinspect-Flare-SourceCodeSecurityReview-SmartContractsV2-v240515.pdf)                              |
| Coinspect   | Apr 2024  | [FTSO V2 Fast Updates](@site/static/pdf/audits/20240401-Coinspect-Flare-SourceCodeSecurityReview-FastUpdates-v240612.pdf)                                              |
| Coinspect   | Mar 2024  | [Transaction Verifier](@site/static/pdf/audits/20240301-Coinspect-Flare-SourceCodeSecurityReview-TransactionVerifier-v240516.pdf)                                      |
| Coinspect   | Jan 2024  | [FTSO V2 Scaling](@site/static/pdf/audits/20240101-Coinspect-Flare-SourceCodeSecurityReview-FTSOScaling-v240515.pdf)                                                   |
| Coinspect   | Jan 2024  | [Flare Systems Client (Top level client)](@site/static/pdf/audits/20240101-Coinspect-Flare-SourceCodeSecurityReview-TopLevelClient-v240515.pdf)                        |
| Coinspect   | Jan 2024  | [CChain Indexer](@site/static/pdf/audits/20240101-Coinspect-Flare-SourceCodeSecurityReview-CChainIndexer-v240409.pdf)                                                  |
| Coinspect   | Jan 2024  | [Attestation Suite](@site/static/pdf/audits/20240101-Coinspect-Smart_Contract_Review-Flare_Attestation_Suite-v240220.pdf)                                              |
| Coinspect   | Dec 2023  | [FAsset Liquidator](@site/static/pdf/audits/20231207-Coinspect-Flare-Smart_Contract_Review-FAsset_Liquidator-v231207.pdf)                                              |
| Coinspect   | Nov 2023  | [Hex Wrapped Tokens](@site/static/pdf/audits/20231101-Coinspect-Flare-SmartContractAudit-HexWrappedTokens-v231211.pdf)                                                 |
| Coinspect   | Oct 2023  | [FAsset V2 Bots](@site/static/pdf/audits/20231001-Coinspect-Flare-Source_Code_Review-FAsset_Bots-v240220.pdf)                                                          |
| Coinspect   | Oct 2023  | [Staking P2 Off-chain Services](@site/static/pdf/audits/20231001-Coinspect-Flare-Source_Code_Review-Staking_P2-Offchain_Services-v240220.pdf)                          |
| Coinspect   | Sep 2023  | [FAsset V2](@site/static/pdf/audits/20230901-Coinspect-Flare-Smart_Contract_Review-FAsset_V2-v240220.pdf)                                                              |
| Coinspect   | Sep 2023  | [Staking P2](@site/static/pdf/audits/20230901-Coinspect-Flare-Smart_Contract_Review-StakingP2-v240220.pdf)                                                             |
| FYEO        | Feb 2023  | [Golang Validator Flare Network](@site/static/pdf/audits/20230201-FlareNetworksLtd.-SecureCodeReviewof_Golang_Validator_on_the_Flare_Network_v1.0_February_Public.pdf) |
| Coinspect   | Jan 2023  | [FTSO V1 Hybrid reward band](@site/static/pdf/audits/20230101-Coinspect-SmartContractAudit-FlareHybridBandRewardv230220.pdf)                                           |
| FYEO        | Dec 2022  | [Validator Codebase V3](@site/static/pdf/audits/20221201-FlareNetworksLtd.-Dec2022-SecureCodeReviewofSoliditySmartContractsontheFlareNetworkv1.0_Public.pdf)           |
| FYEO        | Dec 2022  | [Smart Contracts V1 Audit 3](@site/static/pdf/audits/20221201-FlareNetworksLtd.-Dec2022-SecureCodeReviewofSoliditySmartContractsontheFlareNetworkv1.0_Public.pdf)      |
| Coinspect   | Dec 2022  | [Flare TDE Updates](@site/static/pdf/audits/20221201-Coinspect-SmartContractAudit-FlareTDEUpdates-v221220.pdf)                                                         |
| FYEO        | Oct 2022  | [Smart Contract V1 Audit 2](@site/static/pdf/audits/20221001-Flare_Networks_Ltd.-Secure_Code_Review_of_Solidity_Smart_Contracts_on_the_Flare_Network_v1.0_Public.pdf)  |
| Coinspect   | Oct 2022  | [Flare Airdrop](@site/static/pdf/audits/20221001-Coinspect-Smart_Contract_Audit-Flare_Airdrop_Update-v221109.pdf)                                                      |
| FYEO        | Sep 2022  | [Validator Codebase V2](@site/static/pdf/audits/20220901-Flare_Networks_Ltd.-Secure_Code_Review_of_the_Flare_Validator_V2-Report_v1.0_Public.pdf)                      |
| FYEO        | Sep 2022  | [Smart Contracts V1 Audit 1](@site/static/pdf/audits/20220901-Flare_Networks_Ltd.-Secure_Code_Review_of_Solidity_Contracts_on_the_Flare_Network_v1.0_public.pdf)       |
| FYEO        | Aug 2022  | [Validator Codebase](@site/static/pdf/audits/20220801-Flare_Networks_Ltd.-Secure_Code_Review_of_the_Flare_Network's_Validator_Codebase_v1.0_Public.pdf)                |
| Coinspect   | Jun 2022  | [Multi Chain Library](@site/static/pdf/audits/20220601-Coinspect-Flare-Source_Code_Review-Multichain_Client_Library-v240220.pdf)                                       |
| Coinspect   | Jun 2022  | [Attestation Client V1](@site/static/pdf/audits/20220601-Coinspect-Flare-Source_Code_Review-Attestation_Client-v240220.pdf)                                            |
| Coinspect   | Jun 2022  | [FAssets V1](@site/static/pdf/audits/20220601-Coinspect_Smart_Contract_Audit_fAsset_v220829.pdf)                                                                       |
| Coinspect   | Jun 2022  | [Smart Contracts](@site/static/pdf/audits/20220601-Coinspect-Smart_Contract_Audit-Flare_Network_Launch.pdf)                                                            |
| Coinspect   | Mar 2022  | [Flare Smart Contracts V1 Audit 2](@site/static/pdf/audits/20220201-Coinspect-Smart_Contract_Audit-Flare.pdf)                                                          |
| Coinspect   | Jul 2021  | [Flare Smart Contracts V1 Audit 1](@site/static/pdf/audits/20210701-Coinspect-Smart_Contract_Audit-Flare.pdf)                                                          |",2025-03-08 01:27:14
faqs.mdx,"slug: faqs
title: FAQs
description: Frequently asked questions when building on Flare.
keywords: [faq, frequently-asked-questions, flare-network, support]","import SetEvmVersionRemix from ""/static/img/set-evm-version-remix.png"";

### Why am I getting `invalid opcode: opcode 0x5f not defined`?

Flare supports EVM versions up to London, which does not support the `PUSH0` opcode, leading to this error. To fix this:

- **Using Remix:** Set EVM version to `london` in the **Advanced Configurations** section of the **Solidity Compiler** tab:

  <img src={SetEvmVersionRemix} style={{ width: 300 }} />

- **Using Hardhat or Foundry:** Set EVM version to `london` in [hardhat.config.ts](https://github.com/flare-foundation/flare-hardhat-starter/blob/master/hardhat.config.ts#L34) or [foundry.toml](https://github.com/flare-foundation/flare-foundry-starter/blob/master/foundry.toml).

- **Using Standard Solidity JSON:** Set `evmVersion` to `london`:

  ```json
  {
    ""settings"": {
      ""optimizer"": {
        /* ... */
      },
      ""evmVersion"": ""london""
    }
  }
  ```

- **Using `solc` CLI:** Set `--evm-version` to `london`:

  ```bash
  solc --evm-version london <args>
  ```

### Where can I get Flare testnet tokens?

You can get:

- Testnet C2FLR from the [Coston2 Faucet](https://faucet.flare.network/coston2).

- Testnet CFLR from the [Coston Faucet](https://faucet.flare.network/coston).

To understand the difference between Coston and Coston2, see the [Network Configuration](/network/overview#configuration) page.

### I have a project I would like to build on Flare. Can I get a grant?

Yes! Grants from the Flare Foundation are designed to support innovative and impactful projects in order to accelerate the growth of the Flare ecosystem. Whether you're an independent innovator or part of a larger team, if you believe that you can make valuable contributions to the Flare ecosystem, we'd like to hear from you.

Learn more about [Grants](https://flare.network/grants/).

### Where can I get technical support?

Connect with the rapidly growing community of developers building on Flare.

- Engage with Flare's developer community on [Telegram](https://t.me/FlareNetwork).

- Contribute to Flare's open-source codebase on [GitHub](https://github.com/flare-foundation/).

- Join the community on [Discord](https://discord.com/invite/flarenetwork).

### Where can I learn about Flare-specific terminology?

Learn more about the terminology used in the Flare ecosystem on the [Terminology](/support/terminology) page.",2025-03-08 01:27:14
1-rpc-node.mdx,"sidebar_position: 1
slug: rpc-node
title: RPC Node
description: Service application requests locally or publicly.","import Tabs from ""@theme/Tabs"";
import TabItem from ""@theme/TabItem"";

An RPC node (also sometimes referred to as an observer node) is responsible for servicing application requests. Unlike [validator nodes](/run-node/validator-node), RPC nodes operate outside the network and do not influence consensus or block production. This guide will walk you through deploying an RPC node for Flare.

You have two options for setting up an RPC node, each with its own pros and cons:

1. [Setup on bare-metal](#setup-on-bare-metal): More complex, but offers better performance and lower memory usage.

2. [Setup with Docker](#setup-with-docker): Simpler, but results in lower performance and higher memory usage.

## Hardware requirements

<Tabs groupId=""network"" block>
  <TabItem value=""flare"" label=""Flare Mainnet"" default>

    |                           | **Requirement** |
    |:--------------------------|:----------------|
    | **CPU**                   | 4 cores         |
    | **RAM**                   | 16 GB           |
    | **Disk space (pruned)**   | 500 GB SSD      |
    | **Disk space (archival)** | 3.5 TB SSD      |
    | **Disk growth**           | 30 GB/month     |

  </TabItem>
  <TabItem value=""coston2"" label=""Flare Testnet Coston2"">

    |                           | **Requirement** |
    |:--------------------------|:----------------|
    | **CPU**                   | 4 cores         |
    | **RAM**                   | 16 GB           |
    | **Disk space (pruned)**   | 150 GB SSD      |
    | **Disk space (archival)** | 1 TB SSD        |
    | **Disk growth**           | 5 GB/month      |

  </TabItem>
  <TabItem value=""songbird"" label=""Songbird Canary-Network"">

    |                           | **Requirement**  |
    |:--------------------------|:-----------------|
    | **CPU**                   | 4 cores          |
    | **RAM**                   | 16 GB            |
    | **Disk space (pruned)**   | 2 TB SSD         |
    | **Disk space (archival)** | 8 TB SSD         |
    | **Disk growth**           | 120 GB/month     |

  </TabItem>
  <TabItem value=""coston"" label=""Songbird Testnet Coston"">

    |                           | **Requirement** |
    |:--------------------------|:----------------|
    | **CPU**                   | 4 cores         |
    | **RAM**                   | 16 GB           |
    | **Disk space (pruned)**   | 150 GB SSD      |
    | **Disk space (archival)** | 1 TB SSD        |
    | **Disk growth**           | 11 GB/month     |

  </TabItem>
</Tabs>

- **Disk speed:** 1200 MB/s read and 600 MB/s write, or higher
- **Network speed:** 40 Mbps, or higher

## Setup on bare-metal

### Prerequisites

Ensure you have the following tools installed:

<Tabs groupId=""network"" block>
  <TabItem value=""flare"" label=""Flare Mainnet"" default>

    |                                                   | **Version** |
    | :------------------------------------------------ | :---------- |
    | **[Go](https://golang.org/doc/install)**          | `>=1.21.8`  |
    | **[GCC](https://gcc.gnu.org/install/)**           | `latest`    |
    | **[jq](https://stedolan.github.io/jq/download/)** | `latest`    |
    | **[Ubuntu](https://ubuntu.com)**                  | `>=20.04`   |

  </TabItem>
  <TabItem value=""coston2"" label=""Flare Testnet Coston2"">

    |                                                   | **Version** |
    | :------------------------------------------------ | :---------- |
    | **[Go](https://golang.org/doc/install)**          | `>=1.21.8`  |
    | **[GCC](https://gcc.gnu.org/install/)**           | `latest`    |
    | **[jq](https://stedolan.github.io/jq/download/)** | `latest`    |
    | **[Ubuntu](https://ubuntu.com)**                  | `>=20.04`   |

  </TabItem>
  <TabItem value=""songbird"" label=""Songbird Canary-Network"">

    |                                                   | **Version** |
    | :------------------------------------------------ | :---------- |
    | **[Go](https://golang.org/doc/install)**          | `>=1.21.8`  |
    | **[GCC](https://gcc.gnu.org/install/)**           | `latest`    |
    | **[jq](https://stedolan.github.io/jq/download/)** | `latest`    |
    | **[Ubuntu](https://ubuntu.com)**                  | `>=20.04`   |

  </TabItem>
  <TabItem value=""coston"" label=""Songbird Testnet Coston"">

    |                                                   | **Version** |
    | :------------------------------------------------ | :---------- |
    | **[Go](https://golang.org/doc/install)**          | `>=1.21.8`  |
    | **[GCC](https://gcc.gnu.org/install/)**           | `latest`    |
    | **[jq](https://stedolan.github.io/jq/download/)** | `latest`    |
    | **[Ubuntu](https://ubuntu.com)**                  | `>=20.04`   |

  </TabItem>
</Tabs>

### Configure the node

Clone the repository and run the `build.sh` script:

<Tabs groupId=""network"" block>
  <TabItem value=""flare"" label=""Flare Mainnet"" default>

    ```bash
    git clone https://github.com/flare-foundation/go-flare.git
    cd go-flare/avalanchego
    chmod +x scripts/build.sh
    ./scripts/build.sh
    ```

    The resulting executable will be stored in `build/avalanchego`.

  </TabItem>
  <TabItem value=""coston2"" label=""Flare Testnet Coston2"">

    ```bash
    git clone https://github.com/flare-foundation/go-flare.git
    cd go-flare/avalanchego
    chmod +x scripts/build.sh
    ./scripts/build.sh
    ```

    The resulting executable will be stored in `build/avalanchego`.

  </TabItem>
  <TabItem value=""songbird"" label=""Songbird Canary-Network"">

    ```bash
    git clone --branch v1.9.1 https://github.com/flare-foundation/go-flare.git
    cd go-flare/avalanchego
    chmod +x scripts/build.sh
    ./scripts/build.sh
    ```

    The resulting executable will be stored in `build/avalanchego`.

  </TabItem>
  <TabItem value=""coston"" label=""Songbird Testnet Coston"">

    ```bash
    git clone --branch v1.9.1 https://github.com/flare-foundation/go-flare.git
    cd go-flare/avalanchego
    chmod +x scripts/build.sh
    ./scripts/build.sh
    ```

    The resulting executable will be stored in `build/avalanchego`.

  </TabItem>
</Tabs>

Verify the installation by running:

<Tabs groupId=""network"" block>
  <TabItem value=""flare"" label=""Flare Mainnet"" default>

    ```bash
    go test $(go list ./... | grep -v /tests/) # avalanchego unit tests
    cd ../coreth
    go test ./... # coreth unit tests
    cd ../avalanchego
    ```

  </TabItem>
  <TabItem value=""coston2"" label=""Flare Testnet Coston2"">

    ```bash
    go test $(go list ./... | grep -v /tests/) # avalanchego unit tests
    cd ../coreth
    go test ./... # coreth unit tests
    cd ../avalanchego
    ```

  </TabItem>
  <TabItem value=""songbird"" label=""Songbird Canary-Network"">

    ```bash
    go test $(go list ./... | grep -v /tests/) # avalanchego unit tests
    cd ../coreth
    go test ./... # coreth unit tests
    cd ../avalanchego
    ```

    <details>
    <summary>Whitelisting nodes for Songbird Canary-Network</summary>

    While the Songbird Canary-Network is being tested, all nodes wanting to peer with it, including RPC nodes, need to have their IP address whitelisted.

    To do this, make a whitelisting request by contacting **Tom T.** over:

    - Discord (`Tom T#7603`)
    - Telegram (`@TampaBay7`)
    - Email ([tom@flare.network](mailto:tom@flare.network))

    To have greater redundancy, you can whitelist multiple nodes per single provider.

    **Checking the status of your whitelisting request**

    ```bash
    curl -m 10 -sX POST --data '{ ""jsonrpc"":""2.0"", ""id"":1, ""method"":""info.getNodeIP"" }' -H 'content-type:application/json;' https://songbird-bootstrap.flare.network/ext/info
    ```

    If your IP address is whitelisted, this command returns a JSON response. Otherwise you will get a 403 error (""Forbidden"").

    Note that whitelisting is **not required** on Flare Mainnet, Flare Testnet Coston2, or Songbird Testnet Coston.

    </details>

  </TabItem>
  <TabItem value=""coston"" label=""Songbird Testnet Coston"">

    ```bash
    go test $(go list ./... | grep -v /tests/) # avalanchego unit tests
    cd ../coreth
    go test ./... # coreth unit tests
    cd ../avalanchego
    ```

  </TabItem>
</Tabs>

### Run the node

This is the simplest command to quickly get your node up and running. The next section explains the parameters used here, along with additional parameters you may wish to configure.

<Tabs groupId=""network"" block>
  <TabItem value=""flare"" label=""Flare Mainnet"" default>

    ```bash
    ./build/avalanchego --network-id=flare --http-host= --bootstrap-ips=""$(curl -m 10 -sX POST --data '{ ""jsonrpc"":""2.0"", ""id"":1, ""method"":""info.getNodeIP"" }' -H 'content-type:application/json;' https://flare-bootstrap.flare.network/ext/info | jq -r "".result.ip"")"" --bootstrap-ids=""$(curl -m 10 -sX POST --data '{ ""jsonrpc"":""2.0"", ""id"":1, ""method"":""info.getNodeID"" }' -H 'content-type:application/json;' https://flare-bootstrap.flare.network/ext/info | jq -r "".result.nodeID"")""
    ```

  </TabItem>
  <TabItem value=""coston2"" label=""Flare Testnet Coston2"">

    ```bash
    ./build/avalanchego --network-id=costwo --http-host= --bootstrap-ips=""$(curl -m 10 -sX POST --data '{ ""jsonrpc"":""2.0"", ""id"":1, ""method"":""info.getNodeIP"" }' -H 'content-type:application/json;' https://coston2-bootstrap.flare.network/ext/info | jq -r "".result.ip"")"" --bootstrap-ids=""$(curl -m 10 -sX POST --data '{ ""jsonrpc"":""2.0"", ""id"":1, ""method"":""info.getNodeID"" }' -H 'content-type:application/json;' https://coston2-bootstrap.flare.network/ext/info | jq -r "".result.nodeID"")""
    ```

  </TabItem>
  <TabItem value=""songbird"" label=""Songbird Canary-Network"">

    ```bash
    ./build/avalanchego --network-id=songbird --http-host= --bootstrap-ips=""$(curl -m 10 -sX POST --data '{ ""jsonrpc"":""2.0"", ""id"":1, ""method"":""info.getNodeIP"" }' -H 'content-type:application/json;' https://songbird-bootstrap.flare.network/ext/info | jq -r "".result.ip"")"" --bootstrap-ids=""$(curl -m 10 -sX POST --data '{ ""jsonrpc"":""2.0"", ""id"":1, ""method"":""info.getNodeID"" }' -H 'content-type:application/json;' https://songbird-bootstrap.flare.network/ext/info | jq -r "".result.nodeID"")""
    ```

  </TabItem>
  <TabItem value=""coston"" label=""Songbird Testnet Coston"">

    ```bash
    ./build/avalanchego --network-id=coston --http-host= --bootstrap-ips=""$(curl -m 10 -sX POST --data '{ ""jsonrpc"":""2.0"", ""id"":1, ""method"":""info.getNodeIP"" }' -H 'content-type:application/json;' https://coston-bootstrap.flare.network/ext/info | jq -r "".result.ip"")"" --bootstrap-ids=""$(curl -m 10 -sX POST --data '{ ""jsonrpc"":""2.0"", ""id"":1, ""method"":""info.getNodeID"" }' -H 'content-type:application/json;' https://coston-bootstrap.flare.network/ext/info | jq -r "".result.nodeID"")""
    ```

  </TabItem>
</Tabs>

After a lot of log messages the node should start synchronizing with the network, which might take anywhere from a few hours to a few days depending on network speed and hardware specification. Node syncing can be stopped at any time. Use the same command to resume the node syncing from where it left off.

You will know your node is fully booted and accepting transactions when the output of this command:

```bash
curl http://127.0.0.1:9650/ext/health
```

Contains the field `""healthy"" : true` in the returned JSON object.

:::note

If the node gets stuck during bootstrap (or it takes far longer than the estimates given above), try adding the parameter `--bootstrap-retry-enabled=false` when running the node.

:::

### Additional configuration

These are some of the most relevant CLI parameters you can use. Read more about them in the [Avalanche documentation](https://docs.avax.network/nodes/maintain/avalanchego-config-flags).

{/* prettier-ignore */}
- [`--bootstrap-ips`](https://docs.avax.network/nodes/maintain/avalanchego-config-flags#--bootstrap-ips-string),
  [`--bootstrap-ids`](https://docs.avax.network/nodes/maintain/avalanchego-config-flags#--bootstrap-ids-string):
  IP address and node ID of the peer used to connect to the rest of the network for bootstrapping. Note that you have to whitelist your node's IP address or your queries will always be answered with 403 error codes.

  <details>
  <summary>Determining your peer's IP address and node ID.</summary>

  <Tabs groupId=""network"">
    <TabItem value=""flare"" label=""Flare Mainnet"" default>

      Peer's IP address:
      ```bash
      curl -m 10 -sX POST --data '{ ""jsonrpc"":""2.0"", ""id"":1, ""method"":""info.getNodeIP"" }' -H 'content-type:application/json;' https://flare-bootstrap.flare.network/ext/info | jq -r "".result.ip""
      ```
      Peer's node ID:
      ```bash
      curl -m 10 -sX POST --data '{ ""jsonrpc"":""2.0"", ""id"":1, ""method"":""info.getNodeID"" }' -H 'content-type:application/json;' https://flare-bootstrap.flare.network/ext/info | jq -r "".result.nodeID""
      ```

    </TabItem>
    <TabItem value=""coston2"" label=""Flare Testnet Coston2"">

      Peer's IP address:
      ```bash
      curl -m 10 -sX POST --data '{ ""jsonrpc"":""2.0"", ""id"":1, ""method"":""info.getNodeIP"" }' -H 'content-type:application/json;' https://coston2-bootstrap.flare.network/ext/info | jq -r "".result.ip""
      ```

      Peer's node ID:
      ```bash
      curl -m 10 -sX POST --data '{ ""jsonrpc"":""2.0"", ""id"":1, ""method"":""info.getNodeID"" }' -H 'content-type:application/json;' https://coston2-bootstrap.flare.network/ext/info | jq -r "".result.nodeID""
      ```

    </TabItem>
    <TabItem value=""songbird"" label=""Songbird Canary-Network"">

      Peer's IP address:
      ```bash
      curl -m 10 -sX POST --data '{ ""jsonrpc"":""2.0"", ""id"":1, ""method"":""info.getNodeIP"" }' -H 'content-type:application/json;' https://songbird-bootstrap.flare.network/ext/info | jq -r "".result.ip""
      ```
      Peer's node ID:
      ```bash
      curl -m 10 -sX POST --data '{ ""jsonrpc"":""2.0"", ""id"":1, ""method"":""info.getNodeID"" }' -H 'content-type:application/json;' https://songbird-bootstrap.flare.network/ext/info | jq -r "".result.nodeID""
      ```

    </TabItem>
    <TabItem value=""coston"" label=""Songbird Testnet Coston"">

      Peer's IP address:
      ```bash
      curl -m 10 -sX POST --data '{ ""jsonrpc"":""2.0"", ""id"":1, ""method"":""info.getNodeIP"" }' -H 'content-type:application/json;' https://coston-bootstrap.flare.network/ext/info | jq -r "".result.ip""
      ```
      Peer's node ID:
      ```bash
      curl -m 10 -sX POST --data '{ ""jsonrpc"":""2.0"", ""id"":1, ""method"":""info.getNodeID"" }' -H 'content-type:application/json;' https://coston-bootstrap.flare.network/ext/info | jq -r "".result.nodeID""
      ```

    </TabItem>
  </Tabs>

  </details>

- [`--http-host`](https://docs.avax.network/nodes/maintain/avalanchego-config-flags#--http-host-string): Use `--http-host=` (empty) to allow connections from other machines. Otherwise, only connections from `localhost` are accepted.

- [`--http-port`](https://docs.avax.network/nodes/maintain/avalanchego-config-flags#--http-port-int): The port through which the node will listen to API requests. The default value is `9650`.

- [`--staking-port`](https://docs.avax.network/nodes/maintain/avalanchego-config-flags#--staking-port-int): The port through which the network peers will connect to this node externally. Having this port accessible from the internet is required for correct node operation. The default value is `9651`.

- [`--db-dir`](https://docs.avax.network/nodes/maintain/avalanchego-config-flags#--db-dir-string-file-path): Directory where the database is stored. Make sure to use a disk with enough space as recommended in the [Hardware requirements](#hardware-requirements) section. It defaults to `~/.avalanchego/db` on Flare Mainnet and Flare Testnet Coston2, and to `~/.flare/db` on Songbird Canary-Network and Songbird Testnet Coston. For example, you can use this option to store the database on an external drive.

- [`--chain-config-dir`](https://docs.avax.network/nodes/maintain/avalanchego-config-flags#--chain-config-dir-string): Optional JSON configuration file for using non-default values.

  <details>
  <summary>Sample JSON configuration for RPC nodes.</summary>

  For archival nodes, set `""pruning-enabled"": false` to disable pruning. Note that archival nodes require significantly more disk space than standard RPC nodes.

  ```json title=""<chain-config-dir>/C/config.json""
  {
    ""snowman-api-enabled"": false,
    ""coreth-admin-api-enabled"": false,
    ""eth-apis"": [
      ""eth"",
      ""eth-filter"",
      ""net"",
      ""web3"",
      ""internal-eth"",
      ""internal-blockchain"",
      ""internal-transaction""
    ],
    ""rpc-gas-cap"": 50000000,
    ""rpc-tx-fee-cap"": 100,
    ""pruning-enabled"": true,
    ""local-txs-enabled"": false,
    ""api-max-duration"": 0,
    ""api-max-blocks-per-request"": 0,
    ""allow-unfinalized-queries"": false,
    ""allow-unprotected-txs"": false,
    ""remote-tx-gossip-only-enabled"": false,
    ""log-level"": ""info""
  }
  ```

  </details>

## Setup with Docker

### Prerequisites

- [Docker Engine](https://docs.docker.com/engine/install/)
- [jq](https://stedolan.github.io/jq/download/) (optional, but recommended)

For simplicity this guide uses Docker Engine installed on Debian Linux.

:::tip

To avoid using `sudo` each time you run the `docker` command, add your user to the Docker group after installation:

```bash
sudo usermod -a -G docker $USER
# Log out and log back in or restart your system for the changes to take effect
```

:::

### Configure the node

#### Disk setup

This setup varies depending on your use case, but essentially you need to have a local directory with sufficient space for the blockchain data to be stored and persisted in. In this guide, there is an additional disk mounted at `/mnt/db`, which is used to persist the blockchain data. After you have a machine set up and ready to go, find the additional disk, format it if necessary, and mount to a directory:

```bash
lsblk
# ----
# NAME    MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT
# sda       8:0    0   10G  0 disk
# ‚îú‚îÄsda1    8:1    0  9.9G  0 part /
# ‚îú‚îÄsda14   8:14   0    3M  0 part
# ‚îî‚îÄsda15   8:15   0  124M  0 part /boot/efi
# sdb       8:16   0  300G  0 disk <- Device identified as db disk via size
# ----
sudo mkdir /mnt/db
sudo chown -R <user>:<user> /mnt/db
sudo mkfs.ext4 -m 0 -E lazy_itable_init=0,lazy_journal_init=0,discard /dev/sdb
sudo mount /dev/sdb /mnt/db
```

:::info

- Replace `<user>` with the user you wish to start your containerized RPC node with.
  It is recommended that this isn't the root user for security reasons.
- Ensure you are replacing `/dev/sdb` with your actual device, since it could be different to the example.

:::

Confirm the new disk is mounted:

```bash hl_lines=""11""
df -h
# -----
# Filesystem      Size  Used Avail Use% Mounted on
# udev            3.9G     0  3.9G   0% /dev
# tmpfs           796M  376K  796M   1% /run
# /dev/sda1       9.7G  1.9G  7.3G  21% /
# tmpfs           3.9G     0  3.9G   0% /dev/shm
# tmpfs           5.0M     0  5.0M   0% /run/lock
# /dev/sda15      124M   11M  114M   9% /boot/efi
# tmpfs           796M     0  796M   0% /run/user/1009
# /dev/sdb        295G   28K  295G   1% /mnt/db
```

Look for your device name and mount point specified in the output to confirm the mount worked.

Backup the original `fstab` file (to revert changes if needed) and update `/etc/fstab` to make sure the device is mounted when the system reboots:

```bash
sudo -i
cp /etc/fstab /etc/fstab.backup
fstab_entry=""UUID=$(blkid -o value -s UUID /dev/sdb) /mnt/db ext4 discard,defaults 0 2""
echo $fstab_entry >> /etc/fstab
exit
```

#### Configuration File and Logs Directory Setup

Once the disk setup is complete, you can define the configuration file and logs directory for the RPC node. These will be mounted from your local machine to the specified directories on your containerized RPC node.

Mounting the logs directory allows you to access the logs generated by the workload directly on your local machine. This saves you the effort of using `docker logs` and lets you inspect the files in your local directory instead.

This example uses the configuration provided in the [Additional Configuration](#additional-configuration) section of the Setup on Bare-Metal.

Create the local directories and change ownership to a non-root user of your choice:

```bash
sudo mkdir -p /opt/flare/conf
sudo mkdir /opt/flare/logs
sudo chown -R <user>:<user> /opt/flare
```

:::info

Replace `<user>` with the user you wish to start your containerized RPC node with.
It is recommended that this isn't the root user for security reasons.

:::

Create the configuration file:

```json title=""/opt/flare/conf/config.json""
{
  ""snowman-api-enabled"": false,
  ""coreth-admin-api-enabled"": false,
  ""eth-apis"": [
    ""eth"",
    ""eth-filter"",
    ""net"",
    ""web3"",
    ""internal-eth"",
    ""internal-blockchain"",
    ""internal-transaction""
  ],
  ""rpc-gas-cap"": 50000000,
  ""rpc-tx-fee-cap"": 100,
  ""pruning-enabled"": true,
  ""local-txs-enabled"": false,
  ""api-max-duration"": 0,
  ""api-max-blocks-per-request"": 0,
  ""allow-unfinalized-queries"": false,
  ""allow-unprotected-txs"": false,
  ""remote-tx-gossip-only-enabled"": false,
  ""log-level"": ""info""
}
```

### Run the node

The node can be run using:

- [Docker CLI](#using-docker-cli), easier for a quick setup.

- [Docker Compose](#using-docker-compose), more permanent and usable in the future.

#### Using Docker CLI

<Tabs groupId=""network"" block>
  <TabItem value=""flare"" label=""Flare Mainnet"" default>

    Use the Docker image at [go-flare](https://hub.docker.com/layers/flarefoundation/go-flare/v1.9.1/images/sha256-ab193ed8862bf9ba82b309e00e892a81df1480f63c5b91981a2b4eb9c4847334?context=explore). The **Overview** tab in the repository linked explains the configurable parameters.

    Download and start the container:

    ```bash
    docker pull flarefoundation/go-flare:v1.9.1
    docker run -d --name flare-observer -e AUTOCONFIGURE_BOOTSTRAP=""1"" -e NETWORK_ID=""flare"" -e AUTOCONFIGURE_PUBLIC_IP=""1"" -e AUTOCONFIGURE_BOOTSTRAP_ENDPOINT=""https://flare-bootstrap.flare.network/ext/info"" -v /mnt/db:/app/db -v /opt/flare/conf:/app/conf/C -v /opt/flare/logs:/app/logs -p 0.0.0.0:9650:9650 -p 0.0.0.0:9651:9651 flarefoundation/go-flare:v1.9.1
    ```

    Confirm your container is running and inspect that logs are printing:

    ```bash
    docker ps
    docker logs flare-observer -f
    ```

  </TabItem>
  <TabItem value=""coston2"" label=""Flare Testnet Coston2"">

    Use the Docker image at [go-flare](https://hub.docker.com/layers/flarefoundation/go-flare/v1.9.1/images/sha256-ab193ed8862bf9ba82b309e00e892a81df1480f63c5b91981a2b4eb9c4847334?context=explore). The **Overview** tab in the repository linked explains the configurable parameters.

    Download and start the container:

    ```bash
    docker pull flarefoundation/go-flare:v1.9.1
    docker run -d --name coston2-observer -e AUTOCONFIGURE_BOOTSTRAP=""1"" -e NETWORK_ID=""costwo"" -e AUTOCONFIGURE_PUBLIC_IP=""1"" -e AUTOCONFIGURE_BOOTSTRAP_ENDPOINT=""https://coston2-bootstrap.flare.network/ext/info"" -v /mnt/db:/app/db -v /opt/flare/conf:/app/conf/C -v /opt/flare/logs:/app/logs -p 0.0.0.0:9650:9650 -p 0.0.0.0:9651:9651 flarefoundation/go-flare:v1.9.1
    ```

    Confirm your container is running and inspect that logs are printing:

    ```bash
    docker ps
    docker logs coston2-observer -f
    ```

  </TabItem>
  <TabItem value=""songbird"" label=""Songbird Canary-Network"">

    Use the Docker image at [go-flare](https://hub.docker.com/layers/flarefoundation/go-flare/v1.9.1/images/sha256-ab193ed8862bf9ba82b309e00e892a81df1480f63c5b91981a2b4eb9c4847334?context=explore). The **Overview** tab in the repository linked explains the configurable parameters.

    Download and start the container:

    ```bash
    docker pull flarefoundation/go-flare:v1.9.1
    docker run -d --name songbird-observer -e AUTOCONFIGURE_BOOTSTRAP=""1"" -e NETWORK_ID=""songbird"" -e AUTOCONFIGURE_PUBLIC_IP=""1"" -e AUTOCONFIGURE_BOOTSTRAP_ENDPOINT=""https://songbird-bootstrap.flare.network/ext/info"" -v /mnt/db:/app/db -v /opt/flare/conf:/app/conf/C -v /opt/flare/logs:/app/logs -p 0.0.0.0:9650:9650 -p 0.0.0.0:9651:9651 flarefoundation/go-flare:v1.9.1
    ```

    Confirm your container is running and inspect that logs are printing:

    ```bash
    docker ps
    docker logs songbird-observer -f
    ```

  </TabItem>
  <TabItem value=""coston"" label=""Songbird Testnet Coston"">

    Use the Docker image at [go-flare](https://hub.docker.com/layers/flarefoundation/go-flare/v1.9.1/images/sha256-ab193ed8862bf9ba82b309e00e892a81df1480f63c5b91981a2b4eb9c4847334?context=explore). The **Overview** tab in the repository linked explains the configurable parameters.

    Download and start the container:

    ```bash
    docker pull flarefoundation/go-flare:v1.9.1
    docker run -d --name coston-observer -e AUTOCONFIGURE_BOOTSTRAP=""1"" -e NETWORK_ID=""coston"" -e AUTOCONFIGURE_PUBLIC_IP=""1"" -e AUTOCONFIGURE_BOOTSTRAP_ENDPOINT=""https://coston-bootstrap.flare.network/ext/info"" -v /mnt/db:/app/db -v /opt/flare/conf:/app/conf/C -v /opt/flare/logs:/app/logs -p 0.0.0.0:9650:9650 -p 0.0.0.0:9651:9651 flarefoundation/go-flare:v1.9.1
    ```

    Confirm your container is running and inspect that logs are printing:

    ```bash
    docker ps
    docker logs coston-observer -f
    ```

  </TabItem>
</Tabs>

Once you have confirmed that the container is running, use Ctrl+C to exit the following of logs and check your container's `/ext/health` endpoint. Only when the RPC node is fully synced will you see `""healthy"": true`, but this otherwise confirms your container's HTTP port `9650` is accessible from your local machine.

```bash
curl http://localhost:9650/ext/health | jq
```

<details>
<summary>Explanation of the CLI arguments.</summary>

**Volumes:**

- `-v /mnt/db:/app/db`

  Mount the local database directory to the default database directory of the container.

- `-v /opt/flare/conf:/app/conf/C`

  Mount the local configuration directory to the default location of `config.json`.

- `-v /opt/flare/logs:/app/logs`

  Mount the local logs directory to the workloads default logs directory.

**Ports:**

- `-p 0.0.0.0:9650:9650`

  Mapping the container's HTTP port to your local machine, enabling the querying of the containerized RPC node's HTTP port via your local machine's IP and port.

  !!! warning
  Only use binding `0.0.0.0` for port 9650 if you wish to publicly expose your containerized RPC node's RPC endpoint from your machine's public IP address.
  If you require it to be publicly accessible for another application to use, ensure you set up a firewall rule to only allow port 9650 to be accessible via specific source IP addresses.

- `-p 0.0.0.0:9651:9651`

  Mapping the container's peering port to your local machine so other peers can query the node.

**Environment Variables:**

- `-e AUTOCONFIGURE_BOOTSTRAP=""1""`

  Retrieves the bootstrap endpoints Node-IP and Node-ID automatically.

- `-e NETWORK_ID=""<network>""`

  Sets the correct network ID from the provided options below:

  - `coston`
  - `costwo`
  - `songbird`
  - `flare`

- `-e AUTOCONFIGURE_PUBLIC_IP=""1""`

  Retrieves your local machine's IP automatically.

- `-e AUTOCONFIGURE_BOOTSTRAP_ENDPOINT=""<bootstrap_host>/ext/info""`

      Defines the bootstrap endpoint used to initialize chain sync.
      Flare nodes can be used to bootstrap your node for each chain:

      - `https://coston-bootstrap.flare.network/ext/info`
      - `https://costwo.flare.network/ext/info`
      - `https://songbird-bootstrap.flare.network/ext/info`
      - `https://flare-bootstrap.flare.network/ext/info`

</details>

#### Using Docker Compose

Docker Compose for this use case is a good way to simplify your setup of running the RPC node. Adding all necessary configurations into a single file that can be run with a simple command.

In this guide the `docker-compose.yaml` file is created in `/opt/observer` but the location is entirely up to you.

Create the working directory and set the ownership.

```bash
sudo mkdir /opt/observer
sudo chown -R <user>:<user> /opt/observer
```

Create the `docker-compose.yaml` file:

<Tabs groupId=""network"" block>
  <TabItem value=""flare"" label=""Flare Mainnet"" default>

    ```yaml title=""/opt/observer/docker-compose.yaml""
    version: '3.6'

    services:
      observer:
        container_name: flare-observer
        image: flarefoundation/go-flare:v1.9.1
        restart: on-failure
        environment:
          - AUTOCONFIGURE_BOOTSTRAP=1
          - NETWORK_ID=flare
          - AUTOCONFIGURE_PUBLIC_IP=1
          - AUTOCONFIGURE_BOOTSTRAP_ENDPOINT=https://flare-bootstrap.flare.network/ext/info
        volumes:
          - /mnt/db:/app/db
          - /opt/flare/conf:/app/conf/C
          - /opt/flare/logs:/app/logs
        ports:
          - 0.0.0.0:9650:9650
          - 0.0.0.0:9651:9651
    ```

  </TabItem>
  <TabItem value=""coston2"" label=""Flare Testnet Coston2"">

    ```yaml title=""/opt/observer/docker-compose.yaml""
    version: '3.6'

    services:
      observer:
        container_name: coston2-observer
        image: flarefoundation/go-flare:v1.9.1
        restart: on-failure
        environment:
          - AUTOCONFIGURE_BOOTSTRAP=1
          - NETWORK_ID=costwo
          - AUTOCONFIGURE_PUBLIC_IP=1
          - AUTOCONFIGURE_BOOTSTRAP_ENDPOINT=https://coston2-bootstrap.flare.network/ext/info
        volumes:
          - /mnt/db:/app/db
          - /opt/flare/conf:/app/conf/C
          - /opt/flare/logs:/app/logs
        ports:
          - 0.0.0.0:9650:9650
          - 0.0.0.0:9651:9651
    ```

  </TabItem>
  <TabItem value=""songbird"" label=""Songbird Canary-Network"">

    ```yaml title=""/opt/observer/docker-compose.yaml""
    version: '3.6'

    services:
      observer:
        container_name: songbird-observer
        image: flarefoundation/go-flare:v1.9.1
        restart: on-failure
        environment:
          - AUTOCONFIGURE_BOOTSTRAP=1
          - NETWORK_ID=songbird
          - AUTOCONFIGURE_PUBLIC_IP=1
          - AUTOCONFIGURE_BOOTSTRAP_ENDPOINT=https://songbird-bootstrap.flare.network/ext/info
        volumes:
          - /mnt/db:/app/db
          - /opt/flare/conf:/app/conf/C
          - /opt/flare/logs:/app/logs
        ports:
          - 0.0.0.0:9650:9650
          - 0.0.0.0:9651:9651
    ```

  </TabItem>
  <TabItem value=""coston"" label=""Songbird Testnet Coston"">

    ```yaml title=""/opt/observer/docker-compose.yaml""
    version: '3.6'

    services:
      observer:
        container_name: coston-observer
        image: flarefoundation/go-flare:v1.9.1
        restart: on-failure
        environment:
          - AUTOCONFIGURE_BOOTSTRAP=1
          - NETWORK_ID=coston
          - AUTOCONFIGURE_PUBLIC_IP=1
          - AUTOCONFIGURE_BOOTSTRAP_ENDPOINT=https://coston-bootstrap.flare.network/ext/info
        volumes:
          - /mnt/db:/app/db
          - /opt/flare/conf:/app/conf/C
          - /opt/flare/logs:/app/logs
        ports:
          - 0.0.0.0:9650:9650
          - 0.0.0.0:9651:9651
    ```

  </TabItem>
</Tabs>

Run Docker Compose:

```bash
docker compose -f /opt/observer/docker-compose.yaml up -d
```

When the command completes, check the container is running and inspect that logs are being generated:

```bash
docker ps
docker compose logs -f
```

Once you have confirmed the container is running, use Ctrl+C to exit the following of logs and check your container's `/ext/health` endpoint.
Only when the RPC node is fully synced will you see `""healthy"": true`, but this otherwise confirms your container's HTTP port (9650) is accessible from your local machine.

```bash
curl http://localhost:9650/ext/health | jq
```

### Additional configuration

There are several environment variables to adjust your workload at runtime. The example Docker and Docker Compose guides above assumed some defaults and utilized built-in automation scripts for most of the configuration. Outlined below are all options available:

|         **Variable Name** | **Default** | **Description**                                                      |
| ------------------------: | :---------- | :------------------------------------------------------------------- |
|               `HTTP_HOST` | `0.0.0.0`   | HTTP host binding address                                            |
|               `HTTP_PORT` | `9650`      | The listening port for the HTTP host                                 |
|            `STAKING_PORT` | `9651`      | The staking port for bootstrapping nodes                             |
|               `PUBLIC_IP` | (empty)     | Public facing IP. Must be set if `AUTOCONFIGURE_PUBLIC_IP=0`         |
|                  `DB_DIR` | `/app/db`   | The database directory location                                      |
|                 `DB_TYPE` | `leveldb`   | The database type to be used                                         |
|           `BOOTSTRAP_IPS` | (empty)     | A list of bootstrap server IPs                                       |
|           `BOOTSTRAP_IDS` | (empty)     | A list of bootstrap server IDs                                       |
|        `CHAIN_CONFIG_DIR` | `/app/conf` | Configuration folder where you should mount your configuration file  |
|                 `LOG_DIR` | `/app/logs` | Logging directory                                                    |
|               `LOG_LEVEL` | `info`      | Logging verbosity level that is logged into the file                 |
| `AUTOCONFIGURE_PUBLIC_IP` | `0`         | Set to 1 to autoconfigure `PUBLIC_IP`, skipped if `PUBLIC_IP` is set |
| `AUTOCONFIGURE_BOOTSTRAP` | `0`         | Set to 1 to autoconfigure `BOOTSTRAP_IPS` and `BOOTSTRAP_IDS`        |
|         `EXTRA_ARGUMENTS` | (empty)     | Extra arguments passed to flare binary                               |

Additional options:

- `NETWORK_ID`

  **Default:** The default depends on the image you use, so either go-songbird (`default: coston`) or go-flare (`default: costwo`)

  **Description:** Name of the network you want to connect to.

- `AUTOCONFIGURE_BOOTSTRAP_ENDPOINT`

  **Default:** `https://coston2-bootstrap.flare.network/ext/info` or `https://flare-bootstrap.flare.network/ext/info`

  **Description:** Endpoint used to automatically retrieve the Node-ID and Node-IP from.

- `AUTOCONFIGURE_FALLBACK_ENDPOINTS`

  **Default:** (empty)

  **Description:** Comma-divided fallback bootstrap endpoints, used if `AUTOCONFIGURE_BOOTSTRAP_ENDPOINT` is not valid, such as the bootstrap endpoint being unreachable.
  Tested from first-to-last, until one is valid.

## Node maintenance

In some cases, your node might not work correctly or you might receive unusual messages that are difficult to troubleshoot. Use the following solutions to ensure your node stays healthy:

- **Ensure Adequate Peers:** When your node has fewer than 16 peers, it will not work correctly. To retrieve the number of connected peers, run the following command and look for the line containing `connectedPeers`:

  ```bash
  curl http://127.0.0.1:9650/ext/health | jq
  ```

  To automate the process, use:

  ```bash
  curl -s http://127.0.0.1:9650/ext/health | jq -r "".checks.network.message.connectedPeers""
  ```

- **Check Disk Space:** If your node does not sync after a long time and abruptly stops working, ensure the database location has sufficient disk space. Remember, the database size might change significantly during bootstrapping.

- **Resolve Connection Issues:** If you receive unusual messages after making submissions or when transactions are reverted, your node might not be connected correctly. Ensure the database location has sufficient disk space, then restart the node.

- **Handle Bootstrap Errors:** If you receive an error related to `GetAcceptedFrontier` during bootstrapping, your node was disconnected during the process. Restart the node if you see the following error:

  ```plaintext
  failed to send GetAcceptedFrontier(MtF8bVH241hetCQJgsKEdKyJBs8vhp1BC, 11111111111111111111111111111111LpoYY, NUMBER)
  ```

- **Restart Unhealthy Nodes:** If your node syncs but remains unhealthy for no discernible reason, restart the node.",2025-03-08 01:27:14
2-validator-node.mdx,"sidebar_position: 2
slug: validator-node
title: Validator Node
description: Secure Flare by reaching consensus on state transitions.","import Tabs from ""@theme/Tabs"";
import TabItem from ""@theme/TabItem"";

A validator node is essential for securing the network by validating transactions and blocks, and participating in the consensus process. Deploying validator nodes enables participation in the consensus mechanism and allows for the collection of rewards provided by the network to those who help secure it.

Validator nodes perform the following tasks:

- **Validation:** Ensure the validity of transactions.
- **Consensus:** Reach agreement with other validators on the transactions to be added to the blockchain.
- **Block Addition:** Bundle the agreed-upon transactions into a block and append it to the blockchain.

On Flare, data protocols such as the [Flare Time Series Oracle](/run-node/ftso-data-provider) and [Flare Data Connector](/run-node/fdc-attestation-provider) are enshrined into the network. This requires validators to perform additional tasks to secure the network and earn rewards.

<details>
<summary>**Flare Staking Phases**</summary>

Deployment will occur in three phases, during which:

1. Infrastructure entities will be progressively on-boarded to ensure the network remains operational.
2. Current FTSO data providers must build a minimum stake to function as validators.
3. Existing validators need to enhance their capabilities to become data providers.

Each phase will gradually relinquish control, allowing the network to validate independently of the Flare Foundation.

**Launch (Jul 2022)**

At network launch, 20 validators had their node IDs hard-coded into the client software, preventing other validators from participating. The Flare Foundation managed these nodes and gradually reassigned 16 of them to 4 external entities to increase decentralization. These entities, known as professional validators, are experienced infrastructure providers managing blockchain nodes. During this period, FTSO data providers operated entirely independently of validators.

**Phase 1 (July 2023)**

A network fork enabled Avalanche's proof-of-stake mechanism, opening validation to everyone. Simultaneously, all stakes from the original validators expired. The Flare Foundation loaned all the stakes for the initial validators, maintaining the distribution of validation power while testing proof-of-stake. After some FTSO data providers completed a KYC process, the Flare Foundation loaned them funds to deploy validation nodes and act as validators.

Since staking occurs on the P-chain, staked tokens cannot access rewards managed by smart contracts on the C-chain. To address this, a communication mechanism between the two chains is being developed. All staking rewards are manually calculated offchain and then distributed onchain. These calculations will initially be private for fine-tuning and will become public in Phase 2 for verification.

**Phase 2 (Oct 2023, current)**

Once FTSO data providers have gathered enough stake to ensure the network's continued operation, all stakes loaned by the Flare Foundation to the launch validators will be withdrawn. Professional validators are expected to cease operations unless they provide their own stake. The Flare Foundation might delegate stake to KYC-verified FTSO data providers to help initiate the system. This process, known as stake boosting, will run for a limited time. Staked funds can earn [FlareDrops](https://flare.network/flaredrop-guide/) and participate in governance but not earn [FTSO](https://flare.network/ftso/) delegation rewards.

Staking rewards will:

- Consider validator uptime and staked amount, which is publicly monitored.
- Require that the validator is also an FTSO data provider consistently rewarded for accurate prices.
- Be manually calculated offchain using a public script and then distributed onchain.

**Phase 3**

Once secure communication between the P- and C-chains is established, staking rewards will be managed entirely onchain. The goal is for funds staked on the P-chain to have the same rights as wrapped FLR on the C-chain, enabling them to earn [FTSO](https://flare.network/ftso/) rewards, [FlareDrops](https://flare.network/flaredrop-guide/), and participate in governance.

**Summary of Phases**

|                                                   | Launch | Phase 1 | Phase 2\* | Phase 3 |
| ------------------------------------------------- | :----: | :-----: | :-------: | :-----: |
| Validation open to everybody                      |   ‚ùå   |   ‚úÖ    |    ‚úÖ     |   ‚úÖ    |
| Validators must provide own stake                 |   ‚ùå   |   ‚ùå    |    ‚úÖ     |   ‚úÖ    |
| Validators must be data providers to earn rewards |   ‚ùå   |   ‚ùå    |    ‚úÖ     |   ‚úÖ    |
| Locked stake can earn staking rewards             |   ‚ùå   |   ‚ùå    |    ‚úÖ     |   ‚úÖ    |
| Staking rewards are handled onchain               |   ‚ùå   |   ‚ùå    |    ‚ùå     |   ‚úÖ    |
| Same rights for staked and wrapped tokens         |   ‚ùå   |   ‚ùå    |    ‚ùå     |   ‚úÖ    |

\*Current Phase

</details>

## Hardware requirements

Validator nodes have the same hardware requirements as RPC nodes. Refer to the [Hardware requirements](/run-node/rpc-node#hardware-requirements) section of the RPC node guide for more information.

## Prerequisites

Ensure you have the following tools installed:

- [Go](https://golang.org/doc/install)
- [GCC](https://gcc.gnu.org/install/)
- [jq](https://stedolan.github.io/jq/download/)

<Tabs>
  <TabItem value=""macos"" label=""MacOS"" default>

    ```bash
    brew install go gcc jq
    ```

  </TabItem>
  <TabItem value=""ubuntu"" label=""Ubuntu"">

    ```bash
    apt install golang gcc jq
    ```

  </TabItem>
  <TabItem value=""arch"" label=""Arch"">

    ```bash
    pacman -S go gcc jq
    ```

  </TabItem>
</Tabs>

## Configure the node

:::warning
Validator security impacts the security of the entire network. To configure your node for security:

- **Don't** allow port `9650` to be reached externally.
- **Don't** allow password authentication over SSH.
- **Don't** run any non-validator services on the same IP.

:::

In addition to the above, the following security measures are recommended for further hardening:

- **Do** firewall the machine. Only the ports required for validator operation should be open (i.e. only the staking port, which defaults to `9651`).

- **Don't** allow any ICMP traffic.

- **Don't** allow the node to accept RPC API requests, only use it as a validator. Deploy a separate RPC node for tasks requiring RPC API access.

- **Don't** enable the more than the minimum set of EVM APIs when configuring your node.

<details>
<summary>Sample JSON configuration for validator nodes.</summary>

```json title=""config.json""
{
  ""snowman-api-enabled"": false,
  ""coreth-admin-api-enabled"": false,
  ""coreth-admin-api-dir"": """",
  ""eth-apis"": [""web3""],
  ""continuous-profiler-dir"": """",
  ""continuous-profiler-frequency"": 900000000000,
  ""continuous-profiler-max-files"": 5,
  ""rpc-gas-cap"": 50000000,
  ""rpc-tx-fee-cap"": 100,
  ""preimages-enabled"": false,
  ""pruning-enabled"": true,
  ""snapshot-async"": true,
  ""snapshot-verification-enabled"": false,
  ""metrics-enabled"": true,
  ""metrics-expensive-enabled"": false,
  ""local-txs-enabled"": false,
  ""api-max-duration"": 30000000000,
  ""ws-cpu-refill-rate"": 0,
  ""ws-cpu-max-stored"": 0,
  ""api-max-blocks-per-request"": 30,
  ""allow-unfinalized-queries"": false,
  ""allow-unprotected-txs"": false,
  ""keystore-directory"": """",
  ""keystore-external-signer"": """",
  ""keystore-insecure-unlock-allowed"": false,
  ""remote-tx-gossip-only-enabled"": false,
  ""tx-regossip-frequency"": 60000000000,
  ""tx-regossip-max-size"": 15,
  ""log-level"": ""info"",
  ""offline-pruning-enabled"": false,
  ""offline-pruning-bloom-filter-size"": 512,
  ""offline-pruning-data-directory"": """"
}
```

</details>

## Run the node

Start your node by following the **Run the node** section of the [RPC node](/run-node/rpc-node) guide.

:::info

If you have a pre-registered validator key, you just need to add these parameters to the launch command:

```bash
--staking-tls-cert-file=<NODE_CRT_PATH> --staking-tls-key-file=<NODE_KEY_PATH>
```

:::",2025-03-08 01:27:14
_automated_registration.mdx,,"import Tabs from ""@theme/Tabs"";
import TabItem from ""@theme/TabItem"";

<details>
<summary>Automated registration on testnets.</summary>

:::danger

Automated registration can expose private keys. Only use on testnets.

:::

On testnets, you can register your entity addresses with the [`register-entities.ts`](https://github.com/flare-foundation/flare-smart-contracts-v2/blob/main/deployment/tasks/register-entities.ts) script and your sortition public key with the [`register-public-keys.ts`](https://github.com/flare-foundation/flare-smart-contracts-v2/blob/main/deployment/tasks/register-public-keys.ts) scripts.

1. Clone and build [flare-smart-contracts-v2](https://github.com/flare-foundation/flare-smart-contracts-v2/):

```bash
git clone https://github.com/flare-foundation/flare-smart-contracts-v2/
cd flare-smart-contracts-v2
yarn
yarn c
```

2. Create an `entities.json` file with the following account addresses and private keys:

```json
[
  {
    ""identity"": {
      ""address"": ""<address>"",
      ""privateKey"": ""<private key hex>""
    },
    ""submit"": {
      ""address"": ""<address>"",
      ""privateKey"": ""<private key hex>""
    },
    ""submitSignatures"": {
      ""address"": ""<address>"",
      ""privateKey"": ""<private key hex>""
    },
    ""signingPolicy"": {
      ""address"": ""<address>"",
      ""privateKey"": ""<private key hex>""
    },
    ""delegation"": {
      ""address"": ""<address>"",
      ""privateKey"": ""<private key hex>""
    },
    ""sortitionPrivateKey"": ""<private key hex>""
  }
]
```

3. Setup the following variables in `.env`:

<Tabs groupId=""network"">
  <TabItem value=""coston2"" label=""Flare Testnet Coston2"" default>

    ```text title="".env""
    ENTITIES_FILE_PATH=""<path to entities.json>""
    COSTON2_RPC=<non-public Coston2 RPC>
    CHAIN_CONFIG=""coston2""
    ```

  </TabItem>
  <TabItem value=""songbird"" label=""Songbird Canary-Network"">

    ```text title="".env""
    ENTITIES_FILE_PATH=""<path to entities.json>""
    SONGBIRD_RPC=<non-public Songbird RPC>
    CHAIN_CONFIG=""songbird""
    ```

  </TabItem>
  <TabItem value=""coston"" label=""Songbird Testnet Coston"">

    ```text title="".env""
    ENTITIES_FILE_PATH=""<path to entities.json>""
    COSTON_RPC=<non-public Coston RPC>
    CHAIN_CONFIG=""coston""
    ```

  </TabItem>
</Tabs>

4. Run the registration tasks:

<Tabs groupId=""network"">
  <TabItem value=""coston2"" label=""Flare Testnet Coston2"" default>

    ```bash
    yarn hardhat --network coston2 register-entities
    yarn hardhat --network coston2 register-public-keys
    ```

  </TabItem>
  <TabItem value=""songbird"" label=""Songbird Canary-Network"">

    ```bash
    yarn hardhat --network songbird register-entities
    yarn hardhat --network songbird register-public-keys
    ```

  </TabItem>
  <TabItem value=""coston"" label=""Songbird Testnet Coston"">

    ```bash
    yarn hardhat --network coston register-entities
    yarn hardhat --network coston register-public-keys
    ```

  </TabItem>
</Tabs>
</details>
",2025-03-08 01:27:14
5-GCP-marketplace-nodes.mdx,"sidebar_position: 5
slug: gcp-marketplace-nodes
title: GCP Marketplace Nodes
description: Pre-configured blockchain nodes in GCP marketplace","import Step1 from ""/static/img/run-node-gcp-marketplace/step1-img.png"";
import Step2 from ""/static/img/run-node-gcp-marketplace/step2-img.png"";
import Step2_1 from ""/static/img/run-node-gcp-marketplace/step2-1-img.png"";

Deploy blockchain nodes without the need to install dependencies or manage configuration files. The nodes come with a copy of the databases locally which drastically reduces bootstrap times. The machine images are available for Flare Mainnet, Flare Testnet Coston2, Songbird Canary-Network, Songbird Testnet Coston and several other networks.

Head to [Google Cloud Marketplace](https://console.cloud.google.com/marketplace/product/flare-public/blockchain-machine-image-flare-network) to get started.

## Supported blockchain nodes

| Name                          | Config Dir             | Machine Type   | vCPUs | RAM   | Disk Size | Disk Type |
| :---------------------------- | :--------------------- | :------------- | :---- | :---- | :-------- | :-------- |
| Flare Mainnet                 | `/etc/flare`           | n2d-standard-4 | 4     | 16 GB | 830 GB    | Balanced  |
| Flare Mainnet Rosetta         | `/etc/flare_rosetta`   | n2d-standard-4 | 4     | 16 GB | 830 GB    | Balanced  |
| Flare Testnet Coston2         | `/etc/coston2`         | n2d-standard-4 | 4     | 16 GB | 280 GB    | Balanced  |
| Flare Testnet Coston2 Rosetta | `/etc/coston2_rosetta` | n2d-standard-4 | 4     | 16 GB | 280 GB    | Balanced  |
| Songbird Canary-Network       | `/etc/songbird`        | n2d-standard-8 | 8     | 32 GB | 2,730 GB  | Balanced  |
| Songbird Testnet Coston       | `/etc/coston`          | n2d-standard-4 | 4     | 16 GB | 280 GB    | Balanced  |

<details>
<summary>Other supported networks </summary>

| Name                | Config Dir       | Machine Type       | vCPUs | RAM   | Disk Size | Disk Type |
| :------------------ | :--------------- | :----------------- | :---- | :---- | :-------- | :-------- |
| Algorand            | `/etc/algorand`  | e2-custom-8-13056  | 8     | 13 GB | 70 GB     | Balanced  |
| Avalanche           | `/etc/avalanche` | e2-custom-8-16384  | 8     | 16 GB | 530 GB    | Balanced  |
| Bitcoin             | `/etc/bitcoin`   | e2-custom-2-16128  | 2     | 16 GB | 1,030 GB  | Balanced  |
| Binance Smart Chain | `/etc/bsc`       | c2-standard-8      | 8     | 32 GB | 2,030 GB  | SSD       |
| Cosmos Hub          | `/etc/cosmos`    | n2d-standard-4     | 4     | 16 GB | 1,030 GB  | Balanced  |
| Dogecoin            | `/etc/dogecoin`  | e2-custom-2-11008  | 2     | 11 GB | 380 GB    | Balanced  |
| Ethereum            | `/etc/ethereum`  | n2d-standard-8     | 8     | 32 GB | 2,230 GB  | Balanced  |
| Ethereum Holesky    | `/etc/ethereum`  | n2d-standard-8     | 8     | 32 GB | 430 GB    | Balanced  |
| Ethereum Sepolia    | `/etc/ethereum`  | n2d-standard-8     | 8     | 32 GB | 730 GB    | Balanced  |
| Filecoin Lotus      | `/etc/filecoin`  | e2-custom-16-32768 | 16    | 32 GB | 1,030 GB  | SSD       |
| Litecoin            | `/etc/litecoin`  | e2-custom-2-11520  | 2     | 12 GB | 330 GB    | Balanced  |
| Polygon             | `/etc/polygon`   | n2d-standard-16    | 16    | 64 GB | 6,030 GB  | SSD       |
| XRPL                | `/etc/xrpl`      | n2d-standard-8     | 8     | 32 GB | 375 GB    | Local SSD |

</details>

## Prerequisites

Ensure you have:

- A Google Cloud account

- A service account with at least the following permissions (it can be created beforehand or during the launch process using GUI):

  - **roles/config.agent**
  - **roles/compute.admin**
  - **roles/iam.serviceAccountUser**

- Verify that your [Quotas and System Limits](https://cloud.google.com/docs/quotas/view-manage), located in **IAM and admin > Quotas and system limits**, meet the resource requirements for the blockchain node you intend to deploy. Refer to the [Supported blockchain nodes](#supported-blockchain-nodes) table for the specific resource requirements of each node. Adjust your quotas as needed to ensure sufficient resources are available.

## Setup a node

1. **Locate and launch the blockchain machine image**

   Head to the [Google Cloud Marketplace](https://console.cloud.google.com/marketplace/product/flare-public/blockchain-machine-image-flare-network).

   <img src={Step1} style={{ width: 500 }} />

   Click the **Launch** button to proceed.

2. **Configure basic settings**

   Choose the service account, source image, and region for your instance. To use an existing service account, click the **Existing account** button.

   <img src={Step2} style={{ width: 500 }} />

   Next, select the network where the node will be deployed, and configure basic firewall rules. Once done, click **Deploy**. This will launch a node with the deployment name, for example `flare-node`, in the **Compute Engine > VM instances**.

   <img src={Step2_1} style={{ width: 500 }} />

3. **Troubleshooting**

   If you encounter any issues during the deployment process, refer to the [Troubleshooting Section](#troubleshooting) for guidance.

## Connect to the node

Node operations are managed using the `nodectl` CLI tool.

```bash
sudo nodectl help
```

Configuration files are located in the `/etc/<node_name>` directory. For instance, Flare nodes will have their configurations in `/etc/flare`.

To start the node, connect to the instance and apply the services using:

```bash
# Applies all services configured in `/etc/<node_name>/config.yaml`
sudo nodectl apply --target all
```

## Verify node operation

The quickest way to verify that the node is running is by using the built-in health checks.
Logs can also be accessed in the `/var/log/<node_name>` directory, for example, `/var/log/flare`.

```bash
# Run health checks
sudo nodectl health
# Display detailed node information
sudo nodectl status
```

For live log monitoring, use `nodectl`:

```bash
sudo nodectl logs -f
```

For more log options, refer to the `journalctl` manual:

```bash
man journalctl
```

## Advanced Deployment with Terraform

Blockchain machine images can also be deployed using Terraform to meet advanced requirements,
such as replicating nodes, automating configuration, and scaling.

In this section, we provide an example which deploys two replicas of Flare nodes in the EU and US regions.
Source code is available in the [flare-foundation/bmi-terraform-examples](https://github.com/flare-foundation/bmi-terraform-examples) repository.

The first step is to obtain the latest blockchain machine image.
Start by navigating to the [Google Cloud Marketplace](https://console.cloud.google.com/marketplace/product/flare-public/blockchain-machine-image-flare-network) and click `LAUNCH`.
Then, switch to the `COMMAND-LINE DEPLOYMENT` tab and scroll down to the VM Image section, where you will find a table containing the latest images.
Copy the name of the latest image and update the locals in the `instance.tf` file accordingly.
Additionally, ensure that all required variables are correctly set in the `terraform.tfvars`, such as GCP project name, before proceeding.

```hcl
locals {
  replicas = {
    1 = {
      # update here
      image = ""projects/mpi-flare-public/global/images/flare---v1-...""
      zone  = ""europe-west1-c""
    },
    2 = {
      # update here
      image = ""projects/mpi-flare-public/global/images/flare---v1-...""
      zone  = ""us-west1-a""
    }
  }
}
```

Next, configure a firewall rule to allow external traffic from other peers in the network to access port `9651`.

```hcl
resource ""google_compute_firewall"" ""peering"" {
  project = var.gcp_project_name
  name    = ""flare-example-peering-tcp""
  network = ""default""

  allow {
    protocol = ""tcp""
    ports    = [""9651""]
  }

  source_ranges = [""0.0.0.0/0""]
  target_tags   = [""flare-example-peering""]
  priority      = ""600""
}
```

Optionally, you can create a service account with the necessary permissions to access a Slack webhook stored in GCP Secret Manager.
The node uses the secret's name to obtain the webhook and sends health alerts to Slack.

Each instance must define both startup and shutdown scripts.
The startup script handles node configuration tasks, such as enabling Promtail log scraping, node metrics, and Slack alerts.
Use tools such as `jq`, `yq` and `sed` to perform the configuration.

```bash
#!/bin/bash

#### Configure node ####
# Example
yq eval '.health_checks.slack_alerts.webhook_secret_name = ""example_slack_webhook_secret_name""' -i /etc/flare/config.yaml
yq eval '.health_checks.slack_alerts.enabled = true' -i /etc/flare/config.yaml

#### Start node ####
nodectl apply --target all
```

The shutdown script ensures the node shuts down gracefully.

```bash
#!/bin/bash

nodectl stop
```

Finally, all the previously mentioned files and resources are used to define instance resources,
which tie together the configuration, scripts, replication and permissions necessary for the node deployment.

```hcl
resource ""google_compute_instance"" ""this"" {
  for_each = local.replicas

  project = var.gcp_project_name
  name    = ""flare-node-example-replica-${each.key}""
  zone    = each.value.zone

  machine_type = ""n2d-standard-4""

  metadata = {
    startup-script = templatefile(""${path.module}/templates/startup.sh"", {})
    shutdown-script = templatefile(""${path.module}/templates/shutdown.sh"", {})
  }


  boot_disk {
    initialize_params {
      image = each.value.image
      type  = ""pd-balanced""
    }
  }

  network_interface {
    network = ""default""
    access_config {
      // Ephemeral public IP
    }
  }

  tags = google_compute_firewall.peering.target_tags

  service_account {
    email  = google_service_account.this.email
    scopes = [""cloud-platform""]
  }
}
```

## Troubleshooting

- **Deployment via UI failure due to Terraform state lock**

  - **Symptom**: The deployment fails, and clicking **Retry** leads to Terraform state lock errors.
  - **Solution**: Instead of retrying, delete the failed deployment and start a new one.

- **Deployment failure due to exceeded quotas**

  - **Symptom**: The deployment fails, displaying an error message in the logs similar to:
    ```
    Error: Error waiting for instance to create: Quota 'SSD_TOTAL_GB' exceeded.  Limit: 500.0 in region us-west1.
    metric name = compute.googleapis.com/ssd_total_storage
    limit name = SSD-TOTAL-GB-per-project-region
    limit = 500
    dimensions = map[region:us-west1]
    ```
  - **Solution**: Resource quotas need to be increased manually. To do this, refer to the [Quotas and System Limits documentation](https://cloud.google.com/docs/quotas/view-manage) and navigate to **IAM & Admin > Quotas**. After adjusting the quotas, delete the failed deployment and deploy a new one.",2025-03-08 01:27:14
4-fdc-attestation-provider.mdx,"sidebar_position: 4
slug: fdc-attestation-provider
title: FDC Attestation Provider
description: Provide attestations for FDC.",":::info

The FDC Provider deployment is now integrated into the [`flare-systems-deployment`](https://github.com/flare-foundation/flare-systems-deployment) repository, which also supports FTSO deployments. Previously, deployments were managed through the `ftso-v2-provider-deployment` repository.

The older repository is being deprecated. While it remains available for legacy deployments on Flare or Songbird, transitioning to the updated repository is strongly recommended. Active development has shifted to the new repository, where all future updates and features will be introduced. You can find the deprecation notice and detailed upgrade instructions [here](https://github.com/flare-foundation/ftso-v2-provider-deployment/tree/0.3.1-deprecation.2) until the information is merged into the official repository.

To run the FDC Client, you must also deploy verifiers and nodes that the client depends on. The [`fdc-suite-deployment`](https://github.com/flare-foundation/fdc-suite-deployment) repository contains comprehensive instructions for setting up and deploying these components.

If you already operate some of the required nodes, you can connect the FDC Client to those existing nodes, ensuring that the configurations remain compatible to avoid any operational issues.

:::",2025-03-08 01:27:14
6-flare-systems-provider.mdx,"sidebar_position: 6
title: Flare Systems Provider
description: Provide data for Flare's enshrined FTSO and FDC protocols.
unlisted: true","import Tabs from ""@theme/Tabs"";
import TabItem from ""@theme/TabItem"";
import ThemedImage from ""@theme/ThemedImage"";
import useBaseUrl from ""@docusaurus/useBaseUrl"";
import AutomatedRegistration from ""./_automated_registration.mdx"";

This guide provides a sample deployment configuration for infrastructure providers participating in the [Flare Systems Protocol (FSP)](https://dev.flare.network/network/fsp).
The FSP consists of [Flare Time Series Oracle (FTSO)](https://dev.flare.network/ftso/overview) and [Flare Data Connector (FDC)](https://dev.flare.network/fdc/overview).

<ThemedImage
  alt=""Data Provider System for FSP""
  sources={{
    light: useBaseUrl(""/img/run-node-fsp/fsp_run_node_light.svg""),
    dark: useBaseUrl(""/img/run-node-fsp/fsp_run_node_dark.svg""),
  }}
/>

An FSP provider system consists of the following six components:

1. **Flare System Client**: Manages interactions with FTSO smart contracts, including data collection, submission, voter registration, and system tasks.
2. **C-chain Indexer**: Tracks FSP-related blockchain transactions and events, enabling data calculations and action triggers.
3. **FTSO Client**: Provides anchor feed submissions and median data to the System Client.
4. **Fast Updates Client**: Submits block-latency feeds to Fast Updates contracts.
5. **Feed Value Provider**: Retrieves data from exchanges and supplies current feed values (prices).
6. **FDC Client**: Provides FDC protocol voting round data to the System Client.

## Hardware requirements

To deploy all FSP components on a single HW instance:

<Tabs groupId=""network"" block>
  <TabItem value=""flare"" label=""Flare Mainnet"" default>

    |                           | **Requirement** |
    |:--------------------------|:----------------|
    | **CPU**                   | 16/32 cores     |
    | **RAM**                   | 64 GB           |
    | **Disk space**            | 4 TB SSD        |

  </TabItem>
  <TabItem value=""coston2"" label=""Flare Testnet Coston2"">

    |                           | **Requirement** |
    |:--------------------------|:----------------|
    | **CPU**                   | 8 cores         |
    | **RAM**                   | 16 GB           |
    | **Disk space**            | 100 GB SSD      |

  </TabItem>
  <TabItem value=""songbird"" label=""Songbird Canary-Network"">

    |                           | **Requirement**  |
    |:--------------------------|:-----------------|
    | **CPU**                   | 16/32 cores      |
    | **RAM**                   | 64 GB            |
    | **Disk space**            | 4 TB SSD        |

  </TabItem>
  <TabItem value=""coston"" label=""Songbird Testnet Coston"">

    |                           | **Requirement** |
    |:--------------------------|:----------------|
    | **CPU**                   | 8 cores         |
    | **RAM**                   | 16 GB           |
    | **Disk space**            | 100 GB SSD      |

  </TabItem>
</Tabs>

- **Disk speed:** 1200 MB/s read and 600 MB/s write, or higher
- **Network speed:** 40 Mbps, or higher

## Prerequisites

Ensure you have the following tools installed:

- [Docker Engine](https://docs.docker.com/engine/install/)
- [yarn](https://yarnpkg.com/)
- [jq](https://jqlang.github.io/jq/)
- [envsubst](https://www.gnu.org/software/gettext/manual/html_node/envsubst-Invocation.html)

## Registration

Registration only needs to be performed once.

### Register addresses and key

<AutomatedRegistration />

Each entity in the FSP system must register the following five addresses:

- `Identity`: Main identity account of the voter. On mainnet this should be held in cold storage. This account is required for initial data provider setup, but is not used during each voting round.

- `Submit`: Used for sending commit and reveal transactions.

- `SubmitSignatures`: Used for sending voting round result signature transactions. (To avoid nonce conflicts, **Flare System Client** uses multiple accounts for submitting transactions).

- `SigningPolicy`: Used for signature generation during the voting round, and reward epoch signing policy signing (it's a system protocol ran once during reward epoch to establish reward epoch settings, including valid voters and their weights).

- `Delegation`: Account to which community should delegate funds (using `WNat` contract) to increase the vote power of the voter (identity/entity) - and also to later get the rewards.

To register you can directly call the `EntityManager` contract. For the contract address, see the [Solidity Reference](/network/solidity-reference). The relevant methods on the `EntityManager` contract are:

| Proposal method                                                                                                   | Confirmation method                                                                                                                       |
| ----------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------- |
| [`proposeSubmitAddress`](/network/fsp/solidity-reference/IEntityManager#proposesubmitaddress)                     | [`confirmSubmitAddressRegistration`](/network/fsp/solidity-reference/IEntityManager#confirmsubmitaddressregistration)                     |
| [`proposeSubmitSignaturesAddress`](/network/fsp/solidity-reference/IEntityManager#proposesubmitsignaturesaddress) | [`confirmSubmitSignaturesAddressRegistration`](/network/fsp/solidity-reference/IEntityManager#confirmsubmitsignaturesaddressregistration) |
| [`proposeSigningPolicyAddress`](/network/fsp/solidity-reference/IEntityManager#proposesigningpolicyaddress)       | [`confirmSigningPolicyAddressRegistration`](/network/fsp/solidity-reference/IEntityManager#confirmsigningpolicyaddressregistration)       |
| [`proposeDelegationAddress`](/network/fsp/solidity-reference/IEntityManager#proposedelegationaddress)             | [`confirmDelegationAddressRegistration`](/network/fsp/solidity-reference/IEntityManager#confirmdelegationaddressregistration)             |

First call the `propose...` from your `Identity` address and then the `confirm...` with the proposed address.

#### Fund addresses

All addresses need to be funded for gas fees. The `Delegation` account is used for establishing voter power, which can be achieved by wrapping funds directly or by delegation from other accounts. Wrapping can be done via:

- [Development Portal](https://governance.dev.aflabs.org/) for Flare Testnet Coston2 and Songbird Testnet Coston
- [Flare Portal](https://portal.flare.network) for Flare Mainnet and Songbird Canary-Network.

:::note[Ensure sufficient vote power]

The protocol operation uses normalized weights, and the `Delegation` address should have at least 150 WNat to obtain a non-zero vote power.

| **Network**             | **Native Token** | **Wrapped Native Token (WNat)** |
| ----------------------- | ---------------- | ------------------------------- |
| Flare Mainnet           | FLR              | WFLR                            |
| Flare Testnet Coston2   | C2FLR            | WC2FLR                          |
| Songbird Canary-Network | SGB              | WSGB                            |
| Songbird Testnet Coston | CFLR             | WCFLR                           |

The WNat contract addresses are in the [Network Solidity Reference](/network/solidity-reference).

:::

#### Register sortition key

Generate a sortition key to use in Fast Updates. You can use the [fast-updates/go-client](https://github.com/flare-foundation/fast-updates/tree/main/go-client) docker image to generate a key:

```bash
docker run --rm ghcr.io/flare-foundation/fast-updates/go-client:latest keygen
```

Accounts for Fast Updates submission need to be generated and funded with gas fees.
These can be any accounts **not used** for the five accounts in [register addresses and key](#register-addresses-and-key).
You are recommended to use **three** separate accounts to avoid nonce conflicts.

When registering the sortition key using the explorer, you will need to manually create a signature:

```bash
docker run --rm ghcr.io/flare-foundation/fast-updates/go-client:latest keygen --key <sortitionKeyPrivateKey> --address <identityAddress>
```

Register the generated sortition key and signature via the `EntityManager` contract by calling [`registerPublicKey`](/network/fsp/solidity-reference/IEntityManager#registerpublickey) with your identity address, use the signature generated by the previous command as the input to `_verificationData`.

### Register validator node

To register your validator node, call the `EntityManager` contract's [`registerNodeId`](/network/fsp/solidity-reference/IEntityManager#registernodeid) function by providing your identity address for each validator node.

#### Required Input Arguments

- **`_nodeId`**: 20-byte node ID in hexadecimal format.
- **`_certificateRaw`**: Raw certificate bytes in hexadecimal format.
- **`_signature`**: Signature bytes in hexadecimal format.

#### Registration Steps

1. **Locate Certificate and Private Key Files**

   Find the certificate (`.crt`) and private key (`.key`) files for your validator node. The default file paths are:

   - `~/.avalanchego/staking/staker.key`
   - `~/.avalanchego/staking/staker.crt`

2. **Set Environment Variables**

   Define necessary environment variables by copying and pasting the following snippet into your terminal:

   ```bash
   PATH_TO_CRT=~/.avalanchego/staking/staker.crt
   ZERO_PREFIX=0000000000000000000000000000000000000000000000000000000000000000
   PATH_TO_KEY=~/.avalanchego/staking/staker.key
   IDENTITY_ADDRESS=<YourIdentityAddressWithout0xPrefix>
   ```

3. **Generate required hex values**

   **`_nodeId`:** If you are using an older version of `openssl`, omit the `-provider legacy` flag.

   ```bash
   cat $PATH_TO_CRT | tail -n +2 | head -n -1 | base64 -d | openssl dgst -sha256 -binary | openssl rmd160 -provider legacy -binary | xxd -p | sed -e 's/^/0x/;'
   ```

   **`_certificateRaw`:**

   ```bash
   cat $PATH_TO_CRT | tail -n +2 | head -n -1 | base64 -d | xxd -p | tr -d '\n' | sed -e 's/^/0x/;' && echo
   ```

   **`_signature`:**

   ```bash
   echo -n $ZERO_PREFIX$IDENTITY_ADDRESS | xxd -r -p | openssl dgst -sha256 -sign $PATH_TO_KEY | xxd -p | tr -d '\n' | sed -e 's/^/0x/;' && echo
   ```

## Setup FDC

The FDC suite integrates blockchain data sources through a network of blockchain nodes, indexers, and API servers. This setup allows secure and efficient data verification. The blockchain data flow is of two types:

- **UTXO-Based Chains** (Bitcoin, Dogecoin, Ripple): Use an indexer to create a local database from the blockchain, exposing data through a Verifier API server.

- **EVM Chains** (Ethereum, Flare, Songbird): Directly query the RPC node using the Verifier API server.

### Required components

You can use the following components to run a full FDC suite.

#### Blockchain node images

| Network  | Blockchain node image                                                                                                                      |
| -------- | ------------------------------------------------------------------------------------------------------------------------------------------ |
| Bitcoin  | [flarefoundation/bitcoin](https://hub.docker.com/r/flarefoundation/bitcoin)                                                                |
| Dogecoin | [flarefoundation/dogecoin](https://hub.docker.com/r/flarefoundation/dogecoin)                                                              |
| Ripple   | [flarefoundation/rippled](https://hub.docker.com/r/flarefoundation/rippled)                                                                |
| Ethereum | [ethereum/client-go](https://hub.docker.com/r/ethereum/client-go) & [prysm](https://docs.prylabs.network/docs/install/install-with-docker) |

#### Indexers and verifiers

| Network | Indexer                                                                                             | Verifier                                                                                          |
| ------- | --------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------- |
| BTC     | [flare-foundation/verifier-utxo-indexer](https://github.com/flare-foundation/verifier-utxo-indexer) | [flare-foundation/verifier-indexer-api](https://github.com/flare-foundation/verifier-indexer-api) |
| DOGE    | [flare-foundation/verifier-utxo-indexer](https://github.com/flare-foundation/verifier-utxo-indexer) | [flare-foundation/verifier-indexer-api](https://github.com/flare-foundation/verifier-indexer-api) |
| XRP     | [flare-foundation/verifier-xrp-indexer](https://github.com/flare-foundation/verifier-xrp-indexer)   | [flare-foundation/verifier-indexer-api](https://github.com/flare-foundation/verifier-indexer-api) |
| EVM     | -                                                                                                   | [flare-foundation/evm-verifier](https://github.com/flare-foundation/evm-verifier)                 |

:::info

- Flare Mainnet and Songbird Canary-Network nodes are required for EVM verification but are not listed here.
- You are not required to use exactly these components, eg. if you already have a compatible Bitcoin RPC node, you can configure your deployment to run everything else except for Bitcoin node.
- You can split the deployment across multiple servers.

:::

### Configuring blockchain nodes

Start by cloning the [fdc-suite-deployment](https://github.com/flare-foundation/fdc-suite-deployment.git) repo:

```bash
git clone https://github.com/flare-foundation/fdc-suite-deployment.git
cd fdc-suite-deployment
```

#### Bitcoin (BTC)

Generate the authentication password:

```bash
cd nodes-mainnet/btc
./generate-password.sh
```

Sample output:

```plaintext
password: c021cae645db6d3371b26ced94c8d17a5d9f3accbf3591d8b4c0be19623e5662
String to be appended to bitcoin.conf:
rpcauth=admin:a0956d81a2344f1602d9ed7b82ef3118$2caf19c9cf27937f728f600fc14e8db97f80218d727e331a57c3cfc55b3e17fe
Your password:
c021cae645db6d3371b26ced94c8d17a5d9f3accbf3591d8b4c0be19623e5662
```

Alternatively you can configure the username and password manually:

```bash
./rpcauth.py <USERNAME> <PASSWORD>
```

#### Dogecoin (DOGE)

Same configuration process as Bitcoin.

```bash
cd nodes-mainnet/doge
./generate-password.sh
```

#### Ripple (XRP)

No additional configuration required.

#### Ethereum (ETH)

Generate JWT for Authentication:

```bash
openssl rand -hex 32 > nodes-mainnet/eth/jwt.hex
```

:::warning

Blockchain nodes expose all ports by default.

:::

### Configuring indexers and verifiers

1. Copy `.env.example` into `.env`:

   ```bash
   cp .env.example .env
   ```

2. Configure required keys

   - **RPC Nodes Authentication:** Use credentials generated earlier. If you run blockchain nodes and verifiers on the same server, you can use the ip `172.17.0.1` to reach the nodes.

   - **Start Block Number:** Set `*_START_BLOCK_NUMBER` to a block finalized 14 days ago. This needs to be set the first time when you start the indexers to avoid indexing too much data. FDC requires at least 14 days of history. On later restarts indexers will start indexing from the latest block in the database.

   - **Testnet Mode:** Set `TESTNET=true` if using testnets.
   - **API Keys:** Configure `VERIFIER_API_KEYS` with comma-separated API keys. One or more comma separated keys can be configured. You will likely need at least one key for FDC client that will call verifier api servers.
   - **Database Passwords:** Set `*_DB_PASSWORD` variables to random strings. These are used internally for the indexer database.

3. Generate configuration files

   ```bash
   ./generate-config.sh
   ```

   This script populates config files from `*.example` templates in:

   - `verifiers/btc/`
   - `verifiers/doge/`
   - `verifiers/xrp/`
   - `evm-verifier/`

### Start services

#### Start blockchain nodes

1. Go to the directory for the specific blockchain node you want to run, e.g. `nodes-mainnet/btc`

2. Start the node:

   ```bash
   docker compose up -d
   ```

_Repeat these steps for each blockchain node you intend to run._

#### Start indexers and verifiers

1. Go to the appropriate verifier directory, e.g. `verifiers/btc`

2. Start the verifier:

   ```bash
   docker compose up -d
   ```

_Repeat these steps for all verifiers you intend to run._

## Setup FTSO

### Feed value provider

:::warning

The reference implementation of Feed Value Provider is **only provided for testing purposes and should not be relied on**.
Data providers are expected to reimplement this with their own data sources, following the [REST API specification](https://github.com/flare-foundation/ftso-v2-example-value-provider?tab=readme-ov-file#example-usage).

:::

Start your own feed value provider, or **(for testing only)** use the reference feed value provider:

```bash
docker run --rm -it --publish ""0.0.0.0:3101:3101"" --network ""ftso-v2-deployment_default"" ghcr.io/flare-foundation/ftso-v2-example-value-provider
```

Once the container is running, you can find the API spec at: http://localhost:3101/api-doc

#### Troubleshooting

For initial testing a fixed value provider can be used that simply returns a constant instead of reading data from external data sources. It can be started by setting the variable `VALUE_PROVIDER_IMPL=fixed`:

```bash
docker run --rm -it --env VALUE_PROVIDER_IMPL=fixed --publish ""0.0.0.0:3101:3101"" --network ""ftso-v2-deployment_default"" ghcr.io/flare-foundation/ftso-v2-example-value-provider
```

You should see the following line in the logs:

```plaintext
WARN [FixedFeed] Initializing FixedFeed, will return 0.01 for all feeds.
```

## Generate configuration and deploy

1. Clone [flare-systems-deployment](https://github.com/flare-foundation/flare-systems-deployment) repository:

   ```bash
   git clone https://github.com/flare-foundation/flare-systems-deployment.git
   cd flare-systems-deployment
   ```

2. Copy the sample configuration file:

   ```bash
   cp .env.example .env
   ```

3. Fill out all the values using the information from [Registration](#registration), [Setup FDC](#setup-fdc) and [Setup FTSO](#setup-ftso).

4. Generate the required configurations, you will need to rerun this command if you change your `.env` file:

   ```bash
   ./populate_config.sh
   ```

5. Deploy the instance with the provided `docker-compose.yaml`

   ```bash
   docker compose up -d
   ```

   :::info[Stay up to date]

   To pull the latest `flare-systems-deployment` image:

   ```bash
   docker compose pull
   ```

   ::::

## Troubleshooting

- **`system-client` is not doing anything**

  Llikely, your entity is not registered as a voter for the current reward epoch. There is a time window for voter registration on every reward epoch, and if you leave things running you should eventually see `RegisterVoter success` in the logs. It should then start submitting data successfully in the **following** reward epoch.

- **`system-client` fails to fetch sub-protocol data**

  The `c-chain-indexer` may still be indexing data, once it's finished you should see `Indexer at block x` in the logs. If it's still processing blocks you will see various errors across all services.

- **`fast-updates` client is not doing anything**

  If you have low weight it may take some time until you are selected to submit an update.",2025-03-08 01:27:14
3-ftso-data-provider.mdx,"sidebar_position: 3
slug: ftso-data-provider
title: FTSO Data Provider
description: Provide block-latency and anchor feeds for FTSOv2.",":::info

The FTSO Provider deployment is now integrated into the [`flare-systems-deployment`](https://github.com/flare-foundation/flare-systems-deployment) repository, which also supports FDC deployments. Previously, deployments were managed through the `ftso-v2-provider-deployment` repository.

The older repository is being deprecated. While it remains available for legacy deployments on Flare or Songbird, transitioning to the updated repository is strongly recommended. Active development has shifted to the new repository, where all future updates and features will be introduced. You can find the deprecation notice and detailed upgrade instructions [here](https://github.com/flare-foundation/ftso-v2-provider-deployment/tree/0.3.1-deprecation.2) until the information is merged into the official repository.

For additional information and updates, please follow us on the [Flare forum](https://forum.flare.network/).

:::",2025-03-08 01:27:14
2-getting-started.mdx,"sidebar_position: 2
unlisted: false
title: Getting Started
description: Learn how to verify data from other chains using FDC.
keywords:
  [
    fdc,
    oracle,
    flare-data-connector,
    flare-network,
    smart-contracts,
    solidity,
    remix,
  ]","import Remix from ""@site/src/components/remix"";
import CodeBlock from ""@theme/CodeBlock"";
import YoutubeEmbed from ""@site/src/components/youtube"";
import FDCTransferEventListener from ""!!raw-loader!/examples/developer-hub-solidity/FDCTransferEventListener.sol"";
import PrepareRequest from ""!!raw-loader!/examples/developer-hub-javascript/fdc_prepare_request.ts"";
import SubmitRequest from ""!!raw-loader!/examples/developer-hub-javascript/fdc_submit_request.ts"";
import GetProof from ""!!raw-loader!/examples/developer-hub-javascript/fdc_get_proof.ts"";
import VerifyProof from ""!!raw-loader!/examples/developer-hub-javascript/fdc_verify_proof.ts"";

The Flare Data Connector (FDC) is a powerful cross-chain protocol that enables smart contracts on Flare to securely access and verify data from other blockchains.
This section demonstrates how to bridge data across chains and attest to events on EVM networks, with practical examples using the Ethereum testnet (Sepolia) and Flare Network.

:::info[New to smart contract development?]

Learn how to [deploy your first smart contract](/network/getting-started) on Flare before you start this guide, or explore the [official starter kits](/network/guides/hardhat-foundry-starter-kit) for Hardhat and Foundry.

:::

At its core, FDC enables any smart contract on Flare to query immutable, verifiable information from supported blockchain networks. The protocol achieves consensus through the BitVote-reveal mechanism within the Flare Systems Protocol suite, allowing dapps to validate external blockchain data using Merkle proofs.

Currently supported networks include:

- **Non smart-contract**: Bitcoin, Dogecoin, and XRP Ledger (including their testnets)
- **Smart-contract**: Ethereum, Songbird, and Flare (including Sepolia, Songbird Testnet Coston, and Flare Testnet Coston2)

The protocol's extensible design allows for future integration of additional blockchains and attestation types, making it a foundation for cross-chain interoperability.

## Process overview

This guide demonstrates how to use the [EVMTransaction](/fdc/attestation-types/evm-transaction) attestation type to verify and utilize transaction data from external EVM chains on Flare.
You'll create a smart contract and accompanying script that interact with the FDC to verify Ethereum transactions and decode their event data.

Here's how the attestation process works:

1. **Identify the transaction**

   For this guide, we'll use an existing transaction on the Sepolia testnet that contains event data we want to verify on Flare.
   In a real dapp, you might identify transactions based on user actions or specific event emissions.

2. **Prepare the attestation request**

   To prepare the attestation request, transaction data must be encoded in a FDC-compatible format.
   While this can be done manually, we'll use Flare's verifier service for simplicity.
   Note that while Flare provides rate-limited verifiers suitable for development,
   production applications should use their own verifier service.

3. **Submit the attestation request**

   Once encoded, the attestation request is submitted to the FDC, initiating the consensus protocol.
   After consensus is reached, FDC stores the Merkle root of the attested data on the Flare network.

4. **Extract proof and data**

   After the Merkle root is stored on-chain, we'll use the Data Availability (DA) Layer service to retrieve the complete transaction data for our smart contract logic and the Merkle proof needed to verify the data's authenticity.

5. **Verify and use the data**

   Our smart contract will then verify that the provided transaction data matches what was attested in the Merkle root.
   Once verified, it will decode the event log data and integrate it into the contract's logic, enabling secure cross-chain data flow in your applications.

## Identify the transaction

For this guide, we'll use a pre-existing transaction on the Sepolia testnet: [`0x4e636c6590b22d8dcdade7ee3b5ae5572f42edb1878f09b3034b2f7c3362ef3c`](https://sepolia.etherscan.io/tx/0x4e636c6590b22d8dcdade7ee3b5ae5572f42edb1878f09b3034b2f7c3362ef3c).
This transaction is particularly useful for our demonstration as it contains both an ERC20 `Transfer` event and a `Swap` event, providing clear examples of cross-chain event verification.

:::info[Confirmation Requirements]

Each blockchain connected to FDC has specific confirmation requirements that must be met before data can be attested. For EVM chains, you can configure the required number of confirmations based on the chain's finality and security guarantees.
See the [connected blockchain documentation](/fdc/attestation-types/confirmed-block-height-exists#finality) for detailed requirements.

:::

:::info[Mainnets and testnets]

The Data Connector operates in separate environments for mainnets and testnets, when working with testnets:

- Use different base URLs for the attestation client and DA Layer
- Specify `testETH` instead of `ETH` as the source network name in transaction encoding
- All other procedures and code remain consistent across environments

:::

## Prepare the attestation request

To attest to transaction data, we need to encode it in a format that the Flare Data Connector (FDC) can process.
This is done through a verifier service. While you can set up your own verifier, we'll use Flare's testnet verifier service available at `https://fdc-verifiers-testnet.flare.network/`.
You can explore the API through their Swagger interface at `https://fdc-verifiers-testnet.flare.network/verifier/api-doc`.

### Request structure

To prepare an attestation request, you can use the `prepareRequest` endpoint with the following JSON structure:

```json
{
  ""attestationType"": ""0x45564d5472616e73616374696f6e000000000000000000000000000000000000"",
  ""sourceId"": ""0x7465737445544800000000000000000000000000000000000000000000000000"",
  ""requestBody"": {
    ""transactionHash"": ""0x4e636c6590b22d8dcdade7ee3b5ae5572f42edb1878f09b3034b2f7c3362ef3c"",
    ""requiredConfirmations"": ""1"",
    ""provideInput"": true,
    ""listEvents"": true,
    ""logIndices"": []
  }
}
```

The request contains three main components:

- `attestationType`: Specifies ""EVMTransaction"" as a 32-byte padded hex string.
- `sourceId`: Identifies the source chain (""testETH"" for Sepolia testnet) as a 32-byte padded hex string.
- `requestBody`: Contains transaction-specific parameters including:
  - `transactionHash`: Transaction hash to verify.
  - `requiredConfirmations`: Number of required confirmations.
  - `provideInput`: Boolean specifying if the input data of the toplevel transaction should be included in the response.
  - `listEvents`: Flags for including transaction input and event logs.
  - `logIndices`: Optional log indices (maximum 50 logs per request).

For full details, see the EVMTransaction](/fdc/attestation-types/evm-transaction) type specification.

### Implementation example

Here's a TypeScript script that prepares the attestation request:

<CodeBlock language=""typescript"" title=""prepare_request.ts"">
  {PrepareRequest}
</CodeBlock>

### Verifier response

Upon successful validation, the verifier returns:

```json
{
  ""status"": ""VALID"",
  ""abiEncodedRequest"": ""0x45564d5472616e73616374696f6e00000000000000000000000000000000000074657374455448000000000000000000000000000000000000000000000000009d410778cc0b2b8f1b8eaa79cbd0eed5d3be7514dea070e2041ad00a4c6e88f800000000000000000000000000000000000000000000000000000000000000204e636c6590b22d8dcdade7ee3b5ae5572f42edb1878f09b3034b2f7c3362ef3c00000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000000""
}
```

- `status`: Indicates that the verifier recognized this attestation request as valid.
- `abiEncodedRequest`: Contains all the data necessary for the FDC attestation providers to confirm this request.

This encoded request can now be submitted to the FDC contract.
The attestation clients will pick up the request and include it in the next FDC consensus round.
If consensus is reached, your attestation will be included in that round's Merkle root, making it available for use.
If consensus fails, you'll need to resubmit the request.

<details>
    <summary>Understanding the structure of `abiEncodedRequest`.</summary>

    The structure of `abiEncodedRequest` may seem complex, but it's essentially a concatenated hex string (with the initial 0x removed) representing different parts of the request. Each part is 32 bytes long (64 characters in hex). Here's a breakdown of the string:

    ```text
    45564d5472616e73616374696f6e000000000000000000000000000000000000
    7465737445544800000000000000000000000000000000000000000000000000
    9d410778cc0b2b8f1b8eaa79cbd0eed5d3be7514dea070e2041ad00a4c6e88f8
    0000000000000000000000000000000000000000000000000000000000000020
    4e636c6590b22d8dcdade7ee3b5ae5572f42edb1878f09b3034b2f7c3362ef3c
    0000000000000000000000000000000000000000000000000000000000000001
    0000000000000000000000000000000000000000000000000000000000000001
    0000000000000000000000000000000000000000000000000000000000000001
    00000000000000000000000000000000000000000000000000000000000000a0
    0000000000000000000000000000000000000000000000000000000000000000
    ```

    You can decode the first two parts using an online tool like [playcode.io](https://playcode.io/1752890).

    Breaking it down line-by-line:

    - **First line:** `toHex(""EVMTransaction"")`

    - **Second line:** `toHex(""testETH"")`

    - **Third line:** Message Integrity Code (MIC). This is a hash of the whole response salted with a string `Flare`. It ensures the integrity of the attestation and prevents tampering.

    - **Remaining lines:** ABI encoded request body (as solidity struct).
      The structure of the body is defined in the accompanying attestation [type specification](https://github.com/flare-foundation/songbird-state-connector-protocol/blob/main/contracts/interface/types/EVMTransaction.sol#L68).
      As we supply a list, the encoding is a bit more complicated, but you can easily spot the `transactionHash` as `4e636c6590b22d8dcdade7ee3b5ae5572f42edb1878f09b3034b2f7c3362ef3c`.

</details>

## Submit the attestation request

Once we have our encoded attestation request, we'll submit it to the Flare Data Connector (FDC) smart contract through the `requestAttestation` method on [FDCHub](/fdc/reference/IFdcHub).
This broadcasts our request to the network and initiates the verification process.
The attestation will be processed in the current FDC round, which typically finalizes within 90-180 seconds.

:::info

While you can retrieve a proof before round finalization, it won't be valid until the round completes and its Merkle root is stored on-chain.

:::

Here's how to submit the request and calculate its `roundId`:

<CodeBlock language=""typescript"" title=""submit_request.ts"">
  {SubmitRequest}
</CodeBlock>

After submitting the request, wait for round finalization before proceeding to proof extraction and verification.

## Extract proof and data

Once the FDC round is finalized and its Merkle root is stored on-chain, we can retrieve the full data and proof for our attestation request.
The Data Availability (DA) Layer API provides a streamlined way to access this information.

### Using the DA Layer API

While a rate-limited public endpoint [is available](/fdc/reference/data-availability-api), you should set up your [own DA Layer service](https://github.com/flare-foundation/data-availability) for production use.

```json
{
  ""roundId"": FDC_ROUND_ID,
  ""requestBytes"": ""0xABI_ENCODED_REQUEST""
}
```

We are providing the same `abiEncodedRequest` that we used to request the attestation, and the `roundId` that we calculated when we submitted the request.
Here's how to retrieve the proof and data:

<CodeBlock language=""typescript"" title=""get_proof.ts"">
  {GetProof}
</CodeBlock>

### Response structure

The API returns two key components:

- `response`: Contains the complete transaction data, including:

  - Attestation type and source chain
  - Transaction details (block number, timestamp, addresses)
  - Input data and execution status
  - Emitted events and their details

- `proof`: Contains the Merkle proof array, verifying that the data exists in the round's Merkle tree

Here's a simplified example of the response structure:

```json
{
  ""response"": {
    ""attestationType"": ""0x45564d5472616e73616374696f6e000000000000000000000000000000000000"",
    ""sourceId"": ""0x7465737445544800000000000000000000000000000000000000000000000000"",
    ""votingRound"": ""859315"",
    ""lowestUsedTimestamp"": ""1735543584"",
    ""requestBody"": {
      ""transactionHash"": ""0x4e636c6590b22d8dcdade7ee3b5ae5572f42edb1878f09b3034b2f7c3362ef3c"",
      ""requiredConfirmations"": ""1"",
      ""provideInput"": true,
      ""listEvents"": true,
      ""logIndices"": []
    },
    ""responseBody"": {
      ""blockNumber"": ""7384262"",
      ""timestamp"": ""1735543584"",
      ""sourceAddress"": ""0x70ad32b82b4fe2821c798e628d93645218e2a806"",
      ""isDeployment"": false,
      ""receivingAddress"": ""0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad"",
      ""value"": ""61000000000000000"",
      ""input"": ""0x3593564c000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000000000000000000000000000000000006772521a00000000000000000000000000000000000000000000000000000000000000040b000604000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000e0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000002800000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000d8b72d434c80000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000d8b72d434c8000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002bfff9976782d46cc05630d1f6ebab18b2324d6b140001f41c7d4b196cb0c7b01d743fbc6116a902379c723800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000600000000000000000000000001c7d4b196cb0c7b01d743fbc6116a902379c7238000000000000000000000000e49acc3b16c097ec88dc9352ce4cd57ab7e35b95000000000000000000000000000000000000000000000000000000000000001900000000000000000000000000000000000000000000000000000000000000600000000000000000000000001c7d4b196cb0c7b01d743fbc6116a902379c723800000000000000000000000070ad32b82b4fe2821c798e628d93645218e2a80600000000000000000000000000000000000000000000000000000000ad2090e40c"",
      ""status"": ""1"",
      ""events"": [
        {
          ""logIndex"": 63,
          ""emitterAddress"": ""0xfff9976782d46cc05630d1f6ebab18b2324d6b14"",
          ""topics"": [
            ""0xe1fffcc4923d04b559f4d29a8bfc6cda04eb5b0d3c460751c2402c5c5cc9109c"",
            ""0x0000000000000000000000003fc91a3afd70395cd496c647d5a6cc9d4b2b7fad""
          ],
          ""data"": ""0x00000000000000000000000000000000000000000000000000d8b72d434c8000"",
          ""removed"": false
        }
        // Additional events...
      ]
    }
  },
  ""proof"": [
    ""0x54124eb68914f7ef9017f47328b02af8a61bc9ed4e276d9e09c725df2056b38e"",
    ""0x2ee26beac9f7da0cea28ba8b13f49ca8f6477bb82d839ca1e808ceac2d551427"",
    ""0xf8265e7b0c7165ba16111fbf8d1f0e2e279e44b77ff343393fd2269353f2adfa""
  ]
}
```

This data is now ready to be used in your smart contract to:

- Verify the data's authenticity using the Merkle proof
- Process the transaction data and event logs for your contract's logic

## Verify and use the data

Let's examine how to verify and utilize the data from the DA Layer API in your smart contract. We'll focus on a practical example: listening for and verifying USDC transfer events.

### Data structure

The response data maps directly to the [`IEVMTransaction`](/fdc/reference/IEVMTransaction) interface, which is already included in both Hardhat and Foundry packages.
Here's what you'll work with:

- `requestBody`: Contains your original attestation request parameters
- `responseBody`: Contains the verified transaction data:
  - Block details (number, timestamp)
  - Transaction details (addresses, value, status)
  - Emitted events (logs, topics, data)

Here's a simplified version of the key response structures:

```solidity
struct Response {
    bytes32 attestationType;
    bytes32 sourceId;
    uint64 votingRound;
    uint64 lowestUsedTimestamp;
    RequestBody requestBody;
    ResponseBody responseBody;
}

struct ResponseBody {
    uint64 blockNumber;
    uint64 timestamp;
    address sourceAddress;
    bool isDeployment;
    address receivingAddress;
    uint256 value;
    bytes input;
    uint8 status;
    Event[] events;
}

struct Event {
    uint32 logIndex;
    address emitterAddress;
    bytes32[] topics;
    bytes data;
    bool removed;
}
```

### Implementation example

The response consists of several key components:

1. `requestBody`: Contains an exact copy of your original attestation request data.

2. `metadata`: Includes verification-critical information:

   - `votingRound`: Identifies the specific FDC consensus round
   - `lowestUsedTimestamp`: Ensures data freshness and proper round assignment

3. `responseBody`: Contains the verified transaction details:
   - Basic information: block number, timestamp, addresses, value
   - Transaction status and input data
   - Complete list of emitted events, each containing:
     - Log index and emitter address
     - Event topics and data
     - Chain reorganization status flag

<CodeBlock language=""solidity"" title=""FDCTransferEventListener.sol"">
  {FDCTransferEventListener}
</CodeBlock>

{/* prettier-ignore */}
<Remix fileName=""FDCTransferEventListener.sol"">Open in Remix</Remix>
<br></br>

:::warning

Don't forget to set the EVM version to `london` in Remix before compiling the contract.

:::

### Using the contract

1. **Proof Verification**

   The contract uses the `ContractRegistry` library to access Flare's official verifiers. The verification process:

   - Retrieves the current verifier through the Flare governance-managed registry
   - Uses `isEVMTransactionProofValid` to verify the Merkle proof and data integrity
   - Requires successful verification before proceeding with any data processing

2. **Event Processing**

   After verification, the `collectTransferEvents` function handles the business logic:

   - Processes the verified transaction data
   - Filters for USDC Transfer events
   - Decodes and stores relevant event data

This two-phase approach provides robust security against malicious data providers:

- While the data comes from an off-chain source (DA Layer API), it must match the on-chain Merkle root
- Any attempt to provide manipulated data will fail at the proof verification stage
- Only data that has achieved consensus through the FDC protocol can pass verification

To use the contract, simply retrieve the proof from the DA Layer API and submit it:

<CodeBlock language=""typescript"" title=""verify_proof.ts"">
  {VerifyProof}
</CodeBlock>

## Wait for round finalization (optional)

Before using a proof, you must ensure the FDC round has been finalized and its Merkle root accepted.
Here are the recommended approaches for different scenarios:

**Production environment:** Use the `Relay` contract's event system:

- Access the latest `Relay` contract through `ContractRegistry`
- Listen for the `ProtocolMessageRelayed` event with:
  - `protocolId`: 200 (FDC protocol identifier)
  - `roundId`: Your submitted round ID

**Testing environment:** For testing, you can use the `Relay` contract's view method

```solidity
isFinalized(uint256 _protocolId, uint256 _votingRoundId) returns (bool)
```

## Watch the video

<YoutubeEmbed embedLink=""bURtt4siWd0?si=tVnpU0SC7ISMnrA0""></YoutubeEmbed>",2025-03-08 01:27:14
3-attestation-types.mdx,"title: Attestation Types
description: Learn about different attestation types supported by FDC.
keywords: [fdc, oracle, flare-data-connector, flare-network]
sidebar_position: 3","import DocCardList from ""@theme/DocCardList"";

**FDC Attestations** provide cryptographic proofs for data originating outside Flare's EVM state. They enable smart contracts to verify external data trustlessly. For example, FDC attestations can validate:

- **Non-Payment Verification:** Confirm whether a payment **has not been made** on a UTXO chains like Bitcoin or Dogecoin.
- **Event Log Authentication:** Verify event logs generated by transactions on EVM-compatible blockchains.

FDC currently supports the following six attestation types:

<DocCardList />",2025-03-08 01:27:14
1-overview.mdx,"sidebar_position: 1
slug: overview
title: FDC Overview
authors: [lukaavbreht, filipkoprivec]
description: The Flare Data Connector (FDC) enables secure, on-chain attestation of external data.
tags: [intermediate, ethereum, fdc]
keywords: [ethereum, flare-data-connector, evm, flare-network]
unlisted: false","import ThemedImage from ""@theme/ThemedImage"";
import useBaseUrl from ""@docusaurus/useBaseUrl"";

The **Flare Data Connector (FDC)** is an [enshrined oracle](/support/terminology#enshrined-oracle) designed to validate external data for Flare's EVM state.
It allows users to submit attested data that smart contracts can trust, eliminating the need for direct reliance on users for data integrity.

## Key Features

- **Network-Level Security**: Data attestation requires reaching a 50%+ signature weight from data providers, ensuring decentralized consensus.
- **Efficient On-chain Storage**: Verified data is stored in a Merkle tree, with only the Merkle root stored on-chain to minimize costs.
- **Easy Off-chain Accessibility**: Data providers serve attestation responses and Merkle proofs off-chain through a Data Availability (DA) Layer, ensuring efficient data retrieval.
- **Proof-Based Verification**: Smart contracts validate Merkle proofs against the stored Merkle root, ensuring only authentic data triggers contract actions.
- **Extensible Attestation Types**: New attestation types and data sources can be added through provider consensus, ensuring adaptability.

## Architecture

<ThemedImage
  alt=""FDC Architecture Diagram""
  sources={{
    light: useBaseUrl(""img/fdc-overview/fdc_architecture_light.svg""),
    dark: useBaseUrl(""img/fdc-overview/fdc_architecture_dark.svg""),
  }}
/>

1. **Data Verification**: The FDC verifies user-submitted attestation requests.
2. **Merkle Representation**: Verified responses are organized into a Merkle tree, with only the Merkle root stored on-chain.
3. **Attestation Usage**: Users retrieve attestation responses and Merkle proofs from data providers and submit them to smart contracts.

:::tip[Interested in learning more?]
For a detailed explanation of the FDC mechanism, read the [FDC whitepaper](https://flare.network/wp-content/uploads/FDC_WP_171024_02.pdf).
:::

### Data Availability Layer

The Data Availability Layer (DA Layer) provides API endpoints for querying off-chain attestation data.
Accessing this data is trustless, as users can independently compute and compare Merkle roots against the on-chain version.

Operating a DA Layer is permissionless‚Äîanyone can run a DA Layer service by sourcing data from an [FTSOv2 data provider](/run-node/ftso-data-provider) and [FDC attestation provider](/run-node/fdc-attestation-provider).

<ThemedImage
  alt=""DA Layer Diagram""
  sources={{
    light: useBaseUrl(""img/fdc-overview/da_layer_light.svg""),
    dark: useBaseUrl(""img/fdc-overview/da_layer_dark.svg""),
  }}
/>

## Attestation Types

FDC currently supports seven attestation types, each serving specific verification needs. Below is an overview of these types, with detailed explanations available in their respective sections:

- **AddressValidity**: Validates the format and checksum of addresses on specified chains.
- **EVMTransaction**: Verifies and retrieves transaction details from EVM-compatible chains (`ETH`, `FLR`, `SGB`).
- **JsonApi**: Fetches and processes any Web2 data using a JQ transformation, then returns it as ABI-encoded output. (Currently only on Coston & Coston2).
- **Payment**: Confirms and fetches payment transaction details from non-EVM chains (`BTC`, `DOGE`, `XRP`).
- **ConfirmedBlockHeightExists**: Verifies block existence and confirmation status.
- **BalanceDecreasingTransaction**: Validates if a transaction reduces an address's balance.
- **ReferencedPaymentNonexistence**: Confirms the absence of specific payments within time intervals.

The first three attestation types are the most generally useful, while the last three are primarily used in **FAssets**.

## Workflow Overview

For all attestation types, the workflow follows the same general steps.
Due to the waiting period between steps **2** and **3**, where the round is finalized, the process is split into multiple sections.

### General Workflow

1. **Request Submission**: Users submit attestation requests to the [`FdcHub`](/fdc/reference/IFdcHub) smart contract.
2. **Batch Processing**: Data providers group requests based on emission timestamps.
3. **Data Retrieval**: Providers fetch and format responses, creating a Merkle tree of hashed responses.
4. **Consensus Storage**: Once signatures representing 50%+ weight are collected, the Merkle root is submitted to the [`Relay`](/network/fsp/solidity-reference/IRelay) contract.
5. **Proof Retrieval**: Users fetch attestation responses and proofs from the DA Layer.
6. **Verification and Action**: Smart contracts verify proofs and use the attested data if valid.

### User Workflow

<ThemedImage
  alt=""User Workflow Diagram""
  sources={{
    light: useBaseUrl(""img/fdc-overview/user_workflow_light.svg""),
    dark: useBaseUrl(""img/fdc-overview/user_workflow_dark.svg""),
  }}
/>

1. **Identify Data Needs**: Determine the required attestation type and data source.
2. **Prepare Request**: Format the request with the expected response hash (MIC).
3. **Submit Request**: Use [`requestAttestation`](/fdc/reference/IFdcHub#requestattestation) from `FdcHub` and pay the required fee.
4. **Track Submission**: Record the block timestamp and calculate the voting round.
5. **Wait for Finalization**: The voting round concludes, and a relay contract event signals finalization.
6. **Fetch Data**: Retrieve responses and proofs from the DA Layer.
7. **Submit to Smart Contract**: Provide responses and proofs for verification.

### Smart Contract Workflow

1. **Define Triggers**: Establish data-driven triggers.
2. **Receive Data**: Accept attestation responses and proofs from users.
3. **Verify Proofs**: Use the [`FdcVerification`](/fdc/reference/IFdcVerification) contract to validate the response against the Merkle root.
4. **Act on Data**: Utilize the verified data for computation or decision-making.

### Data Provider Workflow

1. **Collect Requests**: Group requests by emission timestamps.
2. **Retrieve Data**: Fetch responses from verifier servers.
3. **Validate Responses**: Ensure data validity using MIC and LUT checks.
4. **Submit BitVectors**: Indicate valid requests using BitVectors during the ""choose phase"" (90-135 seconds into the round).
5. **Achieve Consensus**: Aggregate BitVectors to form a consensus BitVector.
6. **Create Merkle Tree**: Construct a Merkle tree from validated responses.
7. **Sign and Submit**: Collect signatures representing 50%+ weight and submit the Merkle root to the [`Relay`](/network/fsp/solidity-reference/IRelay) contract.
8. **Serve Data**: Provide attestation responses and proofs via the DA Layer.

The **Flare Data Connector (FDC)** is a critical infrastructure component for the Flare ecosystem, enabling smart contracts to access **secure, attested external data** while maintaining trustless verification through **Merkle proofs**. By integrating the FDC, developers can create more **reliable, decentralized applications** across multiple blockchains.",2025-03-08 01:27:14
5-reference.mdx,"title: FDC Reference
description: Solidity reference for FDC smart contracts.
keywords:
  [
    solidity,
    reference,
    fdc,
    flare-data-connector,
    flare-network,
    smart-contracts,
  ]","import Tabs from ""@theme/Tabs"";
import TabItem from ""@theme/TabItem"";
import DocCardList from ""@theme/DocCardList"";
import SolidityReference from ""@site/src/components/DataTables/SolidityReference"";

## Deployed Contracts

export const contracts = [
  ""FdcHub"",
  ""FdcVerification"",
  ""FdcRequestFeeConfigurations"",
  ""FdcInflationConfigurations"",
];

<Tabs block>
    <TabItem value=""flare"" label=""Flare Mainnet"" default>

        <SolidityReference
            network=""FlareMainnet""
            contractNames={contracts}
        />

    </TabItem>
    <TabItem value=""coston2"" label=""Flare Testnet Coston2"">

        <SolidityReference
            network=""FlareTestnetCoston2""
            contractNames={contracts}
        />

    </TabItem>
    <TabItem value=""songbird"" label=""Songbird Canary-Network"">

        <SolidityReference
            network=""SongbirdCanaryNetwork""
            contractNames={contracts}
        />

    </TabItem>

    <TabItem value=""coston"" label=""Songbird Testnet Coston"">

        <SolidityReference
            network=""SongbirdTestnetCoston""
            contractNames={contracts}
        />

    </TabItem>

</Tabs>

## Interfaces

<DocCardList />",2025-03-08 01:27:14
payment.mdx,"title: Payment
authors: [lukaavbreht, filipkoprivec]
description: Retrieve a Payment transaction data from Bitcoin, Dogecoin, or XRPL.
tags: [intermediate, ethereum, fdc]
keywords: [ethereum, flare-data-connector, evm, flare-network]
sidebar_position: 8
unlisted: false","The `Payment` attestation type enables data collection about a transaction, classified as payment on the native chain.
The currently supported chain are: `BTC`, `DOGE`, and `XRP`.
You can learn more about it in the official [specification repo](/fdc/attestation-types/payment).

We will now demonstrate how the FDC protocol can be used to collect the data of a given XRLP payment transaction.
The transaction we will be observing has the id `2A3E7C7F6077B4D12207A9F063515EACE70FBBF3C55514CD8BD659D4AB721447`; this is an arbitrary transaction that we acquired from the XRPL testnet [explorer](https://testnet.xrpl.org/).

The same procedure works for all supported sources, `BTC`, `DOGE`, and `XRP`.
The source then requires only a slight modification; we will remind you of that when it comes up in the guide.

In this guide, we will follow the steps outlined in the [FDC overview](/fdc/overview).

Our implementation requires handling the FDC voting round finalization process.
To manage this, we will create separate scripts in `script/fdcExample/Payment.s.sol` that handle different stages of the validation process:

```solidity title=""scrip/fdcExample/Payment.s.sol""
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.25;

import {Script} from ""dependencies/forge-std-1.9.5/src/Script.sol"";
...

string constant attestationTypeName = ""Payment"";
string constant dirPath = ""data/"";

contract PrepareAttestationRequest is Script {
 ...
}

contract SubmitAttestationRequest is Script {
 ...
}

contract RetrieveDataAndProof is Script {
 ...
}

contract Deploy is Script {
 ...
}
...
```

The names of included contracts mostly mirror the steps described in the [FDC guide](/fdc/overview).

To bridge the separate executions of the scripts, we will save the relevant data of each script to a file in the `dirPath` folder.
Each succeeding script will then read that file to load the data.

## Prepare request

The JSON request to the verifier is the same form for all attestation types, but the values of the fields differ between them.
It contains the following fields.

### Required Fields

- `attestationType` is the UTF8 hex string encoding of the attestation type name, zero-padded to 32 bytes.
- `sourceId` is the UTF8 hex string encoding of the data source identifier name, zero-padded to 32 bytes.
- `requestBody` is different for each attestation type.

In the case of `Payment`, `requestBody` is a JSON containing the fields:

- `transactionId`: id of the transaction; as `bytes32`
- `inUtxo`: UTXO chains support multiple source addresses, so this is the index of the address considered, as `uint256`; for non-UTXO chains this should always be `0`
- `utxo`: UTXO chains support multiple receiving addresses, so this is the index of the address considered, as `uint256`; for non-UTXO chains this should always be `0`

### Reference Documentation

- [AddressValidity Specification](/fdc/attestation-types/payment)
- [Verifier Interactive Docs](https://fdc-verifiers-testnet.flare.network/verifier/xrp/api-doc#/)
- API available for [DOGE](https://fdc-verifiers-testnet.flare.network/verifier/doge/api-doc#/) and [BTC](https://fdc-verifiers-testnet.flare.network/verifier/btc/api-doc#/).

### Example Values

- `transactionId`: the above address `9421cbb7f195df66d16703442a408261fa973514a0bd9dfc680f10eb3942d11f`
- `inUtxo`: non-default `0`
- `utxo`: non-default `0`

### Encoding Functions

To encode values into UTF8 hex:

- `toUtf8HexString`: Converts a string to UTF8 hex.
- `toHexString`: Zero-right-pads the string to 32 bytes.

These functions are included in the [Base library](https://github.com/flare-foundation/flare-foundry-starter/blob/master/script/fdcExample/Base.s.sol) within the [example repository](https://github.com/flare-foundation/flare-foundry-starter), but they can also be defined locally in your contract or script.

```solidity title=""scrip/fdcExample/Base.s.sol""
function toHexString(
 bytes memory data
) public pure returns (string memory) {
 bytes memory alphabet = ""0123456789abcdef"";

 bytes memory str = new bytes(2 + data.length * 2);
 str[0] = ""0"";
 str[1] = ""x"";
 for (uint i = 0; i < data.length; i++) {
 str[2 + i * 2] = alphabet[uint(uint8(data[i] >> 4))];
 str[3 + i * 2] = alphabet[uint(uint8(data[i] & 0x0f))];
 }
 return string(str);
}
```

```solidity title=""scrip/fdcExample/Base.s.sol""
function toUtf8HexString(
 string memory _string
) internal pure returns (string memory) {
 string memory encodedString = toHexString(
 abi.encodePacked(_string)
 );
 uint256 stringLength = bytes(encodedString).length;
 require(stringLength <= 64, ""String too long"");
 uint256 paddingLength = 64 - stringLength + 2;
 for (uint256 i = 0; i < paddingLength; i++) {
 encodedString = string.concat(encodedString, ""0"");
 }
 return encodedString;
}
```

We also define a helper function for formatting data into a JSON string.

```solidity title=""scrip/fdcExample/Base.s.sol""
function prepareAttestationRequest(
 string memory attestationType,
 string memory sourceId,
 string memory requestBody
) internal view returns (string[] memory, string memory) {
 // We read the API key from the .env file
 string memory apiKey = vm.envString(""VERIFIER_API_KEY"");

 // Preparing headers
 string[] memory headers = prepareHeaders(apiKey);
 // Preparing body
 string memory body = prepareBody(
 attestationType,
 sourceId,
 requestBody
 );

 console.log(
 ""headers: %s"",
 string.concat(""{"", headers[0], "", "", headers[1]),
 ""}\n""
 );
 console.log(""body: %s\n"", body);
 return (headers, body);
}

function prepareHeaders(
 string memory apiKey
) internal pure returns (string[] memory) {
 string[] memory headers = new string[](2);
 headers[0] = string.concat('""X-API-KEY"": ', apiKey);
 headers[1] = '""Content-Type"": ""application/json""';
 return headers;
}

function prepareBody(
 string memory attestationType,
 string memory sourceId,
 string memory body
) internal pure returns (string memory) {
 return
 string.concat(
 '{""attestationType"": ',
 '""',
 attestationType,
 '""',
 ', ""sourceId"": ',
 '""',
 sourceId,
 '""',
 ', ""requestBody"": ',
 body,
 ""}""
 );
}

```

In the example repository, these are once again included within the [Base](https://github.com/flare-foundation/flare-foundry-starter/blob/master/script/fdcExample/Base.s.sol) library file.

Thus, the part of the script that prepares the verifier request looks like:

```solidity title=""scrip/fdcExample/Payment.s.sol""
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.25;

import {console} from ""dependencies/forge-std-1.9.5/src/console.sol"";
import {Script} from ""dependencies/forge-std-1.9.5/src/Script.sol"";
import {Base} from ""./Base.s.sol"";
...

string constant attestationTypeName = ""Payment"";
string constant dirPath = ""data/"";

contract PrepareAttestationRequest is Script {
 using Surl for *;

 // Setting request data
 string public transactionId =
 ""2A3E7C7F6077B4D12207A9F063515EACE70FBBF3C55514CD8BD659D4AB721447"";
 string public inUtxo = ""0"";
 string public utxo = ""0"";
 string public baseSourceName = ""xrp""; // Part of verifier URL
 string public sourceName = ""testXRP""; // XRLP test chain ID

 function prepareRequestBody(
 string memory transactionId,
 string memory inUtxo,
 string memory utxo
 ) private pure returns (string memory) {
 return
 string.concat(
 '{""transactionId"": ""',
 transactionId,
 '"", ""inUtxo"": ""',
 inUtxo,
 '"", ""utxo"": ""',
 utxo,
 '""}'
 );
 }

 function run() external {
 // Preparing request data
 string memory attestationType = Base.toUtf8HexString(
 attestationTypeName
 );
 string memory sourceId = Base.toUtf8HexString(sourceName);
 string memory requestBody = prepareRequestBody(
 transactionId,
 inUtxo,
 utxo
 );

 (string[] memory headers, string memory body) =
 prepareAttestationRequest(attestationType, sourceId, requestBody);

 ...
 }
}

...
```

If you are accessing a different chain, replace the `baseSourceName` with an appropriate value, `doge` or `btc`.

The code above differs slightly from the [starter example](https://github.com/flare-foundation/flare-foundry-starter).
But, if we remove the ellipses `...` signifying missing code, we can still run the script.

Because of the `console.log` commands it will produce JSON strings that represent valid requests; we can then pass this to the [interactive verifier](https://fdc-verifiers-testnet.flare.network/verifier/btc/api-doc#/Payment/BTCPaymentVerifierController_prepareRequest) to check what the response will be.

We can run the script by calling the following commands in the console.

```bash
source .env
```

```bash
forge script script/fdcExample/Payment.s.sol:PrepareAttestationRequest --private-key $PRIVATE_KEY --rpc-url $COSTON2_RPC_URL --etherscan-api-key $FLARE_API_KEY --broadcast  --ffi
```

The prerequisite for this is that the `.env` file is not missing the `PRIVATE KEY` and `COSTON2_RPC_URL` values.
The script can also access other chains; that can be achieved by replacing the `--rpc-url` value with `COSTON_RPC_URL`, `FLARE_RPC_URL`, or `SONGBIRD_RPC_URL`.

## Post request to verifier.

To post a request to a verifier server, we use the `surl` package.
We place `using Surl for *;` at the start of our `PostRequest` contract, and then call its `post` method on the verifier URL.

```solidity title=""scrip/fdcExample/Payment.s.sol""
(, bytes memory data) = url.post(headers, body);
```

We construct the URL by appending to the verifier address `https://fdc-verifiers-testnet.flare.network/` the path `verifier/btc/Payment/prepareRequest`.
We can do so dynamically with the following code.

```solidity title=""scrip/fdcExample/Payment.s.sol""
string memory baseUrl = ""https://fdc-verifiers-testnet.flare.network/"";
string memory url = string.concat(
 baseUrl,
 ""verifier/"",
 baseSourceName,
 ""/"",
 attestationTypeName,
 ""/prepareRequest""
);
console.log(""url: %s"", url);
string memory requestBody = string.concat(
 '{""addressStr"": ""',
 addressStr,
 '""}'
);
```

Lastly, we parse the return data from the verifier server.
Using the Foundry `parseJson` shortcode, and a custom struct `AttestationResponse`, we decode the returned data and extract from it the ABI encoded request.

```solidity title=""scrip/fdcExample/Base.s.sol""
function parseAttestationRequest(
 bytes memory data
) internal pure returns (AttestationResponse memory) {
 string memory dataString = string(data);
 bytes memory dataJson = vm.parseJson(dataString);

 AttestationResponse memory response = abi.decode(
 dataJson,
 (AttestationResponse)
 );

 console.log(""response status: %s\n"", response.status);
 console.log(""response abiEncodedRequest: "");
 console.logBytes(response.abiEncodedRequest);
 console.log(""\n"");

 return response;
}
```

:::info
If everything went right, the `abiEncodedRequest` should look something like this.

```
0x
4164647265737356616c69646974790000000000000000000000000000000000
7465737442544300000000000000000000000000000000000000000000000000
7d2ef938d4ffd2392f588bf46563e07ab885b15fead91c1bb99b16f465b71a68
0000000000000000000000000000000000000000000000000000000000000020
0000000000000000000000000000000000000000000000000000000000000020
0000000000000000000000000000000000000000000000000000000000000022
6d6739503966347772397737633173674665695443356f4d4c59584363326337
6873000000000000000000000000000000000000000000000000000000000000
```

Let's break it down line by line:

- **First line:** `toUtf8HexString(""Payment"")`
- **Second line:** `toUtf8HexString(""testETH"")`
- **Third line:** message integrity code (MIC), a hash of the whole response salted with a string `""Flare""`, ensures the integrity of the attestation
- **Remaining lines:** ABI encoded `Payment.RequestBody` Solidity struct
  :::

What this demonstrates is that, with some effort, the `abiEncodedRequest` can be constructed manually.

We write the `abiEncodedRequest` to a file (`data/Payment_abiEncodedRequest.txt`) to it in the next step.

```solidity title=""scrip/fdcExample/Payment.s.sol""
Base.writeToFile(
    dirPath,
    string.concat(attestationTypeName, ""_abiEncodedRequest""),
    StringsBase.toHexString(response.abiEncodedRequest),
    true
);
```

## Submit request to FDC

This step transitions from off-chain request preparation to on-chain interaction with the FDC protocol. Now, we submit the validated request to the blockchain using deployed smart contracts.

### Submit request

The entire submission process requires only five key steps:

```solidity title=""scrip/fdcExample/Base.s.sol""
function submitAttestationRequest(
 AttestationResponse memory response
) internal {
 uint256 deployerPrivateKey = vm.envUint(""PRIVATE_KEY"");
 vm.startBroadcast(deployerPrivateKey);
 IFdcRequestFeeConfigurations fdcRequestFeeConfigurations = ContractRegistry
 .getFdcRequestFeeConfigurations();
 uint256 requestFee = fdcRequestFeeConfigurations.getRequestFee(
 response.abiEncodedRequest
 );
 console.log(""request fee: %s\n"", requestFee);
 vm.stopBroadcast();

 vm.startBroadcast(deployerPrivateKey);

 IFdcHub fdcHub = ContractRegistry.getFdcHub();
 console.log(""fcdHub address:"");
 console.log(address(fdcHub));
 console.log(""\n"");
 fdcHub.requestAttestation{value: requestFee}(response.abiEncodedRequest);
 vm.stopBroadcast();
}
```

### Step-by-Step Breakdown

1.  Load Private Key
    The private key is read from the `.env` file using Foundry's `envUint` function:

```solidity
       uint256 deployerPrivateKey = vm.envUint(""PRIVATE_KEY"");
```

2.  Obtain Request Fee
    We retrieve the required requestFee from the `FdcRequestFeeConfigurations` contract:

```solidity
        IFdcRequestFeeConfigurations fdcRequestFeeConfigurations = ContractRegistry
            .getFdcRequestFeeConfigurations();
        uint256 requestFee = fdcRequestFeeConfigurations.getRequestFee(
            response.abiEncodedRequest
        );

```

    This is done in a separate broadcast to ensure `requestFee` is available before submitting the request.

3. Access `FdcHub` Contract
   Using the `ContractRegistry` library (from `flare-periphery`), we fetch the `FdcHub` contract:

```solidity
   IFdcHub fdcHub = ContractRegistry.getFdcHub();
   console.log(""fcdHub address:"");
   console.log(address(fdcHub));
   console.log(""\n"");
```

4. Submit the Attestation Request
   We send the attestation request with the required fee:

```solidity
 fdcHub.requestAttestation{value: requestFee}(response.abiEncodedRequest);
```

5.  Calculate Voting Round Number
    To determine the voting round in which the attestation request is processed, we query the `FlareSystemsManager` contract:

```solidity
       // Calculating roundId
       IFlareSystemsManager flareSystemsManager = ContractRegistry
           .getFlareSystemsManager();

       uint32 roundId = flareSystemsManager.getCurrentVotingEpochId();
       console.log(""roundId: %s\n"", Strings.toString(roundId));

```

This can be done within the existing broadcast or in a new one (as done in the demo repository for better code organization).

## Wait for response

We wait for the round to finalize.
This takes no more than 90 seconds.

You can check if the request was submitted successfully on the [AttestationRequests](https://coston2-systems-explorer.flare.rocks/attestation-request) page on the Flare Systems Explorer website.
To check if the round has been finalized, go to [Finalizations](https://coston2-systems-explorer.flare.rocks/finalizations) page.

To learn more about how the FDC protocol works, check [here](/fdc/overview).

## Prepare proof request

We prepare the proof request in a similar manner as in the step Prepare the request, by string concatenation.
We import two new variables from the `.env` file; the URL of a verifier server and the corresponding API key.

```solidity title=""scrip/fdcExample/Payment.s.sol""
string memory daLayerUrl = vm.envString(""COSTON2_DA_LAYER_URL"");
string memory apiKey = vm.envString(""X_API_KEY"");
```

Also, by repeatedly using the Foundry shortcode `vm.readLine`, we read the data, saved to a file in the previous step, to variables.

```solidity title=""scrip/fdcExample/Payment.s.sol""
string memory requestBytes = vm.readLine(
    string.concat(
        dirPath,
        attestationTypeName,
        ""_abiEncodedRequest"",
        "".txt""
    )
);
string memory votingRoundId = vm.readLine(
    string.concat(
        dirPath,
        attestationTypeName,
        ""_votingRoundId"",
        "".txt""
    )
);
```

The code is as follows.

```solidity title=""scrip/fdcExample/Payment.s.sol""
contract RetrieveDataAndProof is Script {
 using Surl for *;

 function run() external {
 string memory daLayerUrl = vm.envString(""COSTON2_DA_LAYER_URL"");
 string memory apiKey = vm.envString(""X_API_KEY"");
 string memory fileName = string.concat(attestationTypeName, "".txt"");
 string memory filePath = string.concat(dirPath, fileName);

 // We import the roundId and abiEncodedRequest from the first file
 string memory votingRoundId = vm.readLine(filePath);
 string memory requestBytes = vm.readLine(filePath);
 console.log(""votingRoundId: %s\n"", votingRoundId);
 console.log(""requestBytes: %s\n"", requestBytes);

 // Preparing the proof request
 string[] memory headers = prepareHeaders(apiKey);
 string memory body = string.concat(
 '{""votingRoundId"":',
 votingRoundId,
 ',""requestBytes"":""',
 requestBytes,
 '""}'
 );
 console.log(""body: %s\n"", body);
 console.log(
 ""headers: %s"",
 string.concat(""{"", headers[0], "", "", headers[1]),
 ""}\n""
 );

 ...
 }
}
```

## Post proof request to DA Layer

We post the proof request to a chosen DA Layer provider server also with the same code as we did in the previous step.

```solidity title=""scrip/fdcExample/Payment.s.sol""
string memory url = string.concat(
 daLayerUrl,
 // ""api/v0/fdc/get-proof-round-id-bytes""
 ""api/v1/fdc/proof-by-request-round-raw""
);
console.log(""url: %s\n"", url);

(, bytes memory data) = Base.postAttestationRequest(url, headers, body);
```

Parsing the returned data requires the definition of an auxiliary `struct`.

{/* <!-- TODO rename after renaming --> */}

```solidity title=""scrip/fdcExample/Base.s.sol""
struct ParsableProof {
 bytes32 attestationType;
 bytes32[] proofs;
 bytes responseHex;
}
```

The field `attestationType` holds the UTF8 encoded hex string of the attestation type name, padded to 32 bytes.
Thus, it should match the value of the `attestationType` parameter in the Prepare the request step.
In our case, that value is `0x4164647265737356616c69646974790000000000000000000000000000000000`.

The array `proofs` holds the Merkle proofs of our attestation request.

Lastly, `responseHex` is the ABI encoding of the chosen attestation type response struct.
In this case, it is the `IPayment.Response` struct.
We retrieve this data as follows.

```solidity title=""scrip/fdcExample/Payment.s.sol""
bytes memory dataJson = parseData(data);
ParsableProof memory proof = abi.decode(dataJson, (ParsableProof));

IPayment.Response memory proofResponse = abi.decode(
 proof.responseHex,
 (IPayment.Response)
);
```

## Verify proof

Because every node holds a copy of the whole chain, storing data on the blockchain is expensive.
For the sake of efficiency, FDC keeps only the Merkle proof on-chain, while the data itself can be obtained from outside data providers.
Per our request, they supply us with the specified data.
That data then be encrypted, and its Merkle proof compared to the Merkle root stored on-chain.
If they match, the data can be trusted.

This step is not strictly necessary; if we trust our data provider, we can skip this step.
And in practice, we do just that.
But it is crucial, that should we want to verify the data, we can do so.

One way to do it is using the `FdcVerification` contract.
We first store our data as an appropriate Solidity struct, namely `IPayment.Proof`.

```solidity title=""scrip/fdcExample/Payment.s.sol""
IPayment.Proof memory _proof = IPayment.Proof(
 proof.proofs,
 proofResponse
);
```

We then access the `FdcVerification` contract through the `ContractRegistry`, and feed it the proof.
If the proof is valid, the function `verifyPayment` will return `true`, otherwise `false`.
As before, we wrap the whole thing into a broadcast environment, using the `PRIVATE_KEY` variable from our `.env` file.

```solidity title=""scrip/fdcExample/Payment.s.sol""
uint256 deployerPrivateKey = vm.envUint(""PRIVATE_KEY"");
vm.startBroadcast(deployerPrivateKey);

bool isValid = ContractRegistry
 .getFdcVerification()
 .verifyPayment(proof);
console.log(""proof is valid: %s\n"", StringsBase.toString(isValid));

vm.stopBroadcast();
```

In actuality, we will only verify the proof within a deployed contract, which we will define in the next step.
What we will do here instead is, we will save the proof to a file so that it can be later loaded into a variable.
The code that does this is as follows.

```solidity title=""scrip/fdcExample/EVMTransaction.s.sol""
Base.writeToFile(
    dirPath,
    string.concat(attestationTypeName, ""_proof""),
    StringsBase.toHexString(abi.encode(_proof)),
    true
);
```

## Use the data

We will now define a simple contract, that will demonstrate how the data can be used onchain.
The contract will receive data and proof of a Payment transaction, and store it into an array of special `Payment` structs.
It will do so only if the transaction is valid.

```solidity title=""src/fdcExample/Payment.sol""
struct Payment {
    uint64 blockNumber;
    uint64 blockTimestamp;
    bytes32 sourceAddressHash;
    bytes32 receivingAddressHash;
    int256 spentAmount;
    bytes32 standardPaymentReference;
    uint8 status;
}
```

First, we define an interface that the contract will inherit from.
We do so, so that we may contact the contract later through a script.

```solidity title=""src/fdcExample/Payment.sol""
interface ITransferEventListener {
    function registerPayment(
        IPayment.Proof calldata _transaction
    ) external;
}
```

The interface exposes the only function the script will call, `collectTransferEvents`.
We now define the contract as follows.

```solidity title=""src/fdcExample/Payment.sol""

contract PaymentRegistry is IPaymentRegistry {
    Payment[] public verifiedPayments;

    function isPaymentProofValid(
        IPayment.Proof calldata transaction
    ) public view returns (bool) {
        // Use the library to get the verifier contract and verify that this transaction was proved by state connector
        IFdcVerification fdc = ContractRegistry.getFdcVerification();
        console.log(""transaction: %s\n"", FdcStrings.toJsonString(transaction));
        // return true;
        return fdc.verifyPayment(transaction);
    }

    function registerPayment(IPayment.Proof calldata _transaction) external {
        // 1. FDC Logic
        // Check that this Payment has indeed been confirmed by the FDC
        require(isPaymentProofValid(_transaction), ""Invalid transaction proof"");

        // 2. Business logic
        Payment memory provedPayment = Payment(
            _transaction.data.responseBody.blockNumber,
            _transaction.data.responseBody.blockTimestamp,
            _transaction.data.responseBody.sourceAddressHash,
            _transaction.data.responseBody.receivingAddressHash,
            _transaction.data.responseBody.spentAmount,
            _transaction.data.responseBody.standardPaymentReference,
            _transaction.data.responseBody.status
        );

        verifiedPayments.push(provedPayment);
    }
}
```

We deploy the contract through a simple script.
The script creates a new `PaymentRegistry` contract, and writes its address to a file (`data/Payment_listenerAddress.txt`).

```solidity title=""scrip/fdcExample/DeployContract.s.sol""
contract DeployContract is Script {
    function run() external {
        uint256 deployerPrivateKey = vm.envUint(""PRIVATE_KEY"");
        vm.startBroadcast(deployerPrivateKey);

        PaymentRegistry paymentRegistry = new PaymentRegistry();
        address _address = address(paymentRegistry);

        vm.stopBroadcast();

        Base.writeToFile(
            dirPath,
            string.concat(attestationTypeName, ""_address""),
            StringsBase.toHexString(abi.encodePacked(_address)),
            true
        );
    }
}
```

We deploy the contract with the following console command.

```bash
forge script script/fdcExample/Payment.s.sol:DeployContract --private-key $PRIVATE_KEY --rpc-url $COSTON2_RPC_URL --etherscan-api-key $FLARE_API_KEY --broadcast --verify --ffi
```

Lastly, we define a script that interacts with the above contract.
It first reads the ABI encoded proof data, and the contract address, from files.
Then, it connects to the above contract at the saved address (this is why we require the interface).
With that, it is able to call the `registerPayment` method of the contract.

```solidity title=""script/fdcExample/Payment.s.sol""
contract InteractWithContract is Script {
    function run() external {
        string memory addressString = vm.readLine(
            string.concat(dirPath, attestationTypeName, ""_address"", "".txt"")
        );
        address _address = vm.parseAddress(addressString);
        string memory proofString = vm.readLine(
            string.concat(dirPath, attestationTypeName, ""_proof"", "".txt"")
        );
        bytes memory proofBytes = vm.parseBytes(proofString);
        IPayment.Proof memory proof = abi.decode(proofBytes, (IPayment.Proof));
        uint256 deployerPrivateKey = vm.envUint(""PRIVATE_KEY"");
        vm.startBroadcast(deployerPrivateKey);
        IPaymentRegistry registry = IPaymentRegistry(_address);
        registry.registerPayment(proof);
        vm.stopBroadcast();
    }
}

```

We run this script with the console command:

```bash
forge script script/fdcExample/Payment.s.sol:InteractWithContract --private-key $PRIVATE_KEY --rpc-url $COSTON2_RPC_URL --etherscan-api-key $FLARE_API_KEY --broadcast --ffi

```",2025-03-08 01:27:14
detect-balance-decrease.mdx,"title: Detect Balance Decrease
authors: [lukaavbreht, filipkoprivec]
description: Detect a UTXO or XRPL balance decreasing transaction.
tags: [intermediate, ethereum, fdc]
keywords: [ethereum, flare-data-connector, evm, flare-network]
sidebar_position: 7
unlisted: true","This guide focuses on the [ConfirmedBlockHeightExists](/fdc/attestation-types/confirmed-block-height-exists) attestation type, an efficient way to assert whether a specific `blockNumber` is confirmed with additional data to compute the block production rate within a given time window.
The primary contract interface for this attestation type is [`IConfirmedBlockHeightExists`](/fdc/reference/IFdcHub).

## Balance Decreasing Transaction

[Full specification on GitHub](https://github.com/flare-foundation/songbird-state-connector-protocol/blob/main/specs/attestations/active-types).

This attestation type is designed to prove that a transaction either decreases the balance of an address or is signed by the source address.

One of the purposes of the Data Connector is to provide connectivity between different blockchains, allowing the use of information from one chain on another. Other chains may not have smart contract capability or support any kind of ""fund locking"" and unlocking based on conditions. This is where the Data Connector comes into play, allowing the Flare network to monitor (and police) an address on another chain and act upon changes in its balance.

For instance, we can have an address on the Bitcoin network that acts as a vault (think fAssets). If the address owner violates an agreement by sending funds out, the Data Connector can detect it. To enhance security and avoid dependence on a single chain, this attestation type makes minimal assumptions about the violating transaction. A transaction is considered ""offending"" if the balance of the designated address is lower after the transaction or if the address is among the signers of the transaction (even if its balance is higher than before the transaction).

This allows us to track balance decreases even if the change results from a complex transaction (e.g., multisig, complex scripts, or specific XRPL transactions where a non-participating address can have funds removed).

The request body consists of only two arguments:

- **`transactionId`**: The ID of the payment transaction we want to prove (same as with payment).

- **`sourceAddressIndicator`**: The indicator of the address whose balance has been decreased.
  - On Bitcoin and Dogecoin, this is the index of the transaction input in hex, padded to a 0x prefixed 32-byte string (very similar to `inUtxo` in the payment type).
  - On XRPL, this is the standard address hash of the address whose balance we want to prove has decreased.

Once the request is submitted, the verifiers will check the transaction, perform full accounting of the requested source address, and confirm the response if and only if the transaction indeed decreases the balance of the address or the address is among the signers of the transaction. In short, the request won't be confirmed if the balance stays the same and the address is not among the signers of the transaction, ensuring there are no false positives.

If the address has indeed decreased the balance (or participated as a signer), the response will also contain information about when exactly the offending transaction occurred. The balance decrease might be allowed under certain conditions (e.g., after a certain time, or with the correct payment reference).

The response will include the following information:

- **`blockNumber`**: The number of the block in which the transaction is included.

- **`blockTimestamp`**: The timestamp of the block in which the transaction is included. For UTXO chains, this is `mediantime`; for XRPL, this is `close_time` of the ledger.

- **`sourceAddressHash`**: The standard address hash of the address indicated by the `sourceAddressIndicator`. For UTXO chains, this gives us the address that controlled the designated input.

- **`spentAmount`**: The amount spent by the source address in minimal units. If this is negative, the address has received funds in the transaction but might still be among the signers.

- **`standardPaymentReference`**: The standard payment reference of the transaction. This is useful if the transaction is an allowed payment and the payment reference is used to identify it.

Let's see how the verification contract looks.

```solidity title=""BalanceDecreasingTransactionVerification.sol""
// SPDX-License-Identifier: MIT
pragma solidity 0.8.20;

import ""../../interface/types/BalanceDecreasingTransaction.sol"";
import ""../../interface/external/IMerkleRootStorage.sol"";
import ""./interface/IBalanceDecreasingTransactionVerification.sol"";
import {MerkleProof} from ""@openzeppelin/contracts/utils/cryptography/MerkleProof.sol"";

contract BalanceDecreasingTransactionVerification is IBalanceDecreasingTransactionVerification {
   using MerkleProof for bytes32[];

   IMerkleRootStorage public immutable merkleRootStorage;

   constructor(IMerkleRootStorage _merkleRootStorage) {
      merkleRootStorage = _merkleRootStorage;
   }

   function verifyBalanceDecreasingTransaction(
      BalanceDecreasingTransaction.Proof calldata _proof
   ) external view returns (bool _proved) {
      return _proof.data.attestationType == bytes32(""BalanceDecreasingTransaction"") &&
         _proof.merkleProof.verify(
            merkleRootStorage.merkleRoot(_proof.data.votingRound),
            keccak256(abi.encode(_proof.data))
         );
   }
}
```

If you remember the payment verification contract, this one is very similar. We still use the `MerkleProof` library to verify the proof, but the type we verify is different. We just ABI encode the response and hash it, and then we verify that the hash is included in the Merkle tree for the round‚Äîexactly the same way as with the payment type. All other types are very similar; only the type we verify is different.

Importantly, the verification contract simply checks that this proof indeed proves that the structure we requested was included in a specific round. It does not make any assumptions about the response itself. The response itself should be checked by the dapp to ensure it is the expected one.

In some cases, the verifiers will not confirm the response (as there is no such confirmation), but in this case, they might confirm the response and also indicate that the balance has not decreased (and has indeed increased).

### Example

Showing a balance decreasing transaction is simple‚Äîwe will reuse the script from creating a transaction and just prove that the transaction has indeed decreased the balance of the address. The complete code that produces the following example is present in `tryXRPLBalanceDecreasingTransaction.ts`.

The code is practically the same as before; we just make the request to a different endpoint (due to the different attestation type), change the `attestationType` field in the request body, and specify the transaction and the address we want to prove the balance decrease for.

As mentioned earlier, specifying the address is important since the address's balance might have decreased in the transaction, but its participation might have been minimal (or it was not even part of the initial signers). For UTXO chains, we also need to specify `sourceAddressIndicator` because many addresses might be involved in the transaction (by signing an array of outputs). We need to specify which one we want to prove the balance decrease for and request the verifiers to do the full accounting.

```typescript title=""tryXRPLBalanceDecreasingTransaction.ts""
const xrpl = require(""xrpl"");

const {
  XRPL_PRIVATE_KEY,
  ATTESTATION_URL,
  ATTESTATION_API_KEY,
  USE_TESTNET_ATTESTATIONS,
} = process.env;
const receiverAddress = ""r9RLXvWuRro3RX33pk4xsN58tefYZ8Tvbj"";

function toHex(data: string): string {
  var result = """";
  for (var i = 0; i < data.length; i++) {
    result += data.charCodeAt(i).toString(16);
  }
  return ""0x"" + result.padEnd(64, ""0"");
}

function fromHex(data: string): string {
  data = data.replace(/^(0x\.)/, """");
  return data
    .split(/(\w\w)/g)
    .filter((p) => !!p)
    .map((c) => String.fromCharCode(parseInt(c, 16)))
    .join("""");
}

async function prepareAttestationResponse(
  attestationType: string,
  network: string,
  sourceId: string,
  requestBody: any,
): Promise<AttestationResponse> {
  const response = await fetch(
    `${ATTESTATION_URL}/verifier/${network}/${attestationType}/prepareResponse`,
    {
      method: ""POST"",
      headers: {
        ""X-API-KEY"": ATTESTATION_API_KEY as string,
        ""Content-Type"": ""application/json"",
      },
      body: JSON.stringify({
        attestationType: toHex(attestationType),
        sourceId: toHex(sourceId),
        requestBody: requestBody,
      }),
    },
  );
  const data = await response.json();
  return data;
}

async function getXRPLclient(): Promise<any> {
  const client = new xrpl.Client(""wss://s.altnet.rippletest.net:51233"");
  await client.connect();

  return client;
}

async function sendXRPLTransaction(
  message: string = """",
  amount: number = 10,
  target: string = ""r9RLXvWuRro3RX33pk4xsN58tefYZ8Tvbj"",
): Promise<string> {
  const client = await getXRPLclient();

  const test_wallet = xrpl.Wallet.fromSeed(XRPL_PRIVATE_KEY);

  let memos = [];
  if (message) {
    // Standard payment reference must be 32 bytes - so we right pad with 0
    const MemoData = xrpl.convertStringToHex(message).padEnd(64, ""0"");
    const MemoType = xrpl.convertStringToHex(""Text"");
    const MemoFormat = xrpl.convertStringToHex(""text/plain"");

    memos.push({
      Memo: {
        MemoType: MemoType,
        MemoData: MemoData,
        MemoFormat: MemoFormat,
      },
    });
  }

  const transaction = await client.autofill({
    TransactionType: ""Payment"",
    Account: test_wallet.address,
    Amount: amount.toString(),
    Destination: target,
    Memos: memos,
  });

  const signed = test_wallet.sign(transaction);
  console.log(
    `See transaction at https://testnet.xrpl.org/transactions/${signed.hash}`,
  );
  await client.submitAndWait(signed.tx_blob);

  await client.disconnect();

  // sleep for 10 seconds to allow the transaction to be processed
  await new Promise((resolve) => setTimeout(resolve, 10 * 1000));

  const result = await prepareAttestationResponse(
    ""BalanceDecreasingTransaction"",
    ""xrp"",
    ""testXRP"",
    {
      transactionId: ""0x"" + signed.hash,
      sourceAddressIndicator: web3.utils.soliditySha3(test_wallet.address),
    },
  );

  console.log(result);

  console.log(fromHex(result.response.responseBody.standardPaymentReference));
}

async function main() {
  await sendXRPLTransaction(""Hello world!"");
}

main().then(() => process.exit(0));
```

You create a transaction, wait for it to be processed, and then prepare a response to check that it was indeed a balance decreasing transaction.

An example response would look like this:

```json
{
    ""status"": ""VALID"",
    ""response"": {
        ""attestationType"": ""0x42616c616e636544656372656173696e675472616e73616374696f6e00000000"",
        ""sourceId"": ""0x7465737458525000000000000000000000000000000000000000000000000000"",
        ""votingRound"": ""0"",
        ""lowestUsedTimestamp"": ""1708671652"",
        ""requestBody"": {
            ""transactionId"": ""0xB40C7540D8393D389AAF6006C0429608ADD871C0CA3174B72EA55776D885B77B"",
            ""sourceAddressIndicator"": ""0xa1ca3089c3e9f4c6e9ccf2bfb65bcf3e9d7544a092c79d642d5d34a54e0267e1""
        }, ""responseBody"": {
            ""blockNumber"": ""45629840"",
            ""blockTimestamp"": ""1708671652"",
            ""sourceAddressHash"": ""0xa1ca3089c3e9f4c6e9ccf2bfb65bcf3e9d7544a092c79d642d5d34a54e0267e1"",
            ""spentAmount"": ""22"",
            ""standardPaymentReference"": ""0x48656C6C6F20776F726C64210000000000000000000000000000000000000000""
        }
    }
}
Hello world!
```

All the fields are populated correctly. Most importantly, although the transaction sent 10 XRP drops, the response clearly shows that the balance decreased by 22 drops, as 12 drops were spent on the transaction fee.

{/* <!-- TODO:BTC Example, and if possible one with XRPL clawback --> */}",2025-03-08 01:27:14
json-api.mdx,"title: Json Api
authors: [lukaavbreht, filipkoprivec]
description: Retrieve arbitrary Web2 data.
tags: [intermediate, ethereum, fdc]
keywords: [ethereum, flare-data-connector, evm, flare-network]
sidebar_position: 8
unlisted: false","The `JsonApi` attestation type enables data collection from an arbitrary Web2 source.
You can learn more about it in the official [specification repo](/fdc/attestation-types/json-api).

We will now demonstrate how the FDC protocol can be used to collect the data of a given [Star Wars API](https://swapi.dev/) request.
The request we will be making is `https://swapi.dev/api/peaople/3/`.
The same procedure works for all public APIs.

In this guide, we will follow the steps outlined in the [FDC overview](/fdc/overview).

Our implementation requires handling the FDC voting round finalization process.
To manage this, we will create separate scripts in `script/fdcExample/JsonApi.s.sol` that handle different stages of the validation process:

```solidity title=""script/fdcExample/JsonApi.s.sol""
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.25;

import {Script} from ""dependencies/forge-std-1.9.5/src/Script.sol"";
...

string constant attestationTypeName = ""JsonApi"";
string constant dirPath = ""data/"";

contract PrepareAttestationRequest is Script {
 ...
}

contract SubmitAttestationRequest is Script {
 ...
}

contract RetrieveDataAndProof is Script {
 ...
}

contract Deploy is Script {
 ...
}
...
```

The names of included contracts mostly mirror the steps described in the [FDC guide](/fdc/overview).

To bridge the separate executions of the scripts, we will save the relevant data of each script to a file in the `dirPath` folder.
Each succeeding script will then read that file to load the data.

## Prepare request

The JSON request to the verifier is the same form for all attestation types, but the values of the fields differ between them.
It contains the following fields.

### Required Fields

- `attestationType` is the UTF8 hex string encoding of the attestation type name, zero-padded to 32 bytes.
- `sourceId` is the UTF8 hex string encoding of the data source identifier name, zero-padded to 32 bytes.
- `requestBody` is different for each attestation type.

In the case of `JsonApi`, `requestBody` is a JSON containing the fields:

- `url`: url of the data source; as `string`
- `postprocessJq`: JQ filter to postprocess the json data received from the URL; as `string`
- `abi_signature`: ABI signature of the Solidity struct that will be used to decode the data; as `string`

### Reference Documentation

- [JsonApi Specification](/fdc/attestation-types/json-api)
- [Verifier Interactive Docs](https://jq-verifier-test.flare.rocks/api-doc#/)

### Example Values

- `url`: the above address `https://swapi.dev/api/people/3/`
- `postprocessJq`: `{name: .name, height: .height, mass: .mass, numberOfFilms: .films | length, uid: (.url | split(\\""/\\"") | .[-2] | tonumber)}`
- `abi_signature`:

```bash
{\\""components\\"": [
{\\""internalType\\"": \\""string\\"", \\""name\\"": \\""name\\"", \\""type\\"": \\""string\\""},
{\\""internalType\\"": \\""uint256\\"", \\""name\\"": \\""height\\"", \\""type\\"": \\""uint256\\""},
{\\""internalType\\"": \\""uint256\\"", \\""name\\"": \\""mass\\"", \\""type\\"": \\""uint256\\""},
{\\""internalType\\"": \\""uint256\\"", \\""name\\"": \\""numberOfFilms\\"", \\""type\\"": \\""uint256\\""},
{\\""internalType\\"": \\""uint256\\"", \\""name\\"": \\""uid\\"", \\""type\\"": \\""uint256\\""}
],
\\""name\\"": \\""task\\"",\\""type\\"": \\""tuple\\""}
```

### Encoding Functions

To encode values into UTF8 hex:

- `toUtf8HexString`: Converts a string to UTF8 hex.
- `toHexString`: Zero-right-pads the string to 32 bytes.

These functions are included in the [Base library](https://github.com/flare-foundation/flare-foundry-starter/blob/master/script/fdcExample/Base.s.sol) within the [example repository](https://github.com/flare-foundation/flare-foundry-starter), but they can also be defined locally in your contract or script.

```solidity title=""scrip/fdcExample/Base.s.sol""
function toHexString(
 bytes memory data
) public pure returns (string memory) {
 bytes memory alphabet = ""0123456789abcdef"";

 bytes memory str = new bytes(2 + data.length * 2);
 str[0] = ""0"";
 str[1] = ""x"";
 for (uint i = 0; i < data.length; i++) {
 str[2 + i * 2] = alphabet[uint(uint8(data[i] >> 4))];
 str[3 + i * 2] = alphabet[uint(uint8(data[i] & 0x0f))];
 }
 return string(str);
}
```

```solidity title=""script/fdcExample/Base.s.sol""
function toUtf8HexString(
 string memory _string
) internal pure returns (string memory) {
 string memory encodedString = toHexString(
 abi.encodePacked(_string)
 );
 uint256 stringLength = bytes(encodedString).length;
 require(stringLength <= 64, ""String too long"");
 uint256 paddingLength = 64 - stringLength + 2;
 for (uint256 i = 0; i < paddingLength; i++) {
 encodedString = string.concat(encodedString, ""0"");
 }
 return encodedString;
}
```

We also define a helper function for formatting data into a JSON string.

```solidity title=""scrip/fdcExample/Base.s.sol""
function prepareAttestationRequest(
 string memory attestationType,
 string memory sourceId,
 string memory requestBody
) internal view returns (string[] memory, string memory) {
 // We read the API key from the .env file
 string memory apiKey = vm.envString(""VERIFIER_API_KEY"");

 // Preparing headers
 string[] memory headers = prepareHeaders(apiKey);
 // Preparing body
 string memory body = prepareBody(
 attestationType,
 sourceId,
 requestBody
 );

 console.log(
 ""headers: %s"",
 string.concat(""{"", headers[0], "", "", headers[1]),
 ""}\n""
 );
 console.log(""body: %s\n"", body);
 return (headers, body);
}

function prepareHeaders(
 string memory apiKey
) internal pure returns (string[] memory) {
 string[] memory headers = new string[](2);
 headers[0] = string.concat('""X-API-KEY"": ', apiKey);
 headers[1] = '""Content-Type"": ""application/json""';
 return headers;
}

function prepareBody(
 string memory attestationType,
 string memory sourceId,
 string memory body
) internal pure returns (string memory) {
 return
 string.concat(
 '{""attestationType"": ',
 '""',
 attestationType,
 '""',
 ', ""sourceId"": ',
 '""',
 sourceId,
 '""',
 ', ""requestBody"": ',
 body,
 ""}""
 );
}

```

In the example repository, these are once again included within the [Base](https://github.com/flare-foundation/flare-foundry-starter/blob/master/script/fdcExample/Base.s.sol) library file.

Thus, the part of the script that prepares the verifier request looks like:

```solidity title=""scrip/fdcExample/JsonApi.s.sol""
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.25;

import {console} from ""dependencies/forge-std-1.9.5/src/console.sol"";
import {Script} from ""dependencies/forge-std-1.9.5/src/Script.sol"";
import {Base} from ""./Base.s.sol"";
...

string constant attestationTypeName = ""JsonApi"";
string constant dirPath = ""data/"";

contract PrepareAttestationRequest is Script {
 using Surl for *;

 // Setting request data
    string public apiUrl = ""https://swapi.dev/api/people/3/"";
    string public postprocessJq =
        '{name: .name, height: .height, mass: .mass, numberOfFilms: .films | length, uid: (.url | split(\\""/\\"") | .[-2] | tonumber)}';
    string publicAbiSignature =
        '{\\""components\\"": ['
        '{\\""internalType\\"": \\""string\\"", \\""name\\"": \\""name\\"", \\""type\\"": \\""string\\""},'
        '{\\""internalType\\"": \\""uint256\\"", \\""name\\"": \\""height\\"", \\""type\\"": \\""uint256\\""},'
        '{\\""internalType\\"": \\""uint256\\"", \\""name\\"": \\""mass\\"", \\""type\\"": \\""uint256\\""},'
        '{\\""internalType\\"": \\""uint256\\"", \\""name\\"": \\""numberOfFilms\\"", \\""type\\"": \\""uint256\\""},'
        '{\\""internalType\\"": \\""uint256\\"", \\""name\\"": \\""uid\\"", \\""type\\"": \\""uint256\\""}'
        ""],""
        '\\""name\\"": \\""task\\"",\\""type\\"": \\""tuple\\""}';

    string public sourceName = ""WEB2"";

    function prepareRequestBody(
        string memory url,
        string memory postprocessJq,
        string memory publicAbiSignature
    ) private pure returns (string memory) {
        return
            string.concat(
                '{""url"": ""',
                url,
                '"",""postprocessJq"": ""',
                postprocessJq,
                '"",""abi_signature"": ""',
                publicAbiSignature,
                '""}'
            );
    }

    function run() external {
        // Preparing request data
        string memory attestationType = Base.toUtf8HexString(
            attestationTypeName
        );
        string memory sourceId = Base.toUtf8HexString(sourceName);
        string memory requestBody = prepareRequestBody(
            apiUrl,
            postprocessJq,
            publicAbiSignature
        );

 (string[] memory headers, string memory body) =
 prepareAttestationRequest(attestationType, sourceId, requestBody);

 ...
 }
}

...
```

The code above differs slightly from the [starter example](https://github.com/flare-foundation/flare-foundry-starter).
But, if we remove the ellipses `...` signifying missing code, we can still run the script.

Because of the `console.log` commands it will produce JSON strings that represent valid requests; we can then pass this to the [interactive verifier](https://fdc-verifiers-testnet.flare.network/verifier/btc/api-doc#/JsonApi/BTCJsonApiVerifierController_prepareRequest) to check the response.

We can run the script by calling the following commands in the console.

```bash
source .env
```

```bash
forge script script/fdcExample/JsonApi.s.sol:PrepareAttestationRequest --private-key $PRIVATE_KEY --rpc-url $COSTON2_RPC_URL --etherscan-api-key $FLARE_API_KEY --broadcast  --ffi
```

The prerequisite for this is that the `.env` file is not missing the `PRIVATE KEY` and `COSTON2_RPC_URL` values.
The script can also access other chains; that can be achieved by replacing the `--rpc-url` value with `COSTON_RPC_URL`, `FLARE_RPC_URL`, or `SONGBIRD_RPC_URL`.

## Post request to verifier

To post a request to a verifier server, we use the `surl` package.
We place `using Surl for *;` at the start of our `PostRequest` contract, and then call its `post` method on the verifier URL.

```solidity title=""scrip/fdcExample/JsonApi.s.sol""
(, bytes memory data) = url.post(headers, body);
```

We construct the URL by appending to the verifier address `https://fdc-verifiers-testnet.flare.network/` the path `verifier/btc/JsonApi/prepareRequest`.
We can do so dynamically with the following code.

```solidity title=""scrip/fdcExample/JsonApi.s.sol""
string memory baseUrl = ""https://fdc-verifiers-testnet.flare.network/"";
string memory url = string.concat(
 baseUrl,
 ""verifier/"",
 baseSourceName,
 ""/"",
 attestationTypeName,
 ""/prepareRequest""
);
console.log(""url: %s"", url);
string memory requestBody = string.concat(
 '{""addressStr"": ""',
 addressStr,
 '""}'
);
```

Lastly, we parse the return data from the verifier server.
Using the Foundry `parseJson` shortcode, and a custom struct `AttestationResponse`, we decode the returned data and extract from it the ABI encoded request.

```solidity title=""scrip/fdcExample/Base.s.sol""
function parseAttestationRequest(
 bytes memory data
) internal pure returns (AttestationResponse memory) {
 string memory dataString = string(data);
 bytes memory dataJson = vm.parseJson(dataString);

 AttestationResponse memory response = abi.decode(
 dataJson,
 (AttestationResponse)
 );

 console.log(""response status: %s\n"", response.status);
 console.log(""response abiEncodedRequest: "");
 console.logBytes(response.abiEncodedRequest);
 console.log(""\n"");

 return response;
}
```

:::info
If everything went right, the `abiEncodedRequest` should look something like this.

```
0x
494a736f6e417069000000000000000000000000000000000000000000000000
5745423200000000000000000000000000000000000000000000000000000000
0b62b2fe7066a5b56cd4cc859f4c802a02e2a0f84b5ad12893ef5a90651e588c
0000000000000000000000000000000000000000000000000000000000000020
0000000000000000000000000000000000000000000000000000000000000060
00000000000000000000000000000000000000000000000000000000000000a0
0000000000000000000000000000000000000000000000000000000000000140
000000000000000000000000000000000000000000000000000000000000001f
68747470733a2f2f73776170692e6465762f6170692f70656f706c652f332f00
0000000000000000000000000000000000000000000000000000000000000078
7b6e616d653a202e6e616d652c206865696768743a202e6865696768742c206d
6173733a202e6d6173732c206e756d6265724f6646696c6d733a202e66696c6d
73207c206c656e6774682c207569643a20282e75726c207c2073706c69742822
2f2229207c202e5b2d325d207c20746f6e756d626572297d0000000000000000
0000000000000000000000000000000000000000000000000000000000000173
7b22636f6d706f6e656e7473223a205b7b22696e7465726e616c54797065223a
2022737472696e67222c20226e616d65223a20226e616d65222c202274797065
223a2022737472696e67227d2c7b22696e7465726e616c54797065223a202275
696e74323536222c20226e616d65223a2022686569676874222c202274797065
223a202275696e74323536227d2c7b22696e7465726e616c54797065223a2022
75696e74323536222c20226e616d65223a20226d617373222c20227479706522
3a202275696e74323536227d2c7b22696e7465726e616c54797065223a202275
696e74323536222c20226e616d65223a20226e756d6265724f6646696c6d7322
2c202274797065223a202275696e74323536227d2c7b22696e7465726e616c54
797065223a202275696e74323536222c20226e616d65223a2022756964222c20
2274797065223a202275696e74323536227d5d2c226e616d65223a2022746173
6b222c2274797065223a20227475706c65227d00000000000000000000000000
```

Let's break it down line by line:

- **First line:** `toUtf8HexString(""JsonApi"")`
- **Second line:** `toUtf8HexString(""testETH"")`
- **Third line:** message integrity code (MIC), a hash of the whole response salted with a string `""Flare""`, ensures the integrity of the attestation
- **Remaining lines:** ABI encoded `JsonApi.RequestBody` Solidity struct
  :::

What this demonstrates is that, with some effort, the `abiEncodedRequest` can be constructed manually.

We write the `abiEncodedRequest` to a file (`data/JsonApi_abiEncodedRequest.txt`) to it in the next step.

```solidity title=""scrip/fdcExample/JsonApi.s.sol""
Base.writeToFile(
    dirPath,
    string.concat(attestationTypeName, ""_abiEncodedRequest""),
    StringsBase.toHexString(response.abiEncodedRequest),
    true
);
```

## Submit request to FDC

This step transitions from off-chain request preparation to on-chain interaction with the FDC protocol. Now, we submit the validated request to the blockchain using deployed smart contracts.

### Submit request

The entire submission process requires only five key steps:

```solidity title=""scrip/fdcExample/Base.s.sol""
function submitAttestationRequest(
    bytes memory abiEncodedRequest
) internal {
 uint256 deployerPrivateKey = vm.envUint(""PRIVATE_KEY"");
 vm.startBroadcast(deployerPrivateKey);
 IFdcRequestFeeConfigurations fdcRequestFeeConfigurations = ContractRegistry
 .getFdcRequestFeeConfigurations();
 uint256 requestFee = fdcRequestFeeConfigurations.getRequestFee(
 abiEncodedRequest
 );
 console.log(""request fee: %s\n"", requestFee);
 vm.stopBroadcast();

 vm.startBroadcast(deployerPrivateKey);

 IFdcHub fdcHub = ContractRegistry.getFdcHub();
 console.log(""fcdHub address:"");
 console.log(address(fdcHub));
 console.log(""\n"");
 fdcHub.requestAttestation{value: requestFee}(abiEncodedRequest);
 vm.stopBroadcast();
}
```

### Step-by-Step Breakdown

1.  Load Private Key
    The private key is read from the `.env` file using Foundry's `envUint` function:

```solidity
       uint256 deployerPrivateKey = vm.envUint(""PRIVATE_KEY"");
```

2.  Obtain Request Fee
    We retrieve the required requestFee from the `FdcRequestFeeConfigurations` contract:

```solidity
        IFdcRequestFeeConfigurations fdcRequestFeeConfigurations = ContractRegistry
            .getFdcRequestFeeConfigurations();
        uint256 requestFee = fdcRequestFeeConfigurations.getRequestFee(
            abiEncodedRequest
        );

```

    This is done in a separate broadcast to ensure `requestFee` is available before submitting the request.

3. Access `FdcHub` Contract
   Using the `ContractRegistry` library (from `flare-periphery`), we fetch the `FdcHub` contract:

```solidity
   IFdcHub fdcHub = ContractRegistry.getFdcHub();
   console.log(""fcdHub address:"");
   console.log(address(fdcHub));
   console.log(""\n"");
```

4. Submit the Attestation Request
   We send the attestation request with the required fee:

```solidity
 fdcHub.requestAttestation{value: requestFee}(abiEncodedRequest);
```

5.  Calculate the Voting Round Number
    To determine the voting round in which the attestation request is processed, we query the `FlareSystemsManager` contract:

```solidity
       // Calculating roundId
       IFlareSystemsManager flareSystemsManager = ContractRegistry
           .getFlareSystemsManager();

       uint32 roundId = flareSystemsManager.getCurrentVotingEpochId();
       console.log(""roundId: %s\n"", Strings.toString(roundId));

```

This can be done within the existing broadcast or in a new one (as done in the demo repository for better code organization).

## Wait for response

We wait for the round to finalize.
This takes no more than 90 seconds.

You can check if the request was submitted successfully on the [AttestationRequests](https://coston2-systems-explorer.flare.rocks/attestation-request) page on the Flare Systems Explorer website.
To check if the round has been finalized, go to [Finalizations](https://coston2-systems-explorer.flare.rocks/finalizations) page.

To learn more about how the FDC protocol works, check [here](/fdc/overview).

## Prepare proof request

We prepare the proof request in a similar manner as in the step Prepare the request, by string concatenation.
We import two new variables from the `.env` file; the URL of a verifier server and the corresponding API key.

```solidity title=""scrip/fdcExample/JsonApi.s.sol""
string memory daLayerUrl = vm.envString(""COSTON2_DA_LAYER_URL"");
string memory apiKey = vm.envString(""X_API_KEY"");
```

Also, by repeatedly using the Foundry shortcode `vm.readLine`, we read the data, saved to a file in the previous step, to variables.

```solidity title=""scrip/fdcExample/JsonApi.s.sol""
string memory requestBytes = vm.readLine(
    string.concat(
        dirPath,
        attestationTypeName,
        ""_abiEncodedRequest"",
        "".txt""
    )
);
string memory votingRoundId = vm.readLine(
    string.concat(
        dirPath,
        attestationTypeName,
        ""_votingRoundId"",
        "".txt""
    )
);
```

The code is as follows.

```solidity title=""scrip/fdcExample/JsonApi.s.sol""
contract RetrieveDataAndProof is Script {
 using Surl for *;

 function run() external {
    string memory daLayerUrl = vm.envString(""COSTON2_DA_LAYER_URL"");
    string memory apiKey = vm.envString(""X_API_KEY"");

    string memory requestBytes = vm.readLine(
        string.concat(
            dirPath,
            attestationTypeName,
            ""_abiEncodedRequest"",
            "".txt""
        )
    );
    string memory votingRoundId = vm.readLine(
        string.concat(
            dirPath,
            attestationTypeName,
            ""_votingRoundId"",
            "".txt""
        )
    );

    console.log(""votingRoundId: %s\n"", votingRoundId);
    console.log(""requestBytes: %s\n"", requestBytes);

    string[] memory headers = Base.prepareHeaders(apiKey);
    string memory body = string.concat(
        '{""votingRoundId"":',
        votingRoundId,
        ',""requestBytes"":""',
        requestBytes,
        '""}'
    );
    console.log(""body: %s\n"", body);
    console.log(
        ""headers: %s"",
        string.concat(""{"", headers[0], "", "", headers[1]),
        ""}\n""
    );


 ...
 }
}
```

## Post proof request to DA Layer

We post the proof request to a chosen DA Layer provider server also with the same code as we did in the previous step.

```solidity title=""scrip/fdcExample/JsonApi.s.sol""
string memory url = string.concat(
 daLayerUrl,
 // ""api/v0/fdc/get-proof-round-id-bytes""
 ""api/v1/fdc/proof-by-request-round-raw""
);
console.log(""url: %s\n"", url);

(, bytes memory data) = Base.postAttestationRequest(url, headers, body);
```

Parsing the returned data requires the definition of an auxiliary `struct`.

{/* <!-- TODO rename after renaming --> */}

```solidity title=""scrip/fdcExample/Base.s.sol""
struct ParsableProof {
 bytes32 attestationType;
 bytes32[] proofs;
 bytes responseHex;
}
```

The field `attestationType` holds the UTF8 encoded hex string of the attestation type name, padded to 32 bytes.
Thus, it should match the value of the `attestationType` parameter in the Prepare the request step.
In our case, that value is `0x4164647265737356616c69646974790000000000000000000000000000000000`.

The array `proofs` holds the Merkle proofs of our attestation request.

Lastly, `responseHex` is the ABI encoding of the chosen attestation type response struct.
In this case, it is the `IJsonApi.Response` struct.
We retrieve this data as follows.

```solidity title=""scrip/fdcExample/JsonApi.s.sol""
bytes memory dataJson = parseData(data);
ParsableProof memory proof = abi.decode(dataJson, (ParsableProof));

IJsonApi.Response memory proofResponse = abi.decode(
 proof.responseHex,
 (IJsonApi.Response)
);
```

## Verify proof

FDC optimizes on-chain storage costs by implementing a hybrid data verification system.
Instead of storing complete datasets on-chain, it stores only Merkle proofs, while maintaining the actual data through trusted off-chain providers.
This approach significantly reduces gas costs while preserving data integrity.

When requested, data providers supply the original data along with its corresponding Merkle proof.
The protocol verifies data authenticity by comparing the provided Merkle proof against the on-chain Merkle root.
A successful match confirms the data's integrity and authenticity within the FDC system.

While data verification is optional if you trust your data provider, FDC ensures transparency by making verification possible at any time.
This capability is crucial for maintaining system integrity and allowing users to independently verify data when needed, particularly in production environments.

FDC provides verification functionality through the `FdcVerification` contract.
To verify address validity, we first format our data using the `IEVMTransaction.Proof` struct, which contains both the Merkle proof and the response data.

```solidity title=""scrip/fdcExample/JsonApi.s.sol""
IJsonApi.Proof memory _proof = IJsonApi.Proof(
 proof.proofs,
 proofResponse
);
```

We then access the `FdcVerification` contract through the `ContractRegistry`, and feed it the proof.
If the proof is valid, the function `verifyJsonApi` will return `true`, otherwise `false`.
As before, we wrap the whole thing into a broadcast environment, using the `PRIVATE_KEY` variable from our `.env` file.

```solidity title=""scrip/fdcExample/JsonApi.s.sol""
uint256 deployerPrivateKey = vm.envUint(""PRIVATE_KEY"");
vm.startBroadcast(deployerPrivateKey);

bool isValid = ContractRegistry
 .getFdcVerification()
 .verifyJsonApi(proof);
console.log(""proof is valid: %s\n"", StringsBase.toString(isValid));

vm.stopBroadcast();
```

In actuality, we will only verify the proof within a deployed contract, which we will define in the next step.
What we will do here instead is, we will save the proof to a file so that it can be later loaded into a variable.
The code that does this is as follows.

```solidity title=""scrip/fdcExample/EVMTransaction.s.sol""
Base.writeToFile(
    dirPath,
    string.concat(attestationTypeName, ""_proof""),
    StringsBase.toHexString(abi.encode(_proof)),
    true
);
```

## Use the data

{/* TODO */}

We will now define a simple contract, that will demonstrate how the data can be used onchain.
The contract will receive character data from the [Star Wars API](https://swapi.dev/), and store it in a `StarWarsCharacter` struct.
It will do so only if the proof is valid.

```solidity title=""src/fdcExample/JsonApi.sol""
struct StarWarsCharacter {
    string name;
    uint256 numberOfMovies;
    uint256 apiUid;
    uint256 bmi;
}

```

We will also need a `DataTransportObject` struct, that will allow us to decode the data.

```solidity title=""src/fdcExample/JsonApi.sol""
struct DataTransportObject {
    string name;
    uint256 height;
    uint256 mass;
    uint256 numberOfMovies;
    uint256 apiUid;
}
```

First, we define an interface that the contract will inherit from.
We do so, so that we may contact the contract later through a script.

```solidity title=""src/fdcExample/JsonApi.sol""
interface IStarWarsCharacterList {
    function addCharacter(IJsonApi.Proof calldata data) external;
    function getAllCharacters()
        external
        view
        returns (StarWarsCharacter[] memory);
}
```

The interface exposes the two functions that a user might call, `addCharacter` and `getAllCharacters`.
We now define the contract as follows.

```solidity title=""src/fdcExample/JsonApi.sol""

contract StarWarsCharacterList {
    mapping(uint256 => StarWarsCharacter) public characters;
    uint256[] public characterIds;

    function isJsonApiProofValid(
        IJsonApi.Proof calldata _proof
    ) private view returns (bool) {
        // Inline the check for now until we have an official contract deployed
        return
            ContractRegistry.auxiliaryGetIJsonApiVerification().verifyJsonApi(
                _proof
            );
    }

    function addCharacter(IJsonApi.Proof calldata data) public {
        require(isJsonApiProofValid(data), ""Invalid proof"");

        DataTransportObject memory dto = abi.decode(
            data.data.responseBody.abi_encoded_data,
            (DataTransportObject)
        );

        require(characters[dto.apiUid].apiUid == 0, ""Character already exists"");

        StarWarsCharacter memory character = StarWarsCharacter({
            name: dto.name,
            numberOfMovies: dto.numberOfMovies,
            apiUid: dto.apiUid,
            bmi: (dto.mass * 100 * 100) / (dto.height * dto.height)
        });

        characters[dto.apiUid] = character;
        characterIds.push(dto.apiUid);
    }

    function getAllCharacters()
        public
        view
        returns (StarWarsCharacter[] memory)
    {
        StarWarsCharacter[] memory result = new StarWarsCharacter[](
            characterIds.length
        );
        for (uint256 i = 0; i < characterIds.length; i++) {
            result[i] = characters[characterIds[i]];
        }
        return result;
    }
}
```

We deploy the contract through a simple script.
The script creates a new `StarWarsCharacterList` contract and writes its address to a file (`data/JsonApi_listenerAddress.txt`).

```solidity title=""scrip/fdcExample/DeployContract.s.sol""
contract DeployContract is Script {
    function run() external {
        uint256 deployerPrivateKey = vm.envUint(""PRIVATE_KEY"");
        vm.startBroadcast(deployerPrivateKey);

        StarWarsCharacterList characterList = new StarWarsCharacterList();
        address _address = address(characterList);

        vm.stopBroadcast();

        Base.writeToFile(
            dirPath,
            string.concat(attestationTypeName, ""_address""),
            StringsBase.toHexString(abi.encodePacked(_address)),
            true
        );
    }
}
```

We deploy the contract with the following console command.

```bash
forge script script/fdcExample/JsonApi.s.sol:DeployContract --private-key $PRIVATE_KEY --rpc-url $COSTON2_RPC_URL --etherscan-api-key $FLARE_API_KEY --broadcast --verify --ffi
```

Lastly, we define a script that interacts with the above contract.
It first reads the ABI-encoded proof data, and the contract address, from files.
Then, it connects to the above contract at the saved address (this is why we require the interface).
With that, it can call the `registerJsonApi` method of the contract.

```solidity title=""script/fdcExample/JsonApi.s.sol""
contract InteractWithContract is Script {
    function run() external {
        string memory addressString = vm.readLine(
            string.concat(dirPath, attestationTypeName, ""_address"", "".txt"")
        );
        address _address = vm.parseAddress(addressString);
        string memory proofString = vm.readLine(
            string.concat(dirPath, attestationTypeName, ""_proof"", "".txt"")
        );
        bytes memory proofBytes = vm.parseBytes(proofString);
        IJsonApi.Proof memory proof = abi.decode(proofBytes, (IJsonApi.Proof));
        uint256 deployerPrivateKey = vm.envUint(""PRIVATE_KEY"");
        vm.startBroadcast(deployerPrivateKey);
        IStarWarsCharacterList characterList = IStarWarsCharacterList(_address);
        characterList.addCharacter(proof);
        vm.stopBroadcast();
    }
}
```

We run this script with the console command:

```bash
forge script script/fdcExample/JsonApi.s.sol:InteractWithContract --private-key $PRIVATE_KEY --rpc-url $COSTON2_RPC_URL --etherscan-api-key $FLARE_API_KEY --broadcast --ffi

```",2025-03-08 01:27:14
confirm-block-height.mdx,"title: Confirm Block Height
authors: [lukaavbreht, filipkoprivec]
description: Confirm the block height on Bitcoin, Dogecoin or XRPL.
tags: [intermediate, ethereum, fdc]
keywords: [ethereum, flare-data-connector, evm, flare-network]
sidebar_position: 4
unlisted: true","This guide focuses on the [ConfirmedBlockHeightExists](/fdc/attestation-types/confirmed-block-height-exists) attestation type, an efficient way to assert whether a specific `blockNumber` is confirmed with additional data to compute the block production rate within a given time window.
The primary contract interface for this attestation type is [`IConfirmedBlockHeightExists`](/fdc/reference/IFdcHub).

### Type Definition

```solidity title=""ConfirmedBlockHeightExists.sol""
// SPDX-License-Identifier: MIT
pragma solidity >=0.7.6 <0.9;

/**
 * @custom:name ConfirmedBlockHeightExists
 * @custom:id 0x03
 * @custom:supported BTC, DOGE, XRP, testBTC, testDOGE, testXRP
 * @author Flare
 * @notice An assertion that a block with `blockNumber` is confirmed.
 * It also provides data to compute the block production rate in the given time range.
 * @custom:verification It is checked that the block with `blockNumber` is confirmed by at least `numberOfConfirmations`.
 * If it is not, the request is rejected. We note a block on the tip of the chain is confirmed by 1 block.
 * Then `lowestQueryWindowBlock` is determined and its number and timestamp are extracted.
 *
 *
 *  Current confirmation heights consensus:
 *
 *
 * | `Chain` | `chainId` | `numberOfConfirmations` | `timestamp ` |
 * | ------- | --------- | ----------------------- | ------------ |
 * | `BTC`   | 0         | 6                       | mediantime   |
 * | `DOGE`  | 2         | 60                      | mediantime   |
 * | `XRP`   | 3         | 3                       | close_time   |
 *
 *
 *
 *
 * @custom:lut `lowestQueryWindowBlockTimestamp`
 */
interface ConfirmedBlockHeightExists {
    /**
     * @notice Toplevel request
     * @param attestationType ID of the attestation type.
     * @param sourceId ID of the data source.
     * @param messageIntegrityCode `MessageIntegrityCode` that is derived from the expected response as defined.
     * @param requestBody Data defining the request. Type (struct) and interpretation is determined by the `attestationType`.
     */
    struct Request {
        bytes32 attestationType;
        bytes32 sourceId;
        bytes32 messageIntegrityCode;
        RequestBody requestBody;
    }

    /**
     * @notice Toplevel response
     * @param attestationType Extracted from the request.
     * @param sourceId Extracted from the request.
     * @param votingRound The ID of the Data Connector round in which the request was considered.
     * @param lowestUsedTimestamp The lowest timestamp used to generate the response.
     * @param requestBody Extracted from the request.
     * @param responseBody Data defining the response. The verification rules for the construction of the response body and the type are defined per specific `attestationType`.
     */
    struct Response {
        bytes32 attestationType;
        bytes32 sourceId;
        uint64 votingRound;
        uint64 lowestUsedTimestamp;
        RequestBody requestBody;
        ResponseBody responseBody;
    }

    /**
     * @notice Toplevel proof
     * @param merkleProof Merkle proof corresponding to the attestation response.
     * @param data Attestation response.
     */
    struct Proof {
        bytes32[] merkleProof;
        Response data;
    }

    /**
     * @notice Request body for ConfirmedBlockHeightExistsType attestation type
     * @param blockNumber The number of the block the request wants a confirmation of.
     * @param queryWindow The length of the period in which the block production rate is to be computed.
     */
    struct RequestBody {
        uint64 blockNumber;
        uint64 queryWindow;
    }

    /**
     * @notice Response body for ConfirmedBlockHeightExistsType attestation type
     * @custom:below `blockNumber`, `lowestQueryWindowBlockNumber`, `blockTimestamp` and `lowestQueryWindowBlockTimestamp` can be used to compute the average block production time in the specified block range.
     * @param blockTimestamp The timestamp of the block with `blockNumber`.
     * @param numberOfConfirmations The depth at which a block is considered confirmed depending on the chain. All attestation providers must agree on this number.
     * @param lowestQueryWindowBlockNumber The block number of the latest block that has a timestamp strictly smaller than `blockTimestamp` - `queryWindow`.
     * @param lowestQueryWindowBlockTimestamp The timestamp of the block at height `lowestQueryWindowBlockNumber`.
     */
    struct ResponseBody {
        uint64 blockTimestamp;
        uint64 numberOfConfirmations;
        uint64 lowestQueryWindowBlockNumber;
        uint64 lowestQueryWindowBlockTimestamp;
    }
}
```

The request body is quite simple. You provide the `blockNumber` you want to confirm exists on the chain and the `queryWindow`‚Äîthe length of the period in which the block production rate is to be computed (relative to the timestamp of the block you are requesting). Importantly, for the block to be considered visible, at least `X` blocks above it must be confirmed. This ensures that blocks not on the main chain are not confirmed. The number of confirmations required varies by chain and is listed in the specification.

#### What Do You Get in Return?

As per the specification, you only receive information confirming that the block with `blockNumber` is confirmed by at least `numberOfConfirmations`. If the block is not confirmed, the request is rejected (none of the attestation clients will confirm the response, and it will not be included in the Merkle tree). The response body contains the following fields:

- **`blockTimestamp`**: The timestamp of the block with `blockNumber`.

- **`numberOfConfirmations`**: The depth at which a block is considered confirmed depending on the chain. This is fixed per chain and specified in the documentation.

- **`lowestQueryWindowBlockNumber`**: The block number of the latest block that has a timestamp strictly smaller than `blockTimestamp` - `queryWindow`. This allows you to gauge the average block production time in the specified block range.

- **`lowestQueryWindowBlockTimestamp`**: The timestamp of the block at height `lowestQueryWindowBlockNumber`, indicating when the block was produced.

### Example

To check the top block, you would typically query the RPC of the chain, get the top block, subtract the number of confirmations, and then query the attestation client to get the result. Alternatively, you can piggyback on the previous example, create a transaction, see the block it was included in, and proceed from there.

Each attestation provider also exposes several diagnostic endpoints that allow you to get information about the chain it is operating on. The endpoint that is particularly interesting for this purpose is the `block-range` endpoint, which returns the range of blocks the attestation provider is currently observing.

By querying the `block-range` endpoint, you can get the range of blocks the attestation provider is observing and then request the confirmation of the top block in that range. This approach allows you to verify the top block efficiently without manually tracking the block production and confirmation process.

Use the following code (also found in `tryConfirmedBlockHeightExists.ts`) and try to see how `prepareResponse` fares for blocks that are out of range for the current confirmation limit. This will help you understand how the attestation client handles requests for blocks that have not yet reached the necessary number of confirmations.

```typescript title=""tryConfirmedBlockHeightExists.ts""
const { ATTESTATION_URL, ATTESTATION_API_KEY } = process.env;

function toHex(data: string): string {
  var result = """";
  for (var i = 0; i < data.length; i++) {
    result += data.charCodeAt(i).toString(16);
  }
  return ""0x"" + result.padEnd(64, ""0"");
}

function fromHex(data: string): string {
  data = data.replace(/^(0x\.)/, """");
  return data
    .split(/(\w\w)/g)
    .filter((p) => !!p)
    .map((c) => String.fromCharCode(parseInt(c, 16)))
    .join("""");
}

async function prepareAttestationResponse(
  attestationType: string,
  network: string,
  sourceId: string,
  requestBody: any,
): Promise<AttestationResponse> {
  const response = await fetch(
    `${ATTESTATION_URL}/verifier/${network}/${attestationType}/prepareResponse`,
    {
      method: ""POST"",
      headers: {
        ""X-API-KEY"": ATTESTATION_API_KEY as string,
        ""Content-Type"": ""application/json"",
      },
      body: JSON.stringify({
        attestationType: toHex(attestationType),
        sourceId: toHex(sourceId),
        requestBody: requestBody,
      }),
    },
  );
  const data = await response.json();
  return data;
}

async function getVerifierBlockRange(network: string): Promise<any> {
  return (
    await (
      await fetch(
        `${ATTESTATION_URL}/verifier/${network}/api/indexer/block-range`,
        {
          method: ""GET"",
          headers: {
            ""X-API-KEY"": ATTESTATION_API_KEY as string,
            ""Content-Type"": ""application/json"",
          },
        },
      )
    ).json()
  ).data;
}

async function main() {
  const btcRange = await getVerifierBlockRange(""btc"");
  const dogeRange = await getVerifierBlockRange(""doge"");
  const xrplRange = await getVerifierBlockRange(""xrp"");

  console.log(""BTC Range: "", btcRange);
  console.log(
    await prepareAttestationResponse(
      ""ConfirmedBlockHeightExists"",
      ""btc"",
      ""testBTC"",
      {
        blockNumber: btcRange.last.toString(),
        queryWindow: ""123"",
      },
    ),
  );

  console.log(""DOGE Range: "", dogeRange);
  console.log(
    await prepareAttestationResponse(
      ""ConfirmedBlockHeightExists"",
      ""doge"",
      ""testDOGE"",
      {
        blockNumber: dogeRange.last.toString(),
        queryWindow: ""123"",
      },
    ),
  );

  console.log(""XRPL Range: "", xrplRange);
  console.log(
    await prepareAttestationResponse(
      ""ConfirmedBlockHeightExists"",
      ""xrp"",
      ""testXRP"",
      {
        blockNumber: xrplRange.last.toString(),
        queryWindow: ""123"",
      },
    ),
  );
}

main().then(() => process.exit(0));
```

Which will output a response similar to this:

```json
BTC Range:  { first: 2578997, last: 2579392 }
{
  status: 'VALID',
  response: {
    attestationType: '0x436f6e6669726d6564426c6f636b486569676874457869737473000000000000',
    sourceId: '0x7465737442544300000000000000000000000000000000000000000000000000',
    votingRound: '0',
    lowestUsedTimestamp: '1708812188',
    requestBody: { blockNumber: '2579392', queryWindow: '123' },
    responseBody: {
      blockTimestamp: '1708812188',
      numberOfConfirmations: '6',
      lowestQueryWindowBlockNumber: '2579391',
      lowestQueryWindowBlockTimestamp: '1708812020'
    }
  }
}
DOGE Range:  { first: 5706001, last: 5974548 }
{
  status: 'VALID',
  response: {
    attestationType: '0x436f6e6669726d6564426c6f636b486569676874457869737473000000000000',
    sourceId: '0x74657374444f4745000000000000000000000000000000000000000000000000',
    votingRound: '0',
    lowestUsedTimestamp: '1708819752',
    requestBody: { blockNumber: '5974548', queryWindow: '123' },
    responseBody: {
      blockTimestamp: '1708819752',
      numberOfConfirmations: '60',
      lowestQueryWindowBlockNumber: '5974543',
      lowestQueryWindowBlockTimestamp: '1708819511'
    }
  }
}
XRPL Range:  { first: 45585486, last: 45678173 }
{
  status: 'VALID',
  response: {
    attestationType: '0x436f6e6669726d6564426c6f636b486569676874457869737473000000000000',
    sourceId: '0x7465737458525000000000000000000000000000000000000000000000000000',
    votingRound: '0',
    lowestUsedTimestamp: '1708822152',
    requestBody: { blockNumber: '45678173', queryWindow: '123' },
    responseBody: {
      blockTimestamp: '1708822152',
      numberOfConfirmations: '1',
      lowestQueryWindowBlockNumber: '45678132',
      lowestQueryWindowBlockTimestamp: '1708822022'
    }
  }
}
```

This attestation type is also useful for observing another important response: `INDETERMINATE`.

An `INDETERMINATE` response means that the attestation can't be confirmed (yet) because there are not enough confirmations for the block. This response indicates that the attestation client cannot confirm or reject the block for sure, but it might be valid in the future once more confirmations are received.

To see this in action, take the provided code and check for a block that has not yet been confirmed by the required amount. The easiest way to do this is to add 10 to the block range and observe the response. If done correctly, the response should be:

```json
{
  ""status"": ""INDETERMINATE""
}
```

One important thing to note is that all numbers are sent as strings (either decimal or hex). The main reason for this is that JavaScript does not have a native 64-bit integer type, and numbers are represented as 64-bit floating-point numbers, which can lead to incorrect representation of large numbers. Even though block numbers might not be that large, encoding JSON numbers as strings ensures they are represented correctly.",2025-03-08 01:27:14
verify-payment-nonexistence.mdx,"title: Verify Payment Nonexistence
authors: [lukaavbreht, filipkoprivec]
description: Verify the nonexistence of a UTXO or XRPL payment.
tags: [intermediate, ethereum, fdc]
keywords: [ethereum, flare-data-connector, evm, flare-network]
sidebar_position: 9
unlisted: true","## Reference Payment Nonexistence

[Full specification on GitHub](https://github.com/flare-foundation/songbird-state-connector-protocol/blob/main/specs/attestations/active-types/ReferencedPaymentNonexistence.md).

You are getting more and more familiar with the attestation types, and you are starting to see that they are very powerful and can be used in many different ways. Let's check a more involved one‚Äîthe `ReferencePaymentNonexistence` type.

This type is a bit more difficult to implement and properly use, as it requires the attestation client to do a lot of work‚Äîthey need to prove that a certain payment has not been made. Instead of looking at the transaction and checking if it is valid, you will be looking at the block range and checking that no valid payment conforming to your requirements has been made in the specified block range.

### Type Definition

```solidity title=""ReferencedPaymentNonexistence.sol""
// SPDX-License-Identifier: MIT
pragma solidity >=0.7.6 <0.9;

/**
 * @custom:name ReferencedPaymentNonexistence
 * @custom:id 0x04
 * @custom:supported BTC, DOGE, XRP, testBTC, testDOGE, testXRP
 * @author Flare
 * @notice Assertion that an agreed-upon payment has not been made by a certain deadline.
 * A confirmed request shows that a transaction meeting certain criteria (address, amount, reference) did not appear in the specified block range.
 *
 *
 * This type of attestation can be used to e.g. provide grounds to liquidate funds locked by a smart contract on Flare when a payment is missed.
 *
 * @custom:verification If `firstOverflowBlock` cannot be determined or does not have a sufficient [number of confirmations](/specs/attestations/configs.md#finalityconfirmation), the attestation request is rejected.
 * If `firstOverflowBlockNumber` is higher or equal to `minimalBlockNumber`, the request is rejected.
 * The search range are blocks between heights including `minimalBlockNumber` and excluding `firstOverflowBlockNumber`.
 * If the verifier does not have a view of all blocks from `minimalBlockNumber` to `firstOverflowBlockNumber`, the attestation request is rejected.
 *
 * The request is confirmed if no transaction meeting the specified criteria is found in the search range.
 * The criteria and timestamp are chain specific.
 * ### UTXO (Bitcoin and Dogecoin)
 *
 *
 * Criteria for the transaction:
 *
 *
 * - It is not coinbase transaction.
 * - The transaction has the specified [standardPaymentReference](/specs/attestations/external-chains/standardPaymentReference.md#btc-and-doge-blockchains).
 * - The sum of values of all outputs with the specified address minus the sum of values of all inputs with the specified address is greater than `amount` (in practice the sum of all values of the inputs with the specified address is zero).
 *
 *
 * Timestamp is `mediantime`.

 * ### XRPL
 *
 *
 *
 * Criteria for the transaction:
 * - The transaction is of type payment.
 * - The transaction has the specified [standardPaymentReference](/specs/attestations/external-chains/standardPaymentReference.md#xrp),
 * - One of the following is true:
 *   - Transaction status is `SUCCESS` and the amount received by the specified destination address is greater than the specified `value`.
 *   - Transaction status is `RECEIVER_FAILURE` and the specified destination address would receive an amount greater than the specified `value` had the transaction been successful.
 *
 *
 * Timestamp is `close_time` converted to UNIX time.
 *
 * @custom:lut `minimalBlockTimestamp`
 */
interface ReferencedPaymentNonexistence {
    /**
     * @notice Toplevel request
     * @param attestationType ID of the attestation type.
     * @param sourceId ID of the data source.
     * @param messageIntegrityCode `MessageIntegrityCode` that is derived from the expected response as defined.
     * @param requestBody Data defining the request. Type (struct) and interpretation is determined by the `attestationType`.
     */
    struct Request {
        bytes32 attestationType;
        bytes32 sourceId;
        bytes32 messageIntegrityCode;
        RequestBody requestBody;
    }

    /**
     * @notice Toplevel response
     * @param attestationType Extracted from the request.
     * @param sourceId Extracted from the request.
     * @param votingRound The ID of the Data Connector round in which the request was considered.
     * @param lowestUsedTimestamp The lowest timestamp used to generate the response.
     * @param requestBody Extracted from the request.
     * @param responseBody Data defining the response. The verification rules for the construction of the response body and the type are defined per specific `attestationType`.
     */
    struct Response {
        bytes32 attestationType;
        bytes32 sourceId;
        uint64 votingRound;
        uint64 lowestUsedTimestamp;
        RequestBody requestBody;
        ResponseBody responseBody;
    }

    /**
     * @notice Toplevel proof
     * @param merkleProof Merkle proof corresponding to the attestation response.
     * @param data Attestation response.
     */
    struct Proof {
        bytes32[] merkleProof;
        Response data;
    }

    /**
     * @notice Request body for ReferencePaymentNonexistence attestation type
     * @param minimalBlockNumber The start block of the search range.
     * @param deadlineBlockNumber The blockNumber to be included in the search range.
     * @param deadlineTimestamp The timestamp to be included in the search range.
     * @param destinationAddressHash The standard address hash of the address to which the payment had to be done.
     * @param amount The requested amount in minimal units that had to be paid.
     * @param standardPaymentReference The requested standard payment reference.
     * @custom:below The `standardPaymentReference` should not be zero (as a 32-byte sequence).
     */
    struct RequestBody {
        uint64 minimalBlockNumber;
        uint64 deadlineBlockNumber;
        uint64 deadlineTimestamp;
        bytes32 destinationAddressHash;
        uint256 amount;
        bytes32 standardPaymentReference;
    }

    /**
     * @notice Response body for ReferencePaymentNonexistence attestation type.
     * @param minimalBlockTimestamp The timestamp of the minimalBlock.
     * @param firstOverflowBlockNumber The height of the firstOverflowBlock.
     * @param firstOverflowBlockTimestamp The timestamp of the firstOverflowBlock.
     * @custom:below `firstOverflowBlock` is the first block that has block number higher than `deadlineBlockNumber` and timestamp later than `deadlineTimestamp`.
     * The specified search range are blocks between heights including `minimalBlockNumber` and excluding `firstOverflowBlockNumber`.
     */
    struct ResponseBody {
        uint64 minimalBlockTimestamp;
        uint64 firstOverflowBlockNumber;
        uint64 firstOverflowBlockTimestamp;
    }
}
```

#### Request Body

The request body for the `ReferencePaymentNonexistence` attestation type is a bit larger, as you need to specify the range of blocks to check and the criteria for the payment to check.

- **`minimalBlockNumber`**: The start block of the search range.

- **`deadlineBlockNumber`**: The block number to be included in the search range.

- **`deadlineTimestamp`**: The timestamp to be included in the search range. By including both block number and timestamp, the requested range will encompass all blocks from `minimalBlockNumber` to `deadlineBlockNumber` and all blocks with timestamps from `minimalBlockTimestamp` to `deadlineTimestamp`.

- **`destinationAddressHash`**: The standard address hash of the address to which the payment should have been made.

- **`amount`**: The requested amount in minimal units that should have been paid. The amount is chain specific.

- **`standardPaymentReference`**: The requested standard payment reference that the payment should have had.

#### Response Body

The response body is simpler and essentially contains the searched range:

- **`minimalBlockTimestamp`**: The timestamp of the minimal block that was included in the search range‚Äîthis is the timestamp of the block with `minimalBlockNumber`.

- **`firstOverflowBlockNumber`**: The height of the first overflow block. This is the first block with a block number higher than `deadlineBlockNumber` and a timestamp later than `deadlineTimestamp`.

- **`firstOverflowBlockTimestamp`**: The timestamp of the first overflow block. This is the timestamp of the first block with a block number higher than `deadlineBlockNumber` and a timestamp later than `deadlineTimestamp`.

#### Confirmation

If the request is confirmed, it means that there was no payment in the specified range (including the minimal block, but excluding the maximal block) with an amount greater than or equal to the requested amount and with the requested reference.

The full rules for verification are quite complex (and chain-dependent) and are available in the [specification](https://github.com/flare-foundation/songbird-state-connector-protocol/blob/main/specs/attestations/active-types/ReferencedPaymentNonexistence.md#verification). The important point is that the request is confirmed if no transaction meeting the specified criteria is found in the search range.

### Example

To produce a correct and thorough example that allows you to test everything properly, you need to be careful. Since you are proving a negative, any mistake during request preparation can result in a transaction that was not made (a simple mis-encoding of a memo field would almost certainly produce a non-existing transaction) and give a false sense of security.

To ensure accuracy, structure your request as follows:

1. **Create a transaction** with a reference payment and some nonzero value.
2. **Confirm `Payment` attestation request** to make sure you get back the correct reference and value, ensuring the transaction is seen. Use the information about when this transaction happened to construct a range for the next step, ensuring it contains your transaction.
3. **Make three requests for non-existing payments**:
   - **Correct (or lower) value and correct reference**: This should return `INVALID`, as the verifier can't prove the non-existence of such a transaction.
   - **Correct value but slightly wrong payment reference**: Change just one index of the reference. This should be confirmed, as no such transaction exists (the payment reference does not match).
   - **Too large value but correct payment reference**: This should be confirmed, as the transaction with the payment reference exists but does not transfer enough value.

#### XRP Ledger

The example code that showcases this on testnet XRP Ledger is available in `tryXRPLPaymentNonExistence.ts`.

```typescript title=""tryXRPLPaymentNonExistence.ts""
const xrpl = require(""xrpl"");

const { XRPL_PRIVATE_KEY, ATTESTATION_URL, ATTESTATION_API_KEY } = process.env;
const receiverAddress = ""r9RLXvWuRro3RX33pk4xsN58tefYZ8Tvbj"";

function toHex(data: string): string {
  var result = """";
  for (var i = 0; i < data.length; i++) {
    result += data.charCodeAt(i).toString(16);
  }
  return ""0x"" + result.padEnd(64, ""0"");
}

function fromHex(data: string): string {
  data = data.replace(/^(0x\.)/, """");
  return data
    .split(/(\w\w)/g)
    .filter((p) => !!p)
    .map((c) => String.fromCharCode(parseInt(c, 16)))
    .join("""");
}

async function prepareAttestationResponse(
  attestationType: string,
  network: string,
  sourceId: string,
  requestBody: any,
): Promise<AttestationResponse> {
  const response = await fetch(
    `${ATTESTATION_URL}/verifier/${network}/${attestationType}/prepareResponse`,
    {
      method: ""POST"",
      headers: {
        ""X-API-KEY"": ATTESTATION_API_KEY as string,
        ""Content-Type"": ""application/json"",
      },
      body: JSON.stringify({
        attestationType: toHex(attestationType),
        sourceId: toHex(sourceId),
        requestBody: requestBody,
      }),
    },
  );
  const data = await response.json();
  return data;
}

async function getXRPLclient(): Promise<any> {
  const client = new xrpl.Client(""wss://s.altnet.rippletest.net:51233"");
  await client.connect();

  return client;
}

async function sendXRPLTransaction(
  message: string = """",
  amount: number = 10,
  target: string = ""r9RLXvWuRro3RX33pk4xsN58tefYZ8Tvbj"",
): Promise<string> {
  const client = await getXRPLclient();

  const test_wallet = xrpl.Wallet.fromSeed(XRPL_PRIVATE_KEY);

  // Standard payment reference must be 32 bytes - so we right pad with 0
  const MemoData = xrpl.convertStringToHex(message).padEnd(64, ""0"");
  const MemoType = xrpl.convertStringToHex(""Text"");
  const MemoFormat = xrpl.convertStringToHex(""text/plain"");

  let memos = [];
  if (message) {
    memos.push({
      Memo: {
        MemoType: MemoType,
        MemoData: MemoData,
        MemoFormat: MemoFormat,
      },
    });
  }

  const transaction = await client.autofill({
    TransactionType: ""Payment"",
    Account: test_wallet.address,
    Amount: amount.toString(),
    Destination: target,
    Memos: memos,
  });

  const signed = test_wallet.sign(transaction);
  console.log(
    `See transaction at https://testnet.xrpl.org/transactions/${signed.hash}`,
  );
  await client.submitAndWait(signed.tx_blob);

  await client.disconnect();

  // sleep for 10 seconds to allow the transaction to be processed
  await new Promise((resolve) => setTimeout(resolve, 10 * 1000));
  console.log(""Payment:"");
  // 1. prove the payment:
  const resultPayment = await prepareAttestationResponse(
    ""Payment"",
    ""xrp"",
    ""testXRP"",
    {
      transactionId: ""0x"" + signed.hash,
      inUtxo: ""0"",
      utxo: ""0"",
    },
  );

  if (resultPayment.status != ""VALID"") {
    console.log(""Something wrong when confirming payment"");
  }
  console.log(resultPayment);
  if (
    resultPayment.response.responseBody.standardPaymentReference !=
    ""0x"" + MemoData
  ) {
    console.log(""Something wrong with message reference"");
    console.log(resultPayment.response.responseBody.standardPaymentReference);
    console.log(MemoData);
  }
  if (
    resultPayment.response.responseBody.receivingAddressHash !=
    web3.utils.soliditySha3(target)
  ) {
    console.log(""Something wrong with target address hash"");
  }

  // Get information about transaction: block and block timestamp -> we will need this to create the range, where the transaction has happened
  console.log(""Failing non existence proof:"");
  const blockNumber = Number(resultPayment.response.responseBody.blockNumber);
  const blockTimestamp = Number(
    resultPayment.response.responseBody.blockTimestamp,
  );

  const targetRange = {
    minimalBlockNumber: (blockNumber - 5).toString(), // Search few block before
    deadlineBlockNumber: (blockNumber + 1).toString(), // Search a few blocks after, but not too much, as they need to already be indexed by attestation clients
    deadlineTimestamp: (blockTimestamp + 3).toString(), // Search a bit after
    destinationAddressHash: web3.utils.soliditySha3(target), // The target address for transaction
  };

  // Try to verify non existence for a transaction and correct parameters
  // This should not verify it

  const resultFailedNonExistence = await prepareAttestationResponse(
    ""ReferencedPaymentNonexistence"",
    ""xrp"",
    ""testXRP"",
    {
      ...targetRange,
      amount: amount.toString(),
      standardPaymentReference: ""0x"" + MemoData,
    },
  );

  console.log(resultFailedNonExistence);

  if (resultFailedNonExistence.status != ""INVALID"") {
    console.log(""Something wrong with failed non existence"");
  }

  console.log(""Successful non existence proofs:"");

  // Change the memo field a bit and successfully prove non existence
  let wrongMemoData = xrpl.convertStringToHex(message).padEnd(64, ""1""); // We pad 1 instead of 0
  const resultWrongMemoNonExistence = await prepareAttestationResponse(
    ""ReferencedPaymentNonexistence"",
    ""xrp"",
    ""testXRP"",
    {
      ...targetRange,
      amount: amount.toString(),
      standardPaymentReference: ""0x"" + wrongMemoData,
    },
  );

  console.log(resultWrongMemoNonExistence);

  if (resultWrongMemoNonExistence.status != ""VALID"") {
    console.log(""Something wrong with wrong memo non existence"");
  }

  // Change the value and successfully prove non existence.

  const resultWrongAmountNonExistence = await prepareAttestationResponse(
    ""ReferencedPaymentNonexistence"",
    ""xrp"",
    ""testXRP"",
    {
      ...targetRange,
      amount: (amount + 1).toString(), // Increase the amount, so the transaction we made is now invalid
      standardPaymentReference: ""0x"" + MemoData,
    },
  );

  console.log(resultWrongAmountNonExistence);

  if (resultWrongAmountNonExistence.status != ""VALID"") {
    console.log(""Something wrong with wrong amount non existence"");
  }
}

async function main() {
  await sendXRPLTransaction(""Hello world!"");
}

main().then(() => process.exit(0));
```

Keep in mind, that the requested range can be quite large, so the verifiers might not be able to confirm the response (as they might not have the view of all blocks from `minimalBlockNumber` to `firstOverflowBlockNumber`), so the request might be rejected.

```json
// See transaction at https://testnet.xrpl.org/transactions/C2B493B8AE2E3C105D004D8AFBB4AFB5CA758608504CCE895C9331291DA19D75
// Payment:
{
  status: 'VALID',
  response: {
    attestationType: '0x5061796d656e7400000000000000000000000000000000000000000000000000',
    sourceId: '0x7465737458525000000000000000000000000000000000000000000000000000',
    votingRound: '0',
    lowestUsedTimestamp: '1708830051',
    requestBody: {
      transactionId: '0xC2B493B8AE2E3C105D004D8AFBB4AFB5CA758608504CCE895C9331291DA19D75',
      inUtxo: '0',
      utxo: '0'
    },
    responseBody: {
      blockNumber: '45680731',
      blockTimestamp: '1708830051',
      sourceAddressHash: '0xa1ca3089c3e9f4c6e9ccf2bfb65bcf3e9d7544a092c79d642d5d34a54e0267e1',
      receivingAddressHash: '0x0555194538763da400394fc7184432e9a006565fa710392ea1a86486eb83920f',
      intendedReceivingAddressHash: '0x0555194538763da400394fc7184432e9a006565fa710392ea1a86486eb83920f',
      standardPaymentReference: '0x48656C6C6F20776F726C64210000000000000000000000000000000000000000',
      spentAmount: '22',
      intendedSpentAmount: '22',
      receivedAmount: '10',
      intendedReceivedAmount: '10',
      oneToOne: true,
      status: '0'
    }
  }
}
Failing non existence proof:
{ status: 'INVALID' }
Successful non existence proofs:
{
  status: 'VALID',
  response: {
    attestationType: '0x5265666572656e6365645061796d656e744e6f6e6578697374656e6365000000',
    sourceId: '0x7465737458525000000000000000000000000000000000000000000000000000',
    votingRound: '0',
    lowestUsedTimestamp: '1708830033',
    requestBody: {
      minimalBlockNumber: '45680726',
      deadlineBlockNumber: '45680732',
      deadlineTimestamp: '1708830054',
      destinationAddressHash: '0x0555194538763da400394fc7184432e9a006565fa710392ea1a86486eb83920f',
      amount: '10',
      standardPaymentReference: '0x48656C6C6F20776F726C64211111111111111111111111111111111111111111'
    },
    responseBody: {
      minimalBlockTimestamp: '45680726',
      firstOverflowBlockNumber: '45680733',
      firstOverflowBlockTimestamp: '1708830060'
    }
  }
}
{
  status: 'VALID',
  response: {
    attestationType: '0x5265666572656e6365645061796d656e744e6f6e6578697374656e6365000000',
    sourceId: '0x7465737458525000000000000000000000000000000000000000000000000000',
    votingRound: '0',
    lowestUsedTimestamp: '1708830033',
    requestBody: {
      minimalBlockNumber: '45680726',
      deadlineBlockNumber: '45680732',
      deadlineTimestamp: '1708830054',
      destinationAddressHash: '0x0555194538763da400394fc7184432e9a006565fa710392ea1a86486eb83920f',
      amount: '11',
      standardPaymentReference: '0x48656C6C6F20776F726C64210000000000000000000000000000000000000000'
    },
    responseBody: {
      minimalBlockTimestamp: '45680726',
      firstOverflowBlockNumber: '45680733',
      firstOverflowBlockTimestamp: '1708830060'
    }
  }
}
```",2025-03-08 01:27:14
check-address-validity.mdx,"title: Check Address Validity
authors: [lukaavbreht, filipkoprivec]
description: Check the validity of a Bitcoin, Dogecoin, or XRPL address.
tags: [intermediate, ethereum, fdc]
keywords: [ethereum, flare-data-connector, evm, flare-network]
sidebar_position: 3
unlisted: false","The [AddressValidity](/fdc/attestation-types/address-validity) attestation type validates whether a string represents a valid address on supported blockchain networks (`BTC`, `DOGE`, and `XRP`).
This validation ensures addresses meet chain-specific formatting and checksum requirements before they're used in transactions or smart contracts.
The full specification is available on the official [specification repo](/fdc/attestation-types/address-validity).

The primary contract interface for this attestation type is [`IAddressValidity`](/fdc/reference/IFdcHub). Let's walk through validating a Bitcoin testnet address using the FDC protocol.
We will use the address `mg9P9f4wr9w7c1sgFeiTC5oMLYXCc2c7hs` as an example throughout this guide.
You can swap this with any valid testnet address from the supported chains.
You can follow this tutorial with any other valid address - just make sure it is a valid testnet address.

This validation process works identically for `BTC`, `DOGE`, and `XRP` addresses, with only minor chain-specific parameter adjustments which we'll highlight throughout the guide.

In this guide, we will follow the steps outlined in the [FDC overview](/fdc/overview).

Our implementation requires handling the FDC voting round finalization process.
To manage this, we will create separate scripts in `script/fdcExample/AddressValidity.s.sol` that handle different stages of the validation process:

```solidity title=""scrip/fdcExample/AddressValidity.s.sol""
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.25;

import {Script} from ""dependencies/forge-std-1.9.5/src/Script.sol"";
...

// Configuration constants
string constant attestationTypeName = ""AddressValidity"";
string constant dirPath = ""data/"";

contract PrepareAttestationRequest is Script {
 ...
}

contract SubmitAttestationRequest is Script {
 ...
}

contract RetrieveDataAndProof is Script {
 ...
}

contract Deploy is Script {
 ...
}
...
```

The names of included contracts mostly mirror the steps described in the [FDC overview](/fdc/overview).

To bridge the separate script executions, we will save the relevant data of each script to a file in the `dirPath` folder.
Each succeeding script will then read that file to load the data.

## Prepare request

A JSON request to the verifier follows the same structure for all attestation types, with field values varying per type.

### Required Fields

- `attestationType`: UTF8 hex string encoding of the attestation type name, zero-padded to 32 bytes.
- `sourceId`: UTF8 hex string encoding of the data source identifier name, zero-padded to 32 bytes.
- `requestBody`: Specific to each attestation type.

For `AddressValidity`, `requestBody` contains a single field:

- `addressString`: The address to verify.

### Reference Documentation

- [AddressValidity Specification](/fdc/attestation-types/address-validity)
- [Verifier Interactive Docs](https://fdc-verifiers-testnet.flare.network/verifier/btc/api-doc#/AddressValidity/BTCAddressValidityVerifierController_prepareRequest)
- API available for [DOGE](https://fdc-verifiers-testnet.flare.network/verifier/doge/api-doc#/AddressValidity/BTCAddressValidityVerifierController_prepareRequest) and [XRP](https://fdc-verifiers-testnet.flare.network/verifier/xrp/api-doc#/AddressValidity/BTCAddressValidityVerifierController_prepareRequest).

### Example Values

- `attestationType`: UTF8 hex encoding of `AddressValidity`, zero-padded to 32 bytes.
- `sourceId`: UTF8 hex encoding of `testBTC`, zero-padded to 32 bytes.
  - `""test""` prefix denotes Bitcoin testnet.
  - Supports deployment on Flare testchains (`Coston` or `Coston2`).
  - Replace `testBTC` with `testDOGE` or `testXRP` for other chains.
- `addressString`: `mg9P9f4wr9w7c1sgFeiTC5oMLYXCc2c7hs`.

### Encoding Functions

To encode values into UTF8 hex:

- `toUtf8HexString`: Converts a string to UTF8 hex.
- `toHexString`: Zero-right-pads the string to 32 bytes.

These functions are included in the [Base library](https://github.com/flare-foundation/flare-foundry-starter/blob/master/script/fdcExample/Base.s.sol) within the [example repository](https://github.com/flare-foundation/flare-foundry-starter), but they can also be defined locally in your contract or script.

```solidity title=""scrip/fdcExample/Base.s.sol""
function toHexString(
 bytes memory data
) public pure returns (string memory) {
 bytes memory alphabet = ""0123456789abcdef"";

 bytes memory str = new bytes(2 + data.length * 2);
 str[0] = ""0"";
 str[1] = ""x"";
 for (uint i = 0; i < data.length; i++) {
 str[2 + i * 2] = alphabet[uint(uint8(data[i] >> 4))];
 str[3 + i * 2] = alphabet[uint(uint8(data[i] & 0x0f))];
 }
 return string(str);
}
```

```solidity title=""scrip/fdcExample/Base.s.sol""
function toUtf8HexString(
 string memory _string
) internal pure returns (string memory) {
 string memory encodedString = toHexString(
 abi.encodePacked(_string)
 );
 uint256 stringLength = bytes(encodedString).length;
 require(stringLength <= 64, ""String too long"");
 uint256 paddingLength = 64 - stringLength + 2;
 for (uint256 i = 0; i < paddingLength; i++) {
 encodedString = string.concat(encodedString, ""0"");
 }
 return encodedString;
}
```

We also define a helper function for formatting data into a JSON string.

```solidity title=""scrip/fdcExample/Base.s.sol""
function prepareAttestationRequest(
 string memory attestationType,
 string memory sourceId,
 string memory requestBody
) internal view returns (string[] memory, string memory) {
 // We read the API key from the .env file
 string memory apiKey = vm.envString(""VERIFIER_API_KEY"");

 // Preparing headers
 string[] memory headers = prepareHeaders(apiKey);
 // Preparing body
 string memory body = prepareBody(
 attestationType,
 sourceId,
 requestBody
 );

 console.log(
 ""headers: %s"",
 string.concat(""{"", headers[0], "", "", headers[1]),
 ""}\n""
 );
 console.log(""body: %s\n"", body);
 return (headers, body);
}

function prepareHeaders(
 string memory apiKey
) internal pure returns (string[] memory) {
 string[] memory headers = new string[](2);
 headers[0] = string.concat('""X-API-KEY"": ', apiKey);
 headers[1] = '""Content-Type"": ""application/json""';
 return headers;
}

function prepareBody(
 string memory attestationType,
 string memory sourceId,
 string memory body
) internal pure returns (string memory) {
 return
 string.concat(
 '{""attestationType"": ',
 '""',
 attestationType,
 '""',
 ', ""sourceId"": ',
 '""',
 sourceId,
 '""',
 ', ""requestBody"": ',
 body,
 ""}""
 );
}

```

In the example repository, these are once again included within the [Base](https://github.com/flare-foundation/flare-foundry-starter/blob/master/script/fdcExample/Base.s.sol) library file.

Thus, the part of the script that prepares the verifier request looks like:

```solidity title=""scrip/fdcExample/AddressValidity.s.sol""
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.25;

import {console} from ""dependencies/forge-std-1.9.5/src/console.sol"";
import {Script} from ""dependencies/forge-std-1.9.5/src/Script.sol"";
import {Base} from ""./Base.s.sol"";
...

string constant attestationTypeName = ""AddressValidity"";
string constant dirPath = ""data/"";

contract PrepareAttestationRequest is Script {
 using Surl for *;

 // Setting request data
 string public addressStr = ""mg9P9f4wr9w7c1sgFeiTC5oMLYXCc2c7hs""; // Id of the Bitcoin address to be validated
 string public baseSourceName = ""btc""; // Part of verifier URL
 string public sourceName = ""testBTC""; // Bitcoin chain ID

 function prepareRequestBody(
 string memory addressStr
 ) private pure returns (string memory) {
 return string.concat('{""addressStr"": ""', addressStr, '""}');
 }

 function run() external {
 // Preparing request data
 string memory attestationType = Base.toUtf8HexString(
 attestationTypeName
 );
 string memory sourceId = Base.toUtf8HexString(sourceName);
 string memory requestBody = prepareRequestBody(addressStr);
 (string[] memory headers, string memory body) = Base
 .prepareAttestationRequest(attestationType, sourceId, requestBody);

 // TODO change key in .env
 // string memory baseUrl = ""https://testnet-verifier-fdc-test.aflabs.org/"";
 string memory baseUrl = vm.envString(""VERIFIER_URL_TESTNET"");
 string memory url = string.concat(
 baseUrl,
 ""verifier/"",
 baseSourceName,
 ""/"",
 attestationTypeName,
 ""/prepareRequest""
 );
 console.log(""url: %s"", url);

 (string[] memory headers, string memory body) = prepareAttestationRequest(attestationType, sourceId, requestBody);

 ...
 }
}

...
```

If you are accessing a different chain, replace the `baseSourceName` with an appropriate value, `doge` or `xrp`.

The code above differs slightly from the [starter example](https://github.com/flare-foundation/flare-foundry-starter).
But, if we remove the ellipses `...` signifying missing code, we can still run the script.

Because of the `console.log` commands it will produce JSON strings that represent valid requests; we can then pass this to the [interactive verifier](https://fdc-verifiers-testnet.flare.network/verifier/btc/api-doc#/AddressValidity/BTCAddressValidityVerifierController_prepareRequest) to check what the response is.

We can run the script by calling the following commands in the console.

```bash
source .env
```

```bash
forge script script/fdcExample/AddressValidity.s.sol:PostRequest --private-key $PRIVATE_KEY --rpc-url $COSTON2_RPC_URL --etherscan-api-key $FLARE_API_KEY --broadcast  --ffi
```

The prerequisite for this is that the `.env` file is not missing the `PRIVATE KEY` and `COSTON2_RPC_URL` values.
The script can also access other chains; that can be achieved by replacing the `--rpc-url` value with `COSTON_RPC_URL`, `FLARE_RPC_URL`, or `SONGBIRD_RPC_URL`.

## Post request to verifier

Before submitting address validation requests to the FDC protocol, we first need to prepare and send them to a verifier server.
This section walks through the request submission process using the `surl` package.
We place `using Surl for *;` at the start of our `PostRequest` contract, and then call its `post` method on the verifier URL.

```solidity title=""scrip/fdcExample/AddressValidity.s.sol""
(, bytes memory data) = url.post(headers, body);
```

We construct the URL by appending to the verifier address `https://fdc-verifiers-testnet.flare.network/` the path `verifier/btc/AddressValidity/prepareRequest`.
We can do so dynamically with the following code.

```solidity title=""scrip/fdcExample/AddressValidity.s.sol""
string memory baseUrl = ""https://fdc-verifiers-testnet.flare.network/"";
string memory url = string.concat(
 baseUrl,
 ""verifier/"",
 baseSourceName,
 ""/"",
 attestationTypeName,
 ""/prepareRequest""
);
console.log(""url: %s"", url);
string memory requestBody = string.concat(
 '{""addressStr"": ""',
 addressStr,
 '""}'
);
```

Lastly, we parse the return data from the verifier server.
Using the Foundry `parseJson` shortcode, and a custom struct `AttestationResponse`, we decode the returned data and extract from it the ABI encoded request.

```solidity title=""scrip/fdcExample/Base.s.sol""
function parseAttestationRequest(
 bytes memory data
) internal pure returns (AttestationResponse memory) {
 string memory dataString = string(data);
 bytes memory dataJson = vm.parseJson(dataString);

 AttestationResponse memory response = abi.decode(
 dataJson,
 (AttestationResponse)
 );

 console.log(""response status: %s\n"", response.status);
 console.log(""response abiEncodedRequest: "");
 console.logBytes(response.abiEncodedRequest);
 console.log(""\n"");

 return response;
}
```

:::info

If everything went right, the `abiEncodedRequest` should look something like this.

```
0x
4164647265737356616c69646974790000000000000000000000000000000000
7465737442544300000000000000000000000000000000000000000000000000
7d2ef938d4ffd2392f588bf46563e07ab885b15fead91c1bb99b16f465b71a68
0000000000000000000000000000000000000000000000000000000000000020
0000000000000000000000000000000000000000000000000000000000000020
0000000000000000000000000000000000000000000000000000000000000022
6d6739503966347772397737633173674665695443356f4d4c59584363326337
6873000000000000000000000000000000000000000000000000000000000000
```

Let's break it down line by line:

- **First line:** `toUtf8HexString(""AddressValidity"")`
- **Second line:** `toUtf8HexString(""testBTC"")`
- **Third line:** message integrity code (MIC), a hash of the whole response salted with a string `""Flare""`, ensures the integrity of the attestation
- **Remaining lines:** ABI encoded `AddressValidity.RequestBody` Solidity struct

:::

What this demonstrates is that, with some effort, the `abiEncodedRequest` can be constructed manually.

## Submit request to FDC

This step transitions from off-chain request preparation to on-chain interaction with the FDC protocol. Now, we submit the validated request to the blockchain using deployed smart contracts.

### Submit request

The entire submission process requires only five key steps:

```solidity title=""script/fdcExample/Base.s.sol""
function submitAttestationRequest(
    bytes memory abiEncodedRequest
) internal {
    uint256 deployerPrivateKey = vm.envUint(""PRIVATE_KEY"");
    vm.startBroadcast(deployerPrivateKey);

    IFdcRequestFeeConfigurations fdcRequestFeeConfigurations = ContractRegistry
        .getFdcRequestFeeConfigurations();
    uint256 requestFee = fdcRequestFeeConfigurations.getRequestFee(
        abiEncodedRequest
    );
    console.log(""request fee: %s\n"", requestFee);
    vm.stopBroadcast();

    vm.startBroadcast(deployerPrivateKey);

    IFdcHub fdcHub = ContractRegistry.getFdcHub();
    console.log(""fcdHub address:"");
    console.log(address(fdcHub));
    console.log(""\n"");

    fdcHub.requestAttestation{value: requestFee}(abiEncodedRequest);
    vm.stopBroadcast();
}
```

### Step-by-Step Breakdown

1.  Load Private Key
    The private key is read from the `.env` file using Foundry's `envUint` function:

```solidity
       uint256 deployerPrivateKey = vm.envUint(""PRIVATE_KEY"");
```

2.  Obtain Request Fee
    We retrieve the required requestFee from the `FdcRequestFeeConfigurations` contract:

```solidity
        IFdcRequestFeeConfigurations fdcRequestFeeConfigurations = ContractRegistry
            .getFdcRequestFeeConfigurations();
        uint256 requestFee = fdcRequestFeeConfigurations.getRequestFee(
            response.abiEncodedRequest
        );

```

    This is done in a separate broadcast to ensure `requestFee` is available before submitting the request.

3. Access `FdcHub` Contract
   Using the `ContractRegistry` library (from `flare-periphery`), we fetch the `FdcHub` contract:

```solidity
   IFdcHub fdcHub = ContractRegistry.getFdcHub();
   console.log(""fcdHub address:"");
   console.log(address(fdcHub));
   console.log(""\n"");
```

4. Submit the Attestation Request
   We send the attestation request with the required fee:

```solidity
 fdcHub.requestAttestation{value: requestFee}(response.abiEncodedRequest);
```

5.  Calculate the Voting Round Number
    To determine the voting round in which the attestation request is processed, we query the `FlareSystemsManager` contract:

```solidity
       // Calculating roundId
       IFlareSystemsManager flareSystemsManager = ContractRegistry
           .getFlareSystemsManager();

       uint32 roundId = flareSystemsManager.getCurrentVotingEpochId();
       console.log(""roundId: %s\n"", Strings.toString(roundId));

```

This can be done within the existing broadcast or in a new one (as done in the demo repository for better code organization).

## Wait for response

We wait for the round to finalize.
This takes no more than 90 seconds.

You can check if the request was submitted successfully on the [AttestationRequests](https://coston2-systems-explorer.flare.rocks/attestation-request) page on the Flare Systems Explorer website.
To check if the round has been finalized, go to [Finalizations](https://coston2-systems-explorer.flare.rocks/finalizations) page.

If you want to learn more about how the FDC protocol works, check [here](/fdc/overview).

## Prepare proof request

We prepare the proof request in a similar manner as in the step Prepare the request, by string concatenation.
We import two new variables from the `.env` file; the URL of a verifier server and the corresponding API key.
note

```solidity title=""scrip/fdcExample/AddressValidity.s.sol""
string memory daLayerUrl = vm.envString(""COSTON2_DA_LAYER_URL"");
string memory apiKey = vm.envString(""X_API_KEY"");
```

Also, by repeatedly using the Foundry shortcode `vm.readLine`, we read the data, saved to a file in the previous step, to variables.

```solidity
string memory votingRoundId = vm.readLine(filePath);
string memory requestBytes = vm.readLine(filePath);
```

The code is as follows.

```solidity title=""scrip/fdcExample/AddressValidity.s.sol""
contract RetrieveDataAndProof is Script {
 using Surl for *;

 function run() external {
    string memory daLayerUrl = vm.envString(""COSTON2_DA_LAYER_URL"");
    string memory apiKey = vm.envString(""X_API_KEY"");

    string memory requestBytes = vm.readLine(
        string.concat(
            dirPath,
            attestationTypeName,
            ""_abiEncodedRequest"",
            "".txt""
        )
    );
    string memory votingRoundId = vm.readLine(
        string.concat(
            dirPath,
            attestationTypeName,
            ""_votingRoundId"",
            "".txt""
        )
    );

    console.log(""votingRoundId: %s\n"", votingRoundId);
    console.log(""requestBytes: %s\n"", requestBytes);

    string[] memory headers = Base.prepareHeaders(apiKey);
    string memory body = string.concat(
        '{""votingRoundId"":',
        votingRoundId,
        ',""requestBytes"":""',
        requestBytes,
        '""}'
    );
    console.log(""body: %s\n"", body);
    console.log(
        ""headers: %s"",
        string.concat(""{"", headers[0], "", "", headers[1]),
        ""}\n""
    );


 ...
 }
}
```

## Post proof request to DA Layer

We post the proof request to a chosen DA Layer provider server also with the same code as we did in the previous step.

```solidity title=""scrip/fdcExample/AddressValidity.s.sol""
string memory url = string.concat(
 daLayerUrl,
 // ""api/v0/fdc/get-proof-round-id-bytes""
 ""api/v1/fdc/proof-by-request-round-raw""
);
console.log(""url: %s\n"", url);

(, bytes memory data) = postAttestationRequest(url, headers, body);
```

Parsing the returned data requires the definition of an auxiliary `struct`.

{/* <!-- TODO rename after renaming --> */}

```solidity title=""scrip/fdcExample/Base.s.sol""
struct ParsableProof {
 bytes32 attestationType;
 bytes32[] proofs;
 bytes responseHex;
}
```

The field `attestationType` holds the UTF8 encoded hex string of the attestation type name, padded to 32 bytes.
Thus, it should match the value of the `attestationType` parameter in the Prepare the request step.
In our case, that value is `0x4164647265737356616c69646974790000000000000000000000000000000000`.

The array `proofs` holds the Merkle proofs of our attestation request.

Lastly, `responseHex` is the ABI encoding of the chosen attestation type response struct.
In this case, it is the `IAddressValidity.Response` struct.
We retrieve this data as follows.

```solidity title=""scrip/fdcExample/AddressValidity.s.sol""
bytes memory dataJson = Base.parseData(data);
ParsableProof memory proof = abi.decode(dataJson, (ParsableProof));

IAddressValidity.Response memory proofResponse = abi.decode(
 proof.responseHex,
 (IAddressValidity.Response)
);
```

## Verify proof

FDC optimizes on-chain storage costs by implementing a hybrid data verification system.
Instead of storing complete datasets on-chain, it stores only Merkle proofs, while maintaining the actual data through trusted off-chain providers.
This approach significantly reduces gas costs while preserving data integrity.

When requested, data providers supply the original data along with its corresponding Merkle proof.
The protocol verifies data authenticity by comparing the provided Merkle proof against the on-chain Merkle root.
A successful match confirms the data's integrity and authenticity within the FDC system.

While data verification is optional if you trust your data provider, FDC ensures transparency by making verification possible at any time.
This capability is crucial for maintaining system integrity and allowing users to independently verify data when needed, particularly in production environments.

FDC provides verification functionality through the `FdcVerification` contract.
To verify address validity, we first format our data using the `IAddressValidity.Proof` struct, which contains both the Merkle proof and the response data.

```solidity title=""scrip/fdcExample/AddressValidity.s.sol""
IAddressValidity.Proof memory _proof = IAddressValidity.Proof(
 proof.proofs,
 proofResponse
);
```

We then access the `FdcVerification` contract through the `ContractRegistry`, and feed it the proof.
If we proof is valid, the function `verifyAddressValidity` will return `true`, otherwise `false`.
As before, we wrap the whole thing into a broadcast environment, using the `PRIVATE_KEY` variable from our `.env` file.

```solidity title=""scrip/fdcExample/AddressValidity.s.sol""
uint256 deployerPrivateKey = vm.envUint(""PRIVATE_KEY"");
vm.startBroadcast(deployerPrivateKey);

bool isValid = ContractRegistry
 .getFdcVerification()
 .verifyAddressValidity(proof);
console.log(""proof is valid: %s\n"", StringsBase.toString(isValid));

vm.stopBroadcast();
```

## Use the data

We will now define a simple contract, that will demonstrate how the data can be used onchain.
The contract will receive an address and proof, and decide if the address is valid.
If the address is valid, the contract will add it to an array of valid addresses.
Otherwise, it will raise an error.

The code for this contract is as follows.

```solidity title=""src/fdcExample/AddressValidity.sol""
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.25;

import {console} from ""dependencies/forge-std-1.9.5/src/console.sol"";
import {Strings} from ""@openzeppelin-contracts/utils/Strings.sol"";
import {ContractRegistry} from ""dependencies/flare-periphery-test-0.0.7/src/coston2/ContractRegistry.sol"";
import {IFdcHub} from ""dependencies/flare-periphery-test-0.0.7/src/coston2/IFdcHub.sol"";
import {IAddressValidity} from ""dependencies/flare-periphery-test-0.0.7/src/coston2/IAddressValidity.sol"";
import {IFdcVerification} from ""dependencies/flare-periphery-test-0.0.7/src/coston2/IFdcVerification.sol"";
import {FdcStrings} from ""src/utils/fdcStrings/AddressValidity.sol"";

struct EventInfo {
 address sender;
 uint256 value;
 bytes data;
}

contract AddressValidity {
 string[] public verifiedAddresses;

 function isAddressValidityProofValid(
 IAddressValidity.Proof calldata transaction
 ) public view returns (bool) {
 // Use the library to get the verifier contract and verify that this transaction was proved by the state connector
 IFdcVerification fdc = ContractRegistry.getFdcVerification();
 console.log(""transaction: %s\n"", FdcStrings.toJsonString(transaction));
 // return true;
 return fdc.verifyAddressValidity(transaction);
 }

 function registerAddress(
 string calldata _addressStr,
 IAddressValidity.Proof calldata _transaction
 ) external {
 // 1. FDC Logic
 // Check that this AddressValidity has indeed been confirmed by the FDC
 require(
 isAddressValidityProofValid(_transaction),
 ""Invalid transaction proof""
 );

 // 2. Business logic
 string provedAddress = _transaction.data.requestBody.addressStr;
 require(
 Strings.equal(provedAddress, _addressStr),
 string.concat(
 ""Invalid address.\n\tProvided: "",
 _addressStr,
 ""\n\tProoved: "",
 provedAddress
 )
 );
 verifiedAddresses.push(provedAddress);
 }
}
```

The function `registerAddress` takes as parameters a string representing an address, and a proof.
If the proof is valid, and if the given address matches the one in the proof, the address is added to an array of verified addresses.

We deploy this contract through a script in `script/AddressValidity.s.sol`.

```solidity title=""scrip/fdcExample/AddressValidity.s.sol""

contract Deploy is Script {
 function run() external {
 uint256 deployerPrivateKey = vm.envUint(""PRIVATE_KEY"");
 vm.startBroadcast(deployerPrivateKey);

 AddressValidity addressValidity = new AddressValidity();

 vm.stopBroadcast();
 }
}
```

We run the above script with the following console command.

```bash
forge script script/fdcExample/AddressValidity.s.sol:Deploy --private-key $PRIVATE_KEY --rpc-url $COSTON2_RPC_URL --etherscan-api-key $FLARE_API_KEY --broadcast --ffi

```",2025-03-08 01:27:14
evm-connectivity.mdx,"title: EVM Connectivity
slug: evm-connectivity
authors: [lukaavbreht, filipkoprivec]
description: Learn how to connect EVM chains to Flare using FDC.
tags: [intermediate, ethereum, fdc]
keywords: [ethereum, flare-data-connector, evm, flare-network]
sidebar_position: 8
unlisted: true","In [Part 1](/fdc/getting-started) and [Part 2](/fdc/attestation-types) of the series, you you have learned how the Data Connector works and what kind of different attestations you can get from it. In this guide, you will:

- Move from the world of UTXO chains to the world of EVM chains with a new `EVMTransaction` attestation type.
- Understand the implications of connecting account-based chains, and the additional possibilities that smart contracts bring.
- Connect Ethereum and Flare (or testnets Sepolia and Flare Testnet Coston2 for the Coston testnet).

From Parts 1 and 2, the attestations that you know so far are:

- Simple payment

- Non-existence of a payment with reference

- Balance decreasing transaction

- Block height confirmation

- Address validity check

You also know that the Data Connector allows Flare to connect to Bitcoin, Dogecoin, and XRP Ledger.

The information that the Data Connector provides is similar to what was provided before (sender and recipient, amount, block, timestamp, etc.), but since you are on a smart contract compatible chain now, you can also get additional things, namely, you can extract the full data about events that were emitted during the transaction, and you can also get the input data of the transaction (in case a contract was called).

## Transaction Type

Let's jump directly into the transaction type to see what kind of data we need to provide.

The top-level `Request` in the `EVMTransaction` has the same structure as others:

```solidity title=""EVMTransaction.sol""
// SPDX-License-Identifier: MIT
pragma solidity >=0.7.6 <0.9;

/**
 * @custom:name EVMTransaction
 * @custom:id 0x06
 * @custom:supported ETH, FLR, SGB, testETH, testFLR, testSGB
 * @author Flare
 * @notice A relay of a transaction from an EVM chain.
 * This type is only relevant for EVM-compatible chains.
 * @custom:verification If a transaction with the `transactionId` is in a block on the main branch with at least `requiredConfirmations`, the specified data is relayed.
 * If an indicated event does not exist, the request is rejected.
 * @custom:lut `timestamp`
 */
interface EVMTransaction {
    /**
     * @notice Toplevel request
     * @param attestationType ID of the attestation type.
     * @param sourceId  ID of the data source.
     * @param messageIntegrityCode `MessageIntegrityCode` that is derived from the expected response.
     * @param requestBody Data defining the request. Type (struct) and interpretation is determined by the `attestationType`.
     */
    struct Request {
        bytes32 attestationType;
        bytes32 sourceId;
        bytes32 messageIntegrityCode;
        RequestBody requestBody;
    }

    /**
     * @notice Toplevel response
     * @param attestationType Extracted from the request.
     * @param sourceId Extracted from the request.
     * @param votingRound The ID of the Data Connector round in which the request was considered.
     * @param lowestUsedTimestamp The lowest timestamp used to generate the response.
     * @param requestBody Extracted from the request.
     * @param responseBody Data defining the response. The verification rules for the construction of the response body and the type are defined per specific `attestationType`.
     */
    struct Response {
        bytes32 attestationType;
        bytes32 sourceId;
        uint64 votingRound;
        uint64 lowestUsedTimestamp;
        RequestBody requestBody;
        ResponseBody responseBody;
    }

    /**
     * @notice Toplevel proof
     * @param merkleProof Merkle proof corresponding to the attestation response.
     * @param data Attestation response.
     */
    struct Proof {
        bytes32[] merkleProof;
        Response data;
    }

    /**
     * @notice Request body for EVM transaction attestation type
     * @custom:below Note that events (logs) are indexed in block not in each transaction. The contract that uses the attestation should specify the order of event logs as needed and the requestor should sort `logIndices`
     * with respect to the set specifications. If possible, the contact should only require one `logIndex`.
     * @param transactionHash Hash of the transaction(transactionHash).
     * @param requiredConfirmations The height at which a block is considered confirmed by the requestor.
     * @param provideInput If true, ""input"" field is included in the response.
     * @param listEvents If true, events indicated by `logIndices` are included in the response. Otherwise, no events are included in the response.
     * @param logIndices If `listEvents` is `false`, this should be an empty list, otherwise, the request is rejected. If `listEvents` is `true`, this is the list of indices (logIndex) of the events to be relayed (sorted by the requestor). The array should contain at most 50 indices. If empty, it indicates all events in order capped by 50.
     */
    struct RequestBody {
        bytes32 transactionHash;
        uint16 requiredConfirmations;
        bool provideInput;
        bool listEvents;
        uint32[] logIndices;
    }

    /**
     * @notice Response body for EVM transaction attestation type
     * @custom:below The fields are in line with [transaction](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_gettransactionbyhash) provided by EVM node.
     * @param blockNumber Number of the block in which the transaction is included.
     * @param timestamp Timestamp of the block in which the transaction is included.
     * @param sourceAddress The address (from) that signed the transaction.
     * @param isDeployment Indicate whether it is a contract creation transaction.
     * @param receivingAddress The address (to) of the receiver of the initial transaction. Zero address if `isDeployment` is `true`.
     * @param value The value transferred by the initial transaction in wei.
     * @param input If `provideInput`, this is the data send along with the initial transaction. Otherwise it is the default value `0x00`.
     * @param status Status of the transaction 1 - success, 0 - failure.
     * @param events If `listEvents` is `true`, an array of the requested events. Sorted by the logIndex in the same order as `logIndices`. Otherwise, an empty array.
     */
    struct ResponseBody {
        uint64 blockNumber;
        uint64 timestamp;
        address sourceAddress;
        bool isDeployment;
        address receivingAddress;
        uint256 value;
        bytes input;
        uint8 status;
        Event[] events;
    }

    /**
     * @notice Event log record
     * @custom:above An `Event` is a struct with the following fields:
     * @custom:below The fields are in line with [EVM event logs](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getfilterchanges).
     * @param logIndex The consecutive number of the event in block.
     * @param emitterAddress The address of the contract that emitted the event.
     * @param topics An array of up to four 32-byte strings of indexed log arguments.
     * @param data Concatenated 32-byte strings of non-indexed log arguments. At least 32 bytes long.
     * @param removed It is `true` if the log was removed due to a chain reorganization and `false` if it is a valid log.
     */
    struct Event {
        uint32 logIndex;
        address emitterAddress;
        bytes32[] topics;
        bytes data;
        bool removed;
    }
}
```

The `attestationType` for the evm attestation is a hex encoding of `hexEncode(""EVMTransaction"")`

{/* Currently supported `sourceId` are */}

{/* - TODO: Na≈°tej jih in prveri, da delajo ok */}

## Request Body

The `RequestBody` is defined as:

```solidity
    /**
     * @notice Request body for EVM transaction attestation type
     * @custom:below Note that events (logs) are indexed in block not in each transaction. The contract that uses the attestation should specify the order of event logs as needed and the requestor should sort `logIndices`
     * with respect to the set specifications. If possible, the contact should only require one `logIndex`.
     * @param transactionHash Hash of the transaction(transactionHash).
     * @param requiredConfirmations The height at which a block is considered confirmed by the requestor.
     * @param provideInput If true, ""input"" field is included in the response.
     * @param listEvents If true, events indicated by `logIndices` are included in the response. Otherwise, no events are included in the response.
     * @param logIndices If `listEvents` is `false`, this should be an empty list, otherwise, the request is rejected. If `listEvents` is `true`, this is the list of indices (logIndex) of the events to be relayed (sorted by the requestor). The array should contain at most 50 indices. If empty, it indicates all events in order capped by 50.
     */
    struct RequestBody {
        bytes32 transactionHash;
        uint16 requiredConfirmations;
        bool provideInput;
        bool listEvents;
        uint32[] logIndices;
    }
```

- `TransactionHash`: Hash of the transaction you are observing.

- `RequiredConfirmations`: The number of blocks after the transaction that you are requesting must be visible to the attestation client to consider this transaction as finalized. Unlike the previous payment (or block height) attestation, where the amount of block confirmations was set per chain, this type is more flexible and allows you to choose how many confirmations you want, thus adapting your security assumptions (about the other chain).

- `provideInput`: Indicates if the response should also contain the input of the transaction. You can always include the input, but this might produce a large data structure that you will need to supply when using this transaction. If you don't need this data, it is advisable not to include it to avoid additional gas costs both for supplying it to the verification contract and making a transaction. However, it might be useful, for example, to check what contract was deployed or what was the top-level method that was executed.

- `listEvents`: Events are an important and powerful tool when interacting with EVM chains, but including them adds additional costs (the same as with input). If you don't need events, you can save some gas costs by excluding them.

- `logIndices`: An array of log indices (in any order, with repetitions allowed) for which events (logs) you want included as the result of your transaction attestation. As before, don't include events you don't need for gas reasons. Importantly, leaving this array empty will include all events emitted in the same order as they were emitted. The indices are the block log indices, indicating the event index in the whole block (not just the transactions you are attesting to), but if you supply an index outside your transaction range, the corresponding event won't be included. The amount of returned events is limited to 50, so if you want to attest that you have included all the events in a single transaction, make sure it has 49 of them or less.

{/* (<!--TODO: link do definicije tega-->) */}

## Response Body

The `ResponseBody` is defined as:

```solidity
    /**
     * @notice Response body for EVM transaction attestation type
     * @custom:below The fields are in line with [transaction](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_gettransactionbyhash) provided by EVM node.
     * @param blockNumber Number of the block in which the transaction is included.
     * @param timestamp Timestamp of the block in which the transaction is included.
     * @param sourceAddress The address (from) that signed the transaction.
     * @param isDeployment Indicate whether it is a contract creation transaction.
     * @param receivingAddress The address (to) of the receiver of the initial transaction. Zero address if `isDeployment` is `true`.
     * @param value The value transferred by the initial transaction in wei.
     * @param input If `provideInput`, this is the data send along with the initial transaction. Otherwise it is the default value `0x00`.
     * @param status Status of the transaction 1 - success, 0 - failure.
     * @param events If `listEvents` is `true`, an array of the requested events. Sorted by the logIndex in the same order as `logIndices`. Otherwise, an empty array.
     */
    struct ResponseBody {
        uint64 blockNumber;
        uint64 timestamp;
        address sourceAddress;
        bool isDeployment;
        address receivingAddress;
        uint256 value;
        bytes input;
        uint8 status;
        Event[] events;
    }

    /**
     * @notice Event log record
     * @custom:above An `Event` is a struct with the following fields:
     * @custom:below The fields are in line with [EVM event logs](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getfilterchanges).
     * @param logIndex The consecutive number of the event in block.
     * @param emitterAddress The address of the contract that emitted the event.
     * @param topics An array of up to four 32-byte strings of indexed log arguments.
     * @param data Concatenated 32-byte strings of non-indexed log arguments. At least 32 bytes long.
     * @param removed It is `true` if the log was removed due to a chain reorganization and `false` if it is a valid log.
     */
    struct Event {
        uint32 logIndex;
        address emitterAddress;
        bytes32[] topics;
        bytes data;
        bool removed;
    }
```

The response body struct contains the following fields:

- `blockNumber`: Number of the block in which the transaction is included.

- `timestamp`: Timestamp of the block the transaction was included in.

- `sourceAddress`: Address signing the transaction. Since Flare is an EVM chain, this is nicely mapped to the address type directly, and you don't have to operate with strings or address hashes.

- `isDeployment`: Flag indicating if this transaction was a contract deployment.

- `receivingAddress`: The `to` address of the transaction (this is a zero address if you are dealing with contract deployment). Keep in mind, this can also be a contract address (if the toplevel transaction is a contract call) and this is where things get interesting.

- `value`: The value (in wei) transferred by the toplevel transaction. Values transferred by internal transactions are not tracked by this type, but if proper events are emitted you can use them to follow this. If there is no value, the value has a default `0` value.

- `input`: The input provided with a transaction (useful for contract calls). If no input is provided, a default value of zero bytes is used.

- `status`: The status of the transaction, which can either be `1` indicating success or `0` indicating failure (without failure reason).

- `events`: Array of requested events in the same order as requested.

Each event has the following fields:

- `logIndex`: The consecutive number of the event in the block.

- `emitterAddress`: The address of the contract that emitted the event.

- `topics`: An array of up to four 32-byte strings of indexed log arguments.

- `data`: Concatenated 32-byte strings of non-indexed log arguments. This (together with topics) is usually the part of an event that you will decode to get the information you need. Keep in mind, this is event-specific and you will need to know the event structure to decode it properly.

- `removed`: It is `true` if the log was removed due to a chain reorganization (transaction was mined, but the block was not on the main chain) and `false` if it is a valid log.

## Examples

Now that you know how to request an attestation and what you are getting in return, let's explore some examples. These examples are a bit more involved and each will come in a few parts:

- Script making a dummy transaction on the `Sepolia` testnet.
- Smart contract(s) accepting an attestation request and performing some desired action.
- Deployment and run script that ties them together.

This deployment script will also allow you to understand exactly how long the waiting for each phase takes, which is something not previously focused on.

### Simple transaction with a value

Let's start small. You will create a smart contract that just tallies the top-level amounts transferred to a designated address on Sepolia.

The scenario is pretty simple:

- You have a ""payment"" to an Externally Owned Account (EOA - so not a smart contract) on Sepolia, and anyone can send funds there and prove this.
- On the Flare side, you will deploy a contract that will accept proofs with data in the proper accounting format: who has sent how much to this end owner address.

The full code for this example is in the `scripts/evm/trySimpleTransaction.ts`, `contracts/EthereumPaymentCollector.sol`, and `contracts/FallbackContract` files.

You won't be copy-pasting the full code here, but you will go through the most important parts.

The setup is now in two parts, and `main` correctly picks up the right part to run depending on the network it is run on.

First, deploy a simple `FallbackContract` on Sepolia.

```bash
yarn hardhat run scripts/evm/trySimpleTransaction --network sepolia
```

- This contract will just emit an event when the `fallback` function is called.
- You will be attesting to this event in the next part.
- The script makes two transactions on Sepolia: one with value to an address and one to the address of the contract.
- The second transaction will call the `fallback` function and emit the event.
- The transaction hashes are logged, and the JSON response of the attestation results is printed (so you can see what you will get in the next part).

Here is an example result:

```bash
0xac640ab047aa1097ddd473e5940921eb500a9912b33072b8532617692428830e
{
  ""status"": ""VALID"",
  ""response"": {
    ""attestationType"": ""0x45564d5472616e73616374696f6e000000000000000000000000000000000000"",
    ""sourceId"": ""0x7465737445544800000000000000000000000000000000000000000000000000"",
    ""votingRound"": ""0"",
    ""lowestUsedTimestamp"": ""1708907688"",
    ""requestBody"": {
      ""transactionHash"": ""0xac640ab047aa1097ddd473e5940921eb500a9912b33072b8532617692428830e"",
      ""requiredConfirmations"": ""1"",
      ""provideInput"": true,
      ""listEvents"": true,
      ""logIndices"": []
    },
    ""responseBody"": {
      ""blockNumber"": ""5363670"",
      ""timestamp"": ""1708907688"",
      ""sourceAddress"": ""0x4C3dFaFc3207Eabb7dc8A6ab01Eb142C8655F373"",
      ""isDeployment"": false,
      ""receivingAddress"": ""0xFf02F742106B8a25C26e65C1f0d66BEC3C90d429"",
      ""value"": ""10"",
      ""input"": ""0x0123456789"",
      ""status"": ""1"",
      ""events"": []
    }
  }
}
0x7eb54cde238fc700be31c98af7e4df8c4fc96fd5c634c490183ca612a481efcc
{
  ""status"": ""VALID"",
  ""response"": {
    ""attestationType"": ""0x45564d5472616e73616374696f6e000000000000000000000000000000000000"",
    ""sourceId"": ""0x7465737445544800000000000000000000000000000000000000000000000000"",
    ""votingRound"": ""0"",
    ""lowestUsedTimestamp"": ""1708907712"",
    ""requestBody"": {
      ""transactionHash"": ""0x7eb54cde238fc700be31c98af7e4df8c4fc96fd5c634c490183ca612a481efcc"",
      ""requiredConfirmations"": ""1"",
      ""provideInput"": true,
      ""listEvents"": true,
      ""logIndices"": []
    },
    ""responseBody"": {
      ""blockNumber"": ""5363672"",
      ""timestamp"": ""1708907712"",
      ""sourceAddress"": ""0x4C3dFaFc3207Eabb7dc8A6ab01Eb142C8655F373"",
      ""isDeployment"": false,
      ""receivingAddress"": ""0xeBBf567beDe2D8842dF538Cf64E0bE9976183853"",
      ""value"": ""10"",
      ""input"": ""0x9876543210"",
      ""status"": ""1"",
      ""events"": [
        {
          ""logIndex"": ""160"",
          ""emitterAddress"": ""0xeBBf567beDe2D8842dF538Cf64E0bE9976183853"",
          ""topics"": [
            ""0xaca09dd456ca888dccf8cc966e382e6e3042bb7e4d2d7815015f844edeafce42""
          ],
          ""data"": ""0x0000000000000000000000004c3dfafc3207eabb7dc8a6ab01eb142c8655f373000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000059876543210000000000000000000000000000000000000000000000000000000"",
          ""removed"": false
        }
      ]
    }
  }
}
```

After you have the transaction hashes, copy them to the part of the `main` method that will execute the Data Connector part, this time on Coston. Let's take a look at `executeStateConnectorProof`.

Here, the Data Connector part comes into play. You have already seen it in the previous guides, so you will just quickly scan through it. The code is a bit more involved, as you are now working with multiple transactions (this is not EVMTransaction specific, but it is a good example of how you can use the Data Connector to do more complex things). Again, you get an encoded attestation request (one for each transaction) and then you submit them to the Data Connector. Once this is done, you wait for the round to be confirmed (see the while loop that takes most of the time) and then you get the proof.

The `EthereumPaymentCollector` contract is deployed on Coston with one important method `collectPayment`. This method accepts the `EVMTransaction.Proof` response and does the important accounting.

As usual, first check that the provided proof is correct: that the Merkle proof really attests that this transaction was included in the Merkle tree.

Then comes the fun part - you can use the information from a transaction to do whatever you want. You won't just write it to the list of all transactions and be done. Instead, you will try to decode the event data and see what you can get from it. As mentioned before, the event data is specific to the event and you need to know the event structure to decode it properly. In this case, you know how it looks, and the decoding is done by the built-in `abi.decode`. You then just push the decoded data in struct form to the list of events and you are done.

:::warning

`abi.decode` is not type-safe and you can easily get wrong results if you don't know the event structure. Even more, this might be a security risk if you are not careful (or revert unexpectedly), but it is a nice representation of how powerful the events - and their information - can be.

:::

Finally, when you have both proofs and the contract deployed, you just call the `collectPayment` method with the proofs, and you are done (unless something goes wrong, then you will have to wait for the next round and try again).

The result looks something like:

```bash
Rounds:  [ '809307', '809307' ]
Waiting for the round to be confirmed 809303n 809307
Waiting for the round to be confirmed 809303n 809307
Waiting for the round to be confirmed 809303n 809307
Waiting for the round to be confirmed 809304n 809307
Waiting for the round to be confirmed 809304n 809307
Waiting for the round to be confirmed 809304n 809307
Waiting for the round to be confirmed 809304n 809307
Waiting for the round to be confirmed 809304n 809307
Waiting for the round to be confirmed 809305n 809307
Waiting for the round to be confirmed 809305n 809307
Waiting for the round to be confirmed 809305n 809307
Waiting for the round to be confirmed 809305n 809307
Waiting for the round to be confirmed 809306n 809307
Waiting for the round to be confirmed 809306n 809307
Waiting for the round to be confirmed 809306n 809307
Waiting for the round to be confirmed 809306n 809307
Waiting for the round to be confirmed 809306n 809307
Round confirmed, getting proof
Successfully submitted source code for contract
contracts/EthereumPaymentCollector.sol:EthereumPaymentCollector at 0x7cf6E7aeFD0207a5bE9a7DbcDA560fc7a6dBD7B4
for verification on the block explorer. Waiting for verification result...

Successfully verified contract EthereumPaymentCollector on the block explorer.
https://coston-explorer.flare.network/address/0x7cf6E7aeFD0207a5bE9a7DbcDA560fc7a6dBD7B4#code

{
  ""data"": {
    ""attestationType"": ""0x45564d5472616e73616374696f6e000000000000000000000000000000000000"",
    ""lowestUsedTimestamp"": ""1708907688"",
    ""requestBody"": {
      ""listEvents"": true,
      ""logIndices"": [],
      ""provideInput"": true,
      ""requiredConfirmations"": ""1"",
      ""transactionHash"": ""0xac640ab047aa1097ddd473e5940921eb500a9912b33072b8532617692428830e""
    },
    ""responseBody"": {
      ""blockNumber"": ""5363670"",
      ""events"": [],
      ""input"": ""0x0123456789"",
      ""isDeployment"": false,
      ""receivingAddress"": ""0xFf02F742106B8a25C26e65C1f0d66BEC3C90d429"",
      ""sourceAddress"": ""0x4C3dFaFc3207Eabb7dc8A6ab01Eb142C8655F373"",
      ""status"": ""1"",
      ""timestamp"": ""1708907688"",
      ""value"": ""10""
    },
    ""sourceId"": ""0x7465737445544800000000000000000000000000000000000000000000000000"",
    ""votingRound"": ""809307""
  },
  ""merkleProof"": [
    ""0x56faf895bbcb0b2a6f3bc283ea5e1793b224dca8b4b99240a34cee6d9bf1b8f3"",
    ""0x13ef0de709e7b0485f7623f5a0ad5b56aa23626fbffe5e7f4502bb7be5e0bf7e"",
    ""0xf72c31824174676516a9c5d9713cb1ae8866cac71462fe2b1a3c1e1b9418a94f""
  ]
}
{
  ""data"": {
    ""attestationType"": ""0x45564d5472616e73616374696f6e000000000000000000000000000000000000"",
    ""lowestUsedTimestamp"": ""1708907712"",
    ""requestBody"": {
      ""listEvents"": true,
      ""logIndices"": [],
      ""provideInput"": true,
      ""requiredConfirmations"": ""1"",
      ""transactionHash"": ""0x7eb54cde238fc700be31c98af7e4df8c4fc96fd5c634c490183ca612a481efcc""
    },
    ""responseBody"": {
      ""blockNumber"": ""5363672"",
      ""events"": [
        {
          ""data"": ""0x0000000000000000000000004c3dfafc3207eabb7dc8a6ab01eb142c8655f373000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000059876543210000000000000000000000000000000000000000000000000000000"",
          ""emitterAddress"": ""0xeBBf567beDe2D8842dF538Cf64E0bE9976183853"",
          ""logIndex"": ""160"",
          ""removed"": false,
          ""topics"": [
            ""0xaca09dd456ca888dccf8cc966e382e6e3042bb7e4d2d7815015f844edeafce42""
          ]
        }
      ],
      ""input"": ""0x9876543210"",
      ""isDeployment"": false,
      ""receivingAddress"": ""0xeBBf567beDe2D8842dF538Cf64E0bE9976183853"",
      ""sourceAddress"": ""0x4C3dFaFc3207Eabb7dc8A6ab01Eb142C8655F373"",
      ""status"": ""1"",
      ""timestamp"": ""1708907712"",
      ""value"": ""10""
    },
    ""sourceId"": ""0x7465737445544800000000000000000000000000000000000000000000000000"",
    ""votingRound"": ""809307""
  },
  ""merkleProof"": [
    ""0x8e45d2d564bf7d652cf904a72e53f5e7e34d7e5e184906afda92f755e99cd421"",
    ""0x13ef0de709e7b0485f7623f5a0ad5b56aa23626fbffe5e7f4502bb7be5e0bf7e"",
    ""0xf72c31824174676516a9c5d9713cb1ae8866cac71462fe2b1a3c1e1b9418a94f""
  ]
}
```

:::info

On the previous attestation types, we were only able to get transactions in the last two days (this is attestation type specific).

:::

### Decoding emitted events

As previously stated, an event will be the core feature for observing what is happening on other chains. Let's now use this to prove that an ERC20 payment was made on Sepolia and then decode the event to see who made the payment and how much.

As before, you will deploy an ERC20 contract on Sepolia, mint some tokens, and send them to an address. The full code is available in the `scripts/evm/tryERC20transfers.ts` and `contracts/MintableERC20.sol` files.

A sample response for the ERC20 transaction would look like:

```bash
Sepolia USDT deployed to: 0x6023e19d70C304eA16a3728ceDcb042791737EC3
0xd7eed8cf377a4079718e8d709b3648d62a3a16ea39fbfbe759600c3d574caa15
{
  ""status"": ""VALID"",
  ""response"": {
    ""attestationType"": ""0x45564d5472616e73616374696f6e000000000000000000000000000000000000"",
    ""sourceId"": ""0x7465737445544800000000000000000000000000000000000000000000000000"",
    ""votingRound"": ""0"",
    ""lowestUsedTimestamp"": ""1708999068"",
    ""requestBody"": {
      ""transactionHash"": ""0xd7eed8cf377a4079718e8d709b3648d62a3a16ea39fbfbe759600c3d574caa15"",
      ""requiredConfirmations"": ""1"",
      ""provideInput"": true,
      ""listEvents"": true,
      ""logIndices"": []
    },
    ""responseBody"": {
      ""blockNumber"": ""5370899"",
      ""timestamp"": ""1708999068"",
      ""sourceAddress"": ""0x4C3dFaFc3207Eabb7dc8A6ab01Eb142C8655F373"",
      ""isDeployment"": false,
      ""receivingAddress"": ""0x6023e19d70C304eA16a3728ceDcb042791737EC3"",
      ""value"": ""0"",
      ""input"": ""0x40c10f190000000000000000000000004c3dfafc3207eabb7dc8a6ab01eb142c8655f37300000000000000000000000000000000000000000000000000000000000f4240"",
      ""status"": ""1"",
      ""events"": [
        {
          ""logIndex"": ""38"",
          ""emitterAddress"": ""0x6023e19d70C304eA16a3728ceDcb042791737EC3"",
          ""topics"": [
            ""0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef"",
            ""0x0000000000000000000000000000000000000000000000000000000000000000"",
            ""0x0000000000000000000000004c3dfafc3207eabb7dc8a6ab01eb142c8655f373""
          ],
          ""data"": ""0x00000000000000000000000000000000000000000000000000000000000f4240"",
          ""removed"": false
        }
      ]
    }
  }
}
0x9dffa80b6daea45ed4bfc93bb72cdb893549fdefb81cb760b7ce08edef9859a6
{
  ""status"": ""VALID"",
  ""response"": {
    ""attestationType"": ""0x45564d5472616e73616374696f6e000000000000000000000000000000000000"",
    ""sourceId"": ""0x7465737445544800000000000000000000000000000000000000000000000000"",
    ""votingRound"": ""0"",
    ""lowestUsedTimestamp"": ""1708999080"",
    ""requestBody"": {
      ""transactionHash"": ""0x9dffa80b6daea45ed4bfc93bb72cdb893549fdefb81cb760b7ce08edef9859a6"",
      ""requiredConfirmations"": ""1"",
      ""provideInput"": true,
      ""listEvents"": true,
      ""logIndices"": []
    },
    ""responseBody"": {
      ""blockNumber"": ""5370900"",
      ""timestamp"": ""1708999080"",
      ""sourceAddress"": ""0x4C3dFaFc3207Eabb7dc8A6ab01Eb142C8655F373"",
      ""isDeployment"": false,
      ""receivingAddress"": ""0x6023e19d70C304eA16a3728ceDcb042791737EC3"",
      ""value"": ""0"",
      ""input"": ""0xa9059cbb000000000000000000000000ff02f742106b8a25c26e65c1f0d66bec3c90d42900000000000000000000000000000000000000000000000000000000000003e8"",
      ""status"": ""1"",
      ""events"": [
        {
          ""logIndex"": ""32"",
          ""emitterAddress"": ""0x6023e19d70C304eA16a3728ceDcb042791737EC3"",
          ""topics"": [
            ""0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef"",
            ""0x0000000000000000000000004c3dfafc3207eabb7dc8a6ab01eb142c8655f373"",
            ""0x000000000000000000000000ff02f742106b8a25c26e65c1f0d66bec3c90d429""
          ],
          ""data"": ""0x00000000000000000000000000000000000000000000000000000000000003e8"",
          ""removed"": false
        }
      ]
    }
  }
}
```

Let's now decode the data you got back and explore the event in a little more detail.

```json
{
  ""logIndex"": ""38"",
  ""emitterAddress"": ""0x6023e19d70C304eA16a3728ceDcb042791737EC3"",
  ""topics"": [
    ""0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef"",
    ""0x0000000000000000000000000000000000000000000000000000000000000000"",
    ""0x0000000000000000000000004c3dfafc3207eabb7dc8a6ab01eb142c8655f373""
  ],
  ""data"": ""0x00000000000000000000000000000000000000000000000000000000000f4240"",
  ""removed"": false
}
{
  ""logIndex"": ""32"",
  ""emitterAddress"": ""0x6023e19d70C304eA16a3728ceDcb042791737EC3"",
  ""topics"": [
    ""0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef"",
    ""0x0000000000000000000000004c3dfafc3207eabb7dc8a6ab01eb142c8655f373"",
    ""0x000000000000000000000000ff02f742106b8a25c26e65c1f0d66bec3c90d429""
  ],
  ""data"": ""0x00000000000000000000000000000000000000000000000000000000000003e8"",
  ""removed"": false
}
```

When processing the events, it is important to know which contract should be emitting the event (you don't want to count a memecoin transfer as a USDT transfer). The `topics` are the indexed arguments of the event, and the `data` is the non-indexed arguments. This was glossed over in the first part, but now it will be important.

If you take a look at the event definition:

```solidity
event Transfer(address indexed from, address indexed to, uint256 value);
```

You see that it has three arguments, two indexed and one non-indexed. However, there are three topics in the event. How do we interpret that? In our case, the first one is the event signature, and the other two are the indexed arguments. Importantly, that is not always the case (it is the case for events that are emitted by Solidity contracts, but not necessarily for other contracts or direct assembly code).

Let's now decode the event data. The second event has the following data:

```json
""topics"": [
    ""0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef"",
    ""0x0000000000000000000000004c3dfafc3207eabb7dc8a6ab01eb142c8655f373"",
    ""0x000000000000000000000000ff02f742106b8a25c26e65c1f0d66bec3c90d429""
]
```

The first topic is the [event signature](https://www.4byte.directory/event-signatures/?bytes_signature=0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef), and the other two are the from and to addresses. You can easily see how they are zero-padded to accommodate the whole 32 bytes.

Similarly, the event in the first transaction that just minted 1,000,000 token wei (hex encoded in the data field) has the same zeroth topic, same recipient (topic with index 2), and zero address as the sender.

{/* <!-- This is good for future examples, but too time consuming to do now --><!-- #### ERC20 payment --> */}

Let's upgrade the contract from before to tally ERC20 payments on external chains. You can do this by listening to events, decoding them, and using the decoded information.

{/* TODO: Here, we will create a simple contract on Sepolia and follow the events it emits, just to see another example of how events function. --> */}

### Decoding top-level transaction data

You now know how to listen to events and decode them. Let's see how we can also decode top-level transaction data. Here, you will verify whether the top-level transaction really did increase the ERC20 allowance and see how to get top-level calldata.

The full code for this example is in the `scripts/evm/tryERC20Allowance.ts` and `contracts/MintableERC20.sol` files.

You initiate a simple `allowance` increase on Sepolia and then decode the calldata to see if it is really what you expect. The example response is something like this:

```json
{
  ""status"": ""VALID"",
  ""response"": {
    ""attestationType"": ""0x45564d5472616e73616374696f6e000000000000000000000000000000000000"",
    ""sourceId"": ""0x7465737445544800000000000000000000000000000000000000000000000000"",
    ""votingRound"": ""0"",
    ""lowestUsedTimestamp"": ""1709147568"",
    ""requestBody"": {
      ""transactionHash"": ""0x445ac68dd09198cb3b8202cb9ccba323d4d1c82157a076f97fd6682dfaa826d9"",
      ""requiredConfirmations"": ""1"",
      ""provideInput"": true,
      ""listEvents"": true,
      ""logIndices"": []
    },
    ""responseBody"": {
      ""blockNumber"": ""5382600"",
      ""timestamp"": ""1709147568"",
      ""sourceAddress"": ""0x4C3dFaFc3207Eabb7dc8A6ab01Eb142C8655F373"",
      ""isDeployment"": false,
      ""receivingAddress"": ""0xc14FA393fa7248c73B74A303cf35D5e980E11e2C"",
      ""value"": ""0"",
      ""input"": ""0x095ea7b3000000000000000000000000ff02f742106b8a25c26e65c1f0d66bec3c90d42900000000000000000000000000000000000000000000000000000000000003e8"",
      ""status"": ""1"",
      ""events"": [
        {
          ""logIndex"": ""54"",
          ""emitterAddress"": ""0xc14FA393fa7248c73B74A303cf35D5e980E11e2C"",
          ""topics"": [
            ""0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925"",
            ""0x0000000000000000000000004c3dfafc3207eabb7dc8a6ab01eb142c8655f373"",
            ""0x000000000000000000000000ff02f742106b8a25c26e65c1f0d66bec3c90d429""
          ],
          ""data"": ""0x00000000000000000000000000000000000000000000000000000000000003e8"",
          ""removed"": false
        }
      ]
    }
  }
}
Result(2) [ '0xFf02F742106B8a25C26e65C1f0d66BEC3C90d429', 1000n ]
```

By now, you should be able to see that the emitted event was the `Approval` event, and the data is the new allowance (with the correct participant addresses in the topics).

What we want to take a look at is the `input` field. It contains the calldata of the top-level transaction. Since you know the signature of this method, you can easily decode it and get the result you expect.

### Observing State Through Events

We do not have direct access to state on the other chain, but we can circumvent this using events. If we deploy a contract on the external chain that emits events pertaining to the state it can read (at that block) from the chain, we can easily observe this state (frozen at that point in time) on Flare. Let's see how we can easily observe the current status of ERC20 allowance.

The full code for this example is in the `scripts/evm/tryStateChecking.ts` and `contracts/FallbackWithEventContract.sol` files.

The contract is simple:

```solidity
function getState(address target, bytes calldata cdata) external payable {
      // Just forward the call to the contract we want to interact with
      // Caution - this is very unsafe, as the calldata can be anything
      // If this contract were to had some tokens for example, the calldata could be used to transfer them.
      (bool result, bytes memory returnData) = target.call{value: msg.value}(cdata);
      emit CallResult(target, result, msg.data, returnData);
      // A bit safer way would be to only allow specific functions to be called or use something like this: https://github.com/gnosis/util-contracts/blob/main/contracts/storage/StorageAccessible.sol
  }
```

Any call to this contract will be forwarded to the target contract, and the result will be emitted as an event.

The script is also relatively simple (though it does a lot of things).

We get the event in the same way as before, but now we also get the calldata and the target address. We need to do two things: First, decode the event to see what happened, and then decode the calldata to see what the state is. Then, decode both data bytes to see what we got. Importantly, it is necessary to know the structure of the event and the method we called to properly decode it.

The response is something like this:

```bash
Sepolia USDT deployed to: 0xf274cCf1f92F9B34FF5704802a9B690E1d3cbC38
FallbackWithEventContract deployed to: 0xfCcB55F281df58869593B64B48f8c2Fe66f91C5D
{
  ""status"": ""VALID"",
  ""response"": {
    ""attestationType"": ""0x45564d5472616e73616374696f6e000000000000000000000000000000000000"",
    ""sourceId"": ""0x7465737445544800000000000000000000000000000000000000000000000000"",
    ""votingRound"": ""0"",
    ""lowestUsedTimestamp"": ""1709151372"",
    ""requestBody"": {
      ""transactionHash"": ""0xff86f77260f7623f24ea888dfd14c56380c5cece1a896bd2566d6b3596343e20"",
      ""requiredConfirmations"": ""1"",
      ""provideInput"": true,
      ""listEvents"": true,
      ""logIndices"": []
    },
    ""responseBody"": {
      ""blockNumber"": ""5382901"",
      ""timestamp"": ""1709151372"",
      ""sourceAddress"": ""0x4C3dFaFc3207Eabb7dc8A6ab01Eb142C8655F373"",
      ""isDeployment"": false,
      ""receivingAddress"": ""0xfCcB55F281df58869593B64B48f8c2Fe66f91C5D"",
      ""value"": ""0"",
      ""input"": ""0xf29ca36c000000000000000000000000f274ccf1f92f9b34ff5704802a9b690e1d3cbc3800000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000044dd62ed3e0000000000000000000000004c3dfafc3207eabb7dc8a6ab01eb142c8655f373000000000000000000000000ff02f742106b8a25c26e65c1f0d66bec3c90d42900000000000000000000000000000000000000000000000000000000"",
      ""status"": ""1"",
      ""events"": [
        {
          ""logIndex"": ""4"",
          ""emitterAddress"": ""0xfCcB55F281df58869593B64B48f8c2Fe66f91C5D"",
          ""topics"": [
            ""0xe1b725358090db1f537294b09c773c14622b44c1bc2832d105fb28cc48f5bd90""
          ],
          ""data"": ""0x000000000000000000000000f274ccf1f92f9b34ff5704802a9b690e1d3cbc380000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000044dd62ed3e0000000000000000000000004c3dfafc3207eabb7dc8a6ab01eb142c8655f373000000000000000000000000ff02f742106b8a25c26e65c1f0d66bec3c90d4290000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000bc614e"",
          ""removed"": false
        }
      ]
    }
  }
}
Event data [
  '0xf274cCf1f92F9B34FF5704802a9B690E1d3cbC38',
  true,
  '0xdd62ed3e0000000000000000000000004c3dfafc3207eabb7dc8a6ab01eb142c8655f373000000000000000000000000ff02f742106b8a25c26e65c1f0d66bec3c90d429',
  '0x0000000000000000000000000000000000000000000000000000000000bc614e'
]
Method signature 0xdd62ed3e
Decoded calldata Result(2) [
  '0x4C3dFaFc3207Eabb7dc8A6ab01Eb142C8655F373',
  '0xFf02F742106B8a25C26e65C1f0d66BEC3C90d429'
]
Decoded state data Result(1) [ 12345678n ]
```

We can see that the event was emitted and all the calldata was properly decoded. Why is that important?

It means that you can now observe any state on the external blockchain without having to modify the contract on the external blockchain. This allows you to easily observe USDT movements, current token balances, and other state changes on the external blockchain.

### State Observation and Decoding

The last example showed how you can observe the state on another blockchain and use it in TypeScript. Now, we will also see how to properly decode the event in a smart contract. We will use the same contract onchain as before to emit events, `CallResult`, and then decode them in the contract. The result will then be passed to the contract on Coston, which will first decode the full event, ensure that the correct function was called, and then decode the returned data (which is the state you want to observe).

The full contract that does this is in `contracts/ERC20BalanceMonitor.sol` and the accompanying script is in the `scripts/evm/tryStateCheckingAndSave.ts` file. What you want to do is simple: query the ERC20 balance of a specific address and save it in the contract storage. Here, you need to be careful, as this query is valid only at the time of the transaction; it might be different at the time of block creation and confirmation. Plus, keep in mind that emitting an event means executing a transaction, and that means gas, so you should be careful with how often you do this.

The process is the same as before: you invoke the contract, it emits the event, and you use the result to interact with the chain. But this time, you cheat a bit. Instead of waiting for the whole data connector process to finish, you use `getResponse` to get just the response without the proof. The `ERC20BalanceMonitor` then disregards the proof and just uses the response to process the data.

The number of events can be quite large and processing all of them can be tedious (and error-prone), so the easiest way is to find out which event is the one you want and add an index parameter to the function call.

The code for this:

```solidity
/*
The function assumes that the event emitted in the eventIndex is the result of checking the balance of specific ERC20 token as emitted by FallbackWithEventContract (see previous guides).
The main idea is to first emit the event checking the balance and then properly decode it
*/
function confirmBalanceEvent(EVMTransaction.Proof calldata transaction, address tokenAddress, address targetAddress, uint256 eventIndex) public
{
    // We explicitly ignore the proof here, but in production code, you should always verify the proof
    // We ignore it so we can test the whole contract much faster on the same network using only the
    // In this guide we will just use the `prepareResponse` endpoint which has everything we need but the proof
    require(
        true || isEVMTransactionProofValid(transaction),
        ""Invalid proof""
    );

    EVMTransaction.Event memory _event = transaction.data.responseBody.events[eventIndex];
    // This just check the happy path - do kkep in mind, that this can possibly faked
    // And keep in mind that the specification does not require the topic0 to be event signature
    require(
        _event.topics[0] == keccak256(""CallResult(address,bool,bytes,bytes)""),
        ""Invalid event""
    );

    // _event.emitterAddress should be the contract we ""trust"" to correctly call the ERC20 token

    (address target, bool result, bytes memory callData, bytes memory returnData) = abi.decode(
        _event.data,
        (address, bool, bytes, bytes)
    );

    require(target == tokenAddress, ""Invalid token address"");


    bytes memory expectedCalldata = abi.encodeWithSignature(""balanceOf(address)"", targetAddress);
    require(
        keccak256(callData) == keccak256(expectedCalldata),
        ""Invalid calldata""
    );
      // If a tuple was returned from the call, we can unpack it using abi.decode in the same way as in the event data decoding
    uint256 balance = abi.decode(returnData, (uint256));

    balances[transaction.data.responseBody.blockNumber] = BalanceInfo({
        holder: targetAddress,
        token: tokenAddress,
        amount: balance,
        blockNumber: transaction.data.responseBody.blockNumber,
        timestamp: transaction.data.responseBody.timestamp,
        rawEvent: _event,
        proofHash: keccak256(abi.encode(transaction))
    });
}
```

We just ignore the proof, but then the fun part starts. We get the top-level event out of the response (this is the one that contains calldata and return data), check that the topic matches, and then decode the resulting data. Be careful, decoding the data might fail if you don't have the correct signature, so the example code is fine to show, but you might want to add more checks in production code.

Once the data of the top-level event is decoded, we check if the call data is what we expect and then decode the return data to get the balance, which is again dependent on what kind of return value was produced in the transaction. Again, the return data needs to be decoded (it might return something more complicated than just one `uint256`), but it is easy to get the full result. Once you have all this, you just write it to the contract storage, and you are done.

Let's take a look at the test code and show a simple trick that is also hidden in there.

The code is practically the same as before: you create a transaction, query the data connector, and use the data in the contract. But this time, everything is done on the same (Coston - `testSGB`) network. This makes it a bit easier to test, as you don't need to change the network, but it is a minor thing.

It does sound strange (and pointless) to allow the Data Connector to be used on the same network, but the main improvement comes from the top-level relayer coming in the FSP. Once the Data Connector is included in the top-level protocol, any Data Connector data is immediately relayed to externally connected chains via relay (as is the FTSO data). This means that external chains can also observe what is happening on Flare.

Think about this: up until now, you only relayed information from other chains to Flare, but now any example from the EVM part can immediately be replicated on the Sepolia chain with Flare being the source chain (where things happen).

{/* <!-- Meh: ### Contract creation --> */}",2025-03-08 01:27:14
connect-evm-chains.mdx,"title: Connect to EVM Chains
authors: [lukaavbreht, filipkoprivec]
description: Relay transaction and event data from Ethereum.
tags: [intermediate, ethereum, fdc]
keywords: [ethereum, flare-data-connector, evm, flare-network]
sidebar_position: 5
unlisted: true","This guide is for developers who want to connect to EVM chains. In this guide, you will learn how to:

- Use the `EVMTransaction` attestation type.

- Understand the implications of connecting account-based chains.

- Relay transaction information from Ethereum Sepolia to Flare Testnet Coston2.

## Examples

Now that you know how to request an attestation and what you are getting in return, let's explore some examples. These examples are a bit more involved and each will come in a few parts:

- Script making a dummy transaction on the `Sepolia` testnet.
- Smart contract(s) accepting an attestation request and performing some desired action.
- Deployment and run script that ties them together.

This deployment script will also allow you to understand exactly how long the waiting for each phase takes, which is something not previously focused on.

### Simple ETH transfer

Let's start small. You will create a smart contract that just tallies the top-level amounts transferred to a designated address on Sepolia.

The scenario is pretty simple:

- You have a ""payment"" to an Externally Owned Account (EOA - so not a smart contract) on Sepolia, and anyone can send funds there and prove this.
- On the Flare side, you will deploy a contract that will accept proofs with data in the proper accounting format: who has sent how much to this end owner address.

The full code for this example is in the `scripts/evm/trySimpleTransaction.ts`, `contracts/EthereumPaymentCollector.sol`, and `contracts/FallbackContract` files.

You won't be copy-pasting the full code here, but you will go through the most important parts.

The setup is now in two parts, and `main` correctly picks up the right part to run depending on the network it is run on.

First, deploy a simple `FallbackContract` on Sepolia.

```bash
yarn hardhat run scripts/evm/trySimpleTransaction --network sepolia
```

- This contract will just emit an event when the `fallback` function is called.
- You will be attesting to this event in the next part.
- The script makes two transactions on Sepolia: one with value to an address and one to the address of the contract.
- The second transaction will call the `fallback` function and emit the event.
- The transaction hashes are logged, and the JSON response of the attestation results is printed (so you can see what you will get in the next part).

Here is an example result:

```bash
0xac640ab047aa1097ddd473e5940921eb500a9912b33072b8532617692428830e
{
  ""status"": ""VALID"",
  ""response"": {
    ""attestationType"": ""0x45564d5472616e73616374696f6e000000000000000000000000000000000000"",
    ""sourceId"": ""0x7465737445544800000000000000000000000000000000000000000000000000"",
    ""votingRound"": ""0"",
    ""lowestUsedTimestamp"": ""1708907688"",
    ""requestBody"": {
      ""transactionHash"": ""0xac640ab047aa1097ddd473e5940921eb500a9912b33072b8532617692428830e"",
      ""requiredConfirmations"": ""1"",
      ""provideInput"": true,
      ""listEvents"": true,
      ""logIndices"": []
    },
    ""responseBody"": {
      ""blockNumber"": ""5363670"",
      ""timestamp"": ""1708907688"",
      ""sourceAddress"": ""0x4C3dFaFc3207Eabb7dc8A6ab01Eb142C8655F373"",
      ""isDeployment"": false,
      ""receivingAddress"": ""0xFf02F742106B8a25C26e65C1f0d66BEC3C90d429"",
      ""value"": ""10"",
      ""input"": ""0x0123456789"",
      ""status"": ""1"",
      ""events"": []
    }
  }
}
0x7eb54cde238fc700be31c98af7e4df8c4fc96fd5c634c490183ca612a481efcc
{
  ""status"": ""VALID"",
  ""response"": {
    ""attestationType"": ""0x45564d5472616e73616374696f6e000000000000000000000000000000000000"",
    ""sourceId"": ""0x7465737445544800000000000000000000000000000000000000000000000000"",
    ""votingRound"": ""0"",
    ""lowestUsedTimestamp"": ""1708907712"",
    ""requestBody"": {
      ""transactionHash"": ""0x7eb54cde238fc700be31c98af7e4df8c4fc96fd5c634c490183ca612a481efcc"",
      ""requiredConfirmations"": ""1"",
      ""provideInput"": true,
      ""listEvents"": true,
      ""logIndices"": []
    },
    ""responseBody"": {
      ""blockNumber"": ""5363672"",
      ""timestamp"": ""1708907712"",
      ""sourceAddress"": ""0x4C3dFaFc3207Eabb7dc8A6ab01Eb142C8655F373"",
      ""isDeployment"": false,
      ""receivingAddress"": ""0xeBBf567beDe2D8842dF538Cf64E0bE9976183853"",
      ""value"": ""10"",
      ""input"": ""0x9876543210"",
      ""status"": ""1"",
      ""events"": [
        {
          ""logIndex"": ""160"",
          ""emitterAddress"": ""0xeBBf567beDe2D8842dF538Cf64E0bE9976183853"",
          ""topics"": [
            ""0xaca09dd456ca888dccf8cc966e382e6e3042bb7e4d2d7815015f844edeafce42""
          ],
          ""data"": ""0x0000000000000000000000004c3dfafc3207eabb7dc8a6ab01eb142c8655f373000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000059876543210000000000000000000000000000000000000000000000000000000"",
          ""removed"": false
        }
      ]
    }
  }
}
```

After you have the transaction hashes, copy them to the part of the `main` method that will execute the Data Connector part, this time on Coston. Let's take a look at `executeStateConnectorProof`.

Here, the Data Connector part comes into play. You have already seen it in the previous guides, so you will just quickly scan through it. The code is a bit more involved, as you are now working with multiple transactions (this is not EVMTransaction specific, but it is a good example of how you can use the Data Connector to do more complex things). Again, you get an encoded attestation request (one for each transaction) and then you submit them to the Data Connector. Once this is done, you wait for the round to be confirmed (see the while loop that takes most of the time) and then you get the proof.

The `EthereumPaymentCollector` contract is deployed on Coston with one important method `collectPayment`. This method accepts the `EVMTransaction.Proof` response and does the important accounting.

As usual, first check that the provided proof is correct: that the Merkle proof really attests that this transaction was included in the Merkle tree.

Then comes the fun part - you can use the information from a transaction to do whatever you want. You won't just write it to the list of all transactions and be done. Instead, you will try to decode the event data and see what you can get from it. As mentioned before, the event data is specific to the event and you need to know the event structure to decode it properly. In this case, you know how it looks, and the decoding is done by the built-in `abi.decode`. You then just push the decoded data in struct form to the list of events and you are done.

:::warning

`abi.decode` is not type-safe and you can easily get wrong results if you don't know the event structure. Even more, this might be a security risk if you are not careful (or revert unexpectedly), but it is a nice representation of how powerful the events - and their information - can be.

:::

Finally, when you have both proofs and the contract deployed, you just call the `collectPayment` method with the proofs, and you are done (unless something goes wrong, then you will have to wait for the next round and try again).

The result looks something like:

```bash
Rounds:  [ '809307', '809307' ]
Waiting for the round to be confirmed 809303n 809307
Waiting for the round to be confirmed 809303n 809307
Waiting for the round to be confirmed 809303n 809307
Waiting for the round to be confirmed 809304n 809307
Waiting for the round to be confirmed 809304n 809307
Waiting for the round to be confirmed 809304n 809307
Waiting for the round to be confirmed 809304n 809307
Waiting for the round to be confirmed 809304n 809307
Waiting for the round to be confirmed 809305n 809307
Waiting for the round to be confirmed 809305n 809307
Waiting for the round to be confirmed 809305n 809307
Waiting for the round to be confirmed 809305n 809307
Waiting for the round to be confirmed 809306n 809307
Waiting for the round to be confirmed 809306n 809307
Waiting for the round to be confirmed 809306n 809307
Waiting for the round to be confirmed 809306n 809307
Waiting for the round to be confirmed 809306n 809307
Round confirmed, getting proof
Successfully submitted source code for contract
contracts/EthereumPaymentCollector.sol:EthereumPaymentCollector at 0x7cf6E7aeFD0207a5bE9a7DbcDA560fc7a6dBD7B4
for verification on the block explorer. Waiting for verification result...

Successfully verified contract EthereumPaymentCollector on the block explorer.
https://coston-explorer.flare.network/address/0x7cf6E7aeFD0207a5bE9a7DbcDA560fc7a6dBD7B4#code

{
  ""data"": {
    ""attestationType"": ""0x45564d5472616e73616374696f6e000000000000000000000000000000000000"",
    ""lowestUsedTimestamp"": ""1708907688"",
    ""requestBody"": {
      ""listEvents"": true,
      ""logIndices"": [],
      ""provideInput"": true,
      ""requiredConfirmations"": ""1"",
      ""transactionHash"": ""0xac640ab047aa1097ddd473e5940921eb500a9912b33072b8532617692428830e""
    },
    ""responseBody"": {
      ""blockNumber"": ""5363670"",
      ""events"": [],
      ""input"": ""0x0123456789"",
      ""isDeployment"": false,
      ""receivingAddress"": ""0xFf02F742106B8a25C26e65C1f0d66BEC3C90d429"",
      ""sourceAddress"": ""0x4C3dFaFc3207Eabb7dc8A6ab01Eb142C8655F373"",
      ""status"": ""1"",
      ""timestamp"": ""1708907688"",
      ""value"": ""10""
    },
    ""sourceId"": ""0x7465737445544800000000000000000000000000000000000000000000000000"",
    ""votingRound"": ""809307""
  },
  ""merkleProof"": [
    ""0x56faf895bbcb0b2a6f3bc283ea5e1793b224dca8b4b99240a34cee6d9bf1b8f3"",
    ""0x13ef0de709e7b0485f7623f5a0ad5b56aa23626fbffe5e7f4502bb7be5e0bf7e"",
    ""0xf72c31824174676516a9c5d9713cb1ae8866cac71462fe2b1a3c1e1b9418a94f""
  ]
}
{
  ""data"": {
    ""attestationType"": ""0x45564d5472616e73616374696f6e000000000000000000000000000000000000"",
    ""lowestUsedTimestamp"": ""1708907712"",
    ""requestBody"": {
      ""listEvents"": true,
      ""logIndices"": [],
      ""provideInput"": true,
      ""requiredConfirmations"": ""1"",
      ""transactionHash"": ""0x7eb54cde238fc700be31c98af7e4df8c4fc96fd5c634c490183ca612a481efcc""
    },
    ""responseBody"": {
      ""blockNumber"": ""5363672"",
      ""events"": [
        {
          ""data"": ""0x0000000000000000000000004c3dfafc3207eabb7dc8a6ab01eb142c8655f373000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000059876543210000000000000000000000000000000000000000000000000000000"",
          ""emitterAddress"": ""0xeBBf567beDe2D8842dF538Cf64E0bE9976183853"",
          ""logIndex"": ""160"",
          ""removed"": false,
          ""topics"": [
            ""0xaca09dd456ca888dccf8cc966e382e6e3042bb7e4d2d7815015f844edeafce42""
          ]
        }
      ],
      ""input"": ""0x9876543210"",
      ""isDeployment"": false,
      ""receivingAddress"": ""0xeBBf567beDe2D8842dF538Cf64E0bE9976183853"",
      ""sourceAddress"": ""0x4C3dFaFc3207Eabb7dc8A6ab01Eb142C8655F373"",
      ""status"": ""1"",
      ""timestamp"": ""1708907712"",
      ""value"": ""10""
    },
    ""sourceId"": ""0x7465737445544800000000000000000000000000000000000000000000000000"",
    ""votingRound"": ""809307""
  },
  ""merkleProof"": [
    ""0x8e45d2d564bf7d652cf904a72e53f5e7e34d7e5e184906afda92f755e99cd421"",
    ""0x13ef0de709e7b0485f7623f5a0ad5b56aa23626fbffe5e7f4502bb7be5e0bf7e"",
    ""0xf72c31824174676516a9c5d9713cb1ae8866cac71462fe2b1a3c1e1b9418a94f""
  ]
}
```

:::info

On the previous attestation types, we were only able to get transactions in the last two days (this is attestation type specific).

:::

### Decoding emitted events

As previously stated, an event will be the core feature for observing what is happening on other chains. Let's now use this to prove that an ERC20 payment was made on Sepolia and then decode the event to see who made the payment and how much.

As before, you will deploy an ERC20 contract on Sepolia, mint some tokens, and send them to an address. The full code is available in the `scripts/evm/tryERC20transfers.ts` and `contracts/MintableERC20.sol` files.

A sample response for the ERC20 transaction would look like:

```bash
Sepolia USDT deployed to: 0x6023e19d70C304eA16a3728ceDcb042791737EC3
0xd7eed8cf377a4079718e8d709b3648d62a3a16ea39fbfbe759600c3d574caa15
{
  ""status"": ""VALID"",
  ""response"": {
    ""attestationType"": ""0x45564d5472616e73616374696f6e000000000000000000000000000000000000"",
    ""sourceId"": ""0x7465737445544800000000000000000000000000000000000000000000000000"",
    ""votingRound"": ""0"",
    ""lowestUsedTimestamp"": ""1708999068"",
    ""requestBody"": {
      ""transactionHash"": ""0xd7eed8cf377a4079718e8d709b3648d62a3a16ea39fbfbe759600c3d574caa15"",
      ""requiredConfirmations"": ""1"",
      ""provideInput"": true,
      ""listEvents"": true,
      ""logIndices"": []
    },
    ""responseBody"": {
      ""blockNumber"": ""5370899"",
      ""timestamp"": ""1708999068"",
      ""sourceAddress"": ""0x4C3dFaFc3207Eabb7dc8A6ab01Eb142C8655F373"",
      ""isDeployment"": false,
      ""receivingAddress"": ""0x6023e19d70C304eA16a3728ceDcb042791737EC3"",
      ""value"": ""0"",
      ""input"": ""0x40c10f190000000000000000000000004c3dfafc3207eabb7dc8a6ab01eb142c8655f37300000000000000000000000000000000000000000000000000000000000f4240"",
      ""status"": ""1"",
      ""events"": [
        {
          ""logIndex"": ""38"",
          ""emitterAddress"": ""0x6023e19d70C304eA16a3728ceDcb042791737EC3"",
          ""topics"": [
            ""0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef"",
            ""0x0000000000000000000000000000000000000000000000000000000000000000"",
            ""0x0000000000000000000000004c3dfafc3207eabb7dc8a6ab01eb142c8655f373""
          ],
          ""data"": ""0x00000000000000000000000000000000000000000000000000000000000f4240"",
          ""removed"": false
        }
      ]
    }
  }
}
0x9dffa80b6daea45ed4bfc93bb72cdb893549fdefb81cb760b7ce08edef9859a6
{
  ""status"": ""VALID"",
  ""response"": {
    ""attestationType"": ""0x45564d5472616e73616374696f6e000000000000000000000000000000000000"",
    ""sourceId"": ""0x7465737445544800000000000000000000000000000000000000000000000000"",
    ""votingRound"": ""0"",
    ""lowestUsedTimestamp"": ""1708999080"",
    ""requestBody"": {
      ""transactionHash"": ""0x9dffa80b6daea45ed4bfc93bb72cdb893549fdefb81cb760b7ce08edef9859a6"",
      ""requiredConfirmations"": ""1"",
      ""provideInput"": true,
      ""listEvents"": true,
      ""logIndices"": []
    },
    ""responseBody"": {
      ""blockNumber"": ""5370900"",
      ""timestamp"": ""1708999080"",
      ""sourceAddress"": ""0x4C3dFaFc3207Eabb7dc8A6ab01Eb142C8655F373"",
      ""isDeployment"": false,
      ""receivingAddress"": ""0x6023e19d70C304eA16a3728ceDcb042791737EC3"",
      ""value"": ""0"",
      ""input"": ""0xa9059cbb000000000000000000000000ff02f742106b8a25c26e65c1f0d66bec3c90d42900000000000000000000000000000000000000000000000000000000000003e8"",
      ""status"": ""1"",
      ""events"": [
        {
          ""logIndex"": ""32"",
          ""emitterAddress"": ""0x6023e19d70C304eA16a3728ceDcb042791737EC3"",
          ""topics"": [
            ""0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef"",
            ""0x0000000000000000000000004c3dfafc3207eabb7dc8a6ab01eb142c8655f373"",
            ""0x000000000000000000000000ff02f742106b8a25c26e65c1f0d66bec3c90d429""
          ],
          ""data"": ""0x00000000000000000000000000000000000000000000000000000000000003e8"",
          ""removed"": false
        }
      ]
    }
  }
}
```

Let's now decode the data you got back and explore the event in a little more detail.

```json
{
  ""logIndex"": ""38"",
  ""emitterAddress"": ""0x6023e19d70C304eA16a3728ceDcb042791737EC3"",
  ""topics"": [
    ""0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef"",
    ""0x0000000000000000000000000000000000000000000000000000000000000000"",
    ""0x0000000000000000000000004c3dfafc3207eabb7dc8a6ab01eb142c8655f373""
  ],
  ""data"": ""0x00000000000000000000000000000000000000000000000000000000000f4240"",
  ""removed"": false
}
{
  ""logIndex"": ""32"",
  ""emitterAddress"": ""0x6023e19d70C304eA16a3728ceDcb042791737EC3"",
  ""topics"": [
    ""0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef"",
    ""0x0000000000000000000000004c3dfafc3207eabb7dc8a6ab01eb142c8655f373"",
    ""0x000000000000000000000000ff02f742106b8a25c26e65c1f0d66bec3c90d429""
  ],
  ""data"": ""0x00000000000000000000000000000000000000000000000000000000000003e8"",
  ""removed"": false
}
```

When processing the events, it is important to know which contract should be emitting the event (you don't want to count a memecoin transfer as a USDT transfer). The `topics` are the indexed arguments of the event, and the `data` is the non-indexed arguments. This was glossed over in the first part, but now it will be important.

If you take a look at the event definition:

```solidity
event Transfer(address indexed from, address indexed to, uint256 value);
```

You see that it has three arguments, two indexed and one non-indexed. However, there are three topics in the event. How do we interpret that? In our case, the first one is the event signature, and the other two are the indexed arguments. Importantly, that is not always the case (it is the case for events that are emitted by Solidity contracts, but not necessarily for other contracts or direct assembly code).

Let's now decode the event data. The second event has the following data:

```json
""topics"": [
    ""0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef"",
    ""0x0000000000000000000000004c3dfafc3207eabb7dc8a6ab01eb142c8655f373"",
    ""0x000000000000000000000000ff02f742106b8a25c26e65c1f0d66bec3c90d429""
]
```

The first topic is the [event signature](https://www.4byte.directory/event-signatures/?bytes_signature=0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef), and the other two are the from and to addresses. You can easily see how they are zero-padded to accommodate the whole 32 bytes.

Similarly, the event in the first transaction that just minted 1,000,000 token wei (hex encoded in the data field) has the same zeroth topic, same recipient (topic with index 2), and zero address as the sender.

{/* <!-- This is good for future examples, but too time consuming to do now --><!-- #### ERC20 payment --> */}

Let's upgrade the contract from before to tally ERC20 payments on external chains. You can do this by listening to events, decoding them, and using the decoded information.

{/* TODO: Here, we will create a simple contract on Sepolia and follow the events it emits, just to see another example of how events function. --> */}

### Decoding transaction data

You now know how to listen to events and decode them. Let's see how we can also decode top-level transaction data. Here, you will verify whether the top-level transaction really did increase the ERC20 allowance and see how to get top-level calldata.

The full code for this example is in the `scripts/evm/tryERC20Allowance.ts` and `contracts/MintableERC20.sol` files.

You initiate a simple `allowance` increase on Sepolia and then decode the calldata to see if it is really what you expect. The example response is something like this:

```json
{
  ""status"": ""VALID"",
  ""response"": {
    ""attestationType"": ""0x45564d5472616e73616374696f6e000000000000000000000000000000000000"",
    ""sourceId"": ""0x7465737445544800000000000000000000000000000000000000000000000000"",
    ""votingRound"": ""0"",
    ""lowestUsedTimestamp"": ""1709147568"",
    ""requestBody"": {
      ""transactionHash"": ""0x445ac68dd09198cb3b8202cb9ccba323d4d1c82157a076f97fd6682dfaa826d9"",
      ""requiredConfirmations"": ""1"",
      ""provideInput"": true,
      ""listEvents"": true,
      ""logIndices"": []
    },
    ""responseBody"": {
      ""blockNumber"": ""5382600"",
      ""timestamp"": ""1709147568"",
      ""sourceAddress"": ""0x4C3dFaFc3207Eabb7dc8A6ab01Eb142C8655F373"",
      ""isDeployment"": false,
      ""receivingAddress"": ""0xc14FA393fa7248c73B74A303cf35D5e980E11e2C"",
      ""value"": ""0"",
      ""input"": ""0x095ea7b3000000000000000000000000ff02f742106b8a25c26e65c1f0d66bec3c90d42900000000000000000000000000000000000000000000000000000000000003e8"",
      ""status"": ""1"",
      ""events"": [
        {
          ""logIndex"": ""54"",
          ""emitterAddress"": ""0xc14FA393fa7248c73B74A303cf35D5e980E11e2C"",
          ""topics"": [
            ""0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925"",
            ""0x0000000000000000000000004c3dfafc3207eabb7dc8a6ab01eb142c8655f373"",
            ""0x000000000000000000000000ff02f742106b8a25c26e65c1f0d66bec3c90d429""
          ],
          ""data"": ""0x00000000000000000000000000000000000000000000000000000000000003e8"",
          ""removed"": false
        }
      ]
    }
  }
}
Result(2) [ '0xFf02F742106B8a25C26e65C1f0d66BEC3C90d429', 1000n ]
```

By now, you should be able to see that the emitted event was the `Approval` event, and the data is the new allowance (with the correct participant addresses in the topics).

What we want to take a look at is the `input` field. It contains the calldata of the top-level transaction. Since you know the signature of this method, you can easily decode it and get the result you expect.

### Observing state through events

We do not have direct access to state on the other chain, but we can circumvent this using events. If we deploy a contract on the external chain that emits events pertaining to the state it can read (at that block) from the chain, we can easily observe this state (frozen at that point in time) on Flare. Let's see how we can easily observe the current status of ERC20 allowance.

The full code for this example is in the `scripts/evm/tryStateChecking.ts` and `contracts/FallbackWithEventContract.sol` files.

The contract is simple:

```solidity
function getState(address target, bytes calldata cdata) external payable {
      // Just forward the call to the contract we want to interact with
      // Caution - this is very unsafe, as the calldata can be anything
      // If this contract were to had some tokens for example, the calldata could be used to transfer them.
      (bool result, bytes memory returnData) = target.call{value: msg.value}(cdata);
      emit CallResult(target, result, msg.data, returnData);
      // A bit safer way would be to only allow specific functions to be called or use something like this: https://github.com/gnosis/util-contracts/blob/main/contracts/storage/StorageAccessible.sol
  }
```

Any call to this contract will be forwarded to the target contract, and the result will be emitted as an event.

The script is also relatively simple (though it does a lot of things).

We get the event in the same way as before, but now we also get the calldata and the target address. We need to do two things: First, decode the event to see what happened, and then decode the calldata to see what the state is. Then, decode both data bytes to see what we got. Importantly, it is necessary to know the structure of the event and the method we called to properly decode it.

The response is something like this:

```bash
Sepolia USDT deployed to: 0xf274cCf1f92F9B34FF5704802a9B690E1d3cbC38
FallbackWithEventContract deployed to: 0xfCcB55F281df58869593B64B48f8c2Fe66f91C5D
{
  ""status"": ""VALID"",
  ""response"": {
    ""attestationType"": ""0x45564d5472616e73616374696f6e000000000000000000000000000000000000"",
    ""sourceId"": ""0x7465737445544800000000000000000000000000000000000000000000000000"",
    ""votingRound"": ""0"",
    ""lowestUsedTimestamp"": ""1709151372"",
    ""requestBody"": {
      ""transactionHash"": ""0xff86f77260f7623f24ea888dfd14c56380c5cece1a896bd2566d6b3596343e20"",
      ""requiredConfirmations"": ""1"",
      ""provideInput"": true,
      ""listEvents"": true,
      ""logIndices"": []
    },
    ""responseBody"": {
      ""blockNumber"": ""5382901"",
      ""timestamp"": ""1709151372"",
      ""sourceAddress"": ""0x4C3dFaFc3207Eabb7dc8A6ab01Eb142C8655F373"",
      ""isDeployment"": false,
      ""receivingAddress"": ""0xfCcB55F281df58869593B64B48f8c2Fe66f91C5D"",
      ""value"": ""0"",
      ""input"": ""0xf29ca36c000000000000000000000000f274ccf1f92f9b34ff5704802a9b690e1d3cbc3800000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000044dd62ed3e0000000000000000000000004c3dfafc3207eabb7dc8a6ab01eb142c8655f373000000000000000000000000ff02f742106b8a25c26e65c1f0d66bec3c90d42900000000000000000000000000000000000000000000000000000000"",
      ""status"": ""1"",
      ""events"": [
        {
          ""logIndex"": ""4"",
          ""emitterAddress"": ""0xfCcB55F281df58869593B64B48f8c2Fe66f91C5D"",
          ""topics"": [
            ""0xe1b725358090db1f537294b09c773c14622b44c1bc2832d105fb28cc48f5bd90""
          ],
          ""data"": ""0x000000000000000000000000f274ccf1f92f9b34ff5704802a9b690e1d3cbc380000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000044dd62ed3e0000000000000000000000004c3dfafc3207eabb7dc8a6ab01eb142c8655f373000000000000000000000000ff02f742106b8a25c26e65c1f0d66bec3c90d4290000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000bc614e"",
          ""removed"": false
        }
      ]
    }
  }
}
Event data [
  '0xf274cCf1f92F9B34FF5704802a9B690E1d3cbC38',
  true,
  '0xdd62ed3e0000000000000000000000004c3dfafc3207eabb7dc8a6ab01eb142c8655f373000000000000000000000000ff02f742106b8a25c26e65c1f0d66bec3c90d429',
  '0x0000000000000000000000000000000000000000000000000000000000bc614e'
]
Method signature 0xdd62ed3e
Decoded calldata Result(2) [
  '0x4C3dFaFc3207Eabb7dc8A6ab01Eb142C8655F373',
  '0xFf02F742106B8a25C26e65C1f0d66BEC3C90d429'
]
Decoded state data Result(1) [ 12345678n ]
```

We can see that the event was emitted and all the calldata was properly decoded. Why is that important?

It means that you can now observe any state on the external blockchain without having to modify the contract on the external blockchain. This allows you to easily observe USDT movements, current token balances, and other state changes on the external blockchain.

### State observation and decoding

The last example showed how you can observe the state on another blockchain and use it in TypeScript. Now, we will also see how to properly decode the event in a smart contract. We will use the same contract onchain as before to emit events, `CallResult`, and then decode them in the contract. The result will then be passed to the contract on Coston, which will first decode the full event, ensure that the correct function was called, and then decode the returned data (which is the state you want to observe).

The full contract that does this is in `contracts/ERC20BalanceMonitor.sol` and the accompanying script is in the `scripts/evm/tryStateCheckingAndSave.ts` file. What you want to do is simple: query the ERC20 balance of a specific address and save it in the contract storage. Here, you need to be careful, as this query is valid only at the time of the transaction; it might be different at the time of block creation and confirmation. Plus, keep in mind that emitting an event means executing a transaction, and that means gas, so you should be careful with how often you do this.

The process is the same as before: you invoke the contract, it emits the event, and you use the result to interact with the chain. But this time, you cheat a bit. Instead of waiting for the whole data connector process to finish, you use `getResponse` to get just the response without the proof. The `ERC20BalanceMonitor` then disregards the proof and just uses the response to process the data.

The number of events can be quite large and processing all of them can be tedious (and error-prone), so the easiest way is to find out which event is the one you want and add an index parameter to the function call.

The code for this:

```solidity
/*
The function assumes that the event emitted in the eventIndex is the result of checking the balance of specific ERC20 token as emitted by FallbackWithEventContract (see previous guides).
The main idea is to first emit the event checking the balance and then properly decode it
*/
function confirmBalanceEvent(EVMTransaction.Proof calldata transaction, address tokenAddress, address targetAddress, uint256 eventIndex) public
{
    // We explicitly ignore the proof here, but in production code, you should always verify the proof
    // We ignore it so we can test the whole contract much faster on the same network using only the
    // In this guide we will just use the `prepareResponse` endpoint which has everything we need but the proof
    require(
        true || isEVMTransactionProofValid(transaction),
        ""Invalid proof""
    );

    EVMTransaction.Event memory _event = transaction.data.responseBody.events[eventIndex];
    // This just check the happy path - do kkep in mind, that this can possibly faked
    // And keep in mind that the specification does not require the topic0 to be event signature
    require(
        _event.topics[0] == keccak256(""CallResult(address,bool,bytes,bytes)""),
        ""Invalid event""
    );

    // _event.emitterAddress should be the contract we ""trust"" to correctly call the ERC20 token

    (address target, bool result, bytes memory callData, bytes memory returnData) = abi.decode(
        _event.data,
        (address, bool, bytes, bytes)
    );

    require(target == tokenAddress, ""Invalid token address"");


    bytes memory expectedCalldata = abi.encodeWithSignature(""balanceOf(address)"", targetAddress);
    require(
        keccak256(callData) == keccak256(expectedCalldata),
        ""Invalid calldata""
    );
      // If a tuple was returned from the call, we can unpack it using abi.decode in the same way as in the event data decoding
    uint256 balance = abi.decode(returnData, (uint256));

    balances[transaction.data.responseBody.blockNumber] = BalanceInfo({
        holder: targetAddress,
        token: tokenAddress,
        amount: balance,
        blockNumber: transaction.data.responseBody.blockNumber,
        timestamp: transaction.data.responseBody.timestamp,
        rawEvent: _event,
        proofHash: keccak256(abi.encode(transaction))
    });
}
```

We just ignore the proof, but then the fun part starts. We get the top-level event out of the response (this is the one that contains calldata and return data), check that the topic matches, and then decode the resulting data. Be careful, decoding the data might fail if you don't have the correct signature, so the example code is fine to show, but you might want to add more checks in production code.

Once the data of the top-level event is decoded, we check if the call data is what we expect and then decode the return data to get the balance, which is again dependent on what kind of return value was produced in the transaction. Again, the return data needs to be decoded (it might return something more complicated than just one `uint256`), but it is easy to get the full result. Once you have all this, you just write it to the contract storage, and you are done.

Let's take a look at the test code and show a simple trick that is also hidden in there.

The code is practically the same as before: you create a transaction, query the data connector, and use the data in the contract. But this time, everything is done on the same (Coston - `testSGB`) network. This makes it a bit easier to test, as you don't need to change the network, but it is a minor thing.

It does sound strange (and pointless) to allow the Data Connector to be used on the same network, but the main improvement comes from the top-level relayer coming in the FSP. Once the Data Connector is included in the top-level protocol, any Data Connector data is immediately relayed to externally connected chains via relay (as is the FTSO data). This means that external chains can also observe what is happening on Flare.

Think about this: up until now, you only relayed information from other chains to Flare, but now any example from the EVM part can immediately be replicated on the Sepolia chain with Flare being the source chain (where things happen).

{/* <!-- Meh: ### Contract creation --> */}",2025-03-08 01:27:14
evm-transaction.mdx,"title: EVM Transaction
authors: [lukaavbreht, filipkoprivec]
description: Retrieve the transaction data from Ethereum, Flare, or Songbird.
tags: [intermediate, ethereum, fdc]
keywords: [ethereum, flare-data-connector, evm, flare-network]
sidebar_position: 6
unlisted: false","The [`EVMTransaction`](/fdc/attestation-types/evm-transaction) attestation type enables data collection about a transaction on an EVM chain.
The currently supported chain are: `ETH`, `FLR`, and `SGB`.
You can learn more about it in the official [specification repo](/fdc/attestation-types/evm-transaction).

We will now demonstrate how the FDC protocol can be used to collect the data of a given Ethereum transaction.
The transaction we will be observing has the hash `0x4e636c6590b22d8dcdade7ee3b5ae5572f42edb1878f09b3034b2f7c3362ef3c`; this is an arbitrary transaction that we acquired from the Sepolia Ethereum testnet [explorer](https://sepolia.etherscan.io/).

The same procedure works for all supported sources, `ETH`, `FLR`, and `SGB`.
The source then requires only a slight modification; we will remind you of that when it comes up in the guide.

In this guide, we will be following the steps outlined in the [FDC Overview](/fdc/overview).

Our implementation requires handling the FDC voting round finalization process.
To manage this, we will create separate scripts in `script/fdcExample/EVMTransaction.s.sol` that handle different stages of the validation process:

```solidity title=""scrip/fdcExample/EVMTransaction.s.sol""
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.25;

import {Script} from ""dependencies/forge-std-1.9.5/src/Script.sol"";
...

string constant attestationTypeName = ""EVMTransaction"";
string constant dirPath = ""data/"";

contract PrepareAttestationRequest is Script {
 ...
}

contract SubmitAttestationRequest is Script {
 ...
}

contract RetrieveDataAndProof is Script {
 ...
}

contract Deploy is Script {
 ...
}
...
```

The names of included contracts mostly mirror the steps described in the [FDC guide](/fdc/overview).

To bridge the separate executions of the scripts, we will save the relevant data of each script to a file in the `dirPath` folder.
Each succeeding script will then read that file to load the data.

## Prepare request

The JSON request to the verifier is the same form for all attestation types, but the values of the fields differ between them.
It contains the following fields.

### Required Fields

- `attestationType` is the UTF8 hex string encoding of the attestation type name, zero-padded to 32 bytes.
- `sourceId` is the UTF8 hex string encoding of the data source identifier name, zero-padded to 32 bytes.
- `requestBody` is different for each attestation type.

In the case of `EVMTransaction`, `requestBody` is a JSON containing the fields:

- `transactionHash`: hash (address) of the observed transaction
- `requiredConfirmations`: the depth of the block containing the transaction at which it is considered confirmed, i.e. when the transaction itself is considered confirmed; as `uint16`
- `provideInput`: a `bool` determining whether the `input` field is included in the response
- `listEvents`: a `bool` determining whether the `events` field is included in the response
- `logIndices`: an `uint32` array of indices of the events to be included in the response; if `listEvents` is set to false `false` and this field is not `[]`, the attestation request will fail

### Reference Documentation

- [EVMTransaction Specification](/fdc/attestation-types/evm-transaction)
- [Verifier Interactive Docs](https://fdc-verifiers-testnet.flare.network/verifier/api-doc#/)

### Example Values

- `transactionHash`: `0x4e636c6590b22d8dcdade7ee3b5ae5572f42edb1878f09b3034b2f7c3362ef3c`
- `requiredConfirmations`: `1`
- `provideInput`: `true`
- `listEvents`: `true`
- `logIndices`: `[]`

### Encoding Functions

To encode values into UTF8 hex:

- `toUtf8HexString`: Converts a string to UTF8 hex.
- `toHexString`: Zero-right-pads the string to 32 bytes.

These functions are included in the [Base library](https://github.com/flare-foundation/flare-foundry-starter/blob/master/script/fdcExample/Base.s.sol) within the [example repository](https://github.com/flare-foundation/flare-foundry-starter), but they can also be defined locally in your contract or script.

The first function translates a string to a UTF8 encoded hex string.
The other then zero-right-pads such a string, so that it is 32 bytes long.

```solidity title=""scrip/fdcExample/Base.s.sol""
function toHexString(
 bytes memory data
) public pure returns (string memory) {
 bytes memory alphabet = ""0123456789abcdef"";

 bytes memory str = new bytes(2 + data.length * 2);
 str[0] = ""0"";
 str[1] = ""x"";
 for (uint i = 0; i < data.length; i++) {
 str[2 + i * 2] = alphabet[uint(uint8(data[i] >> 4))];
 str[3 + i * 2] = alphabet[uint(uint8(data[i] & 0x0f))];
 }
 return string(str);
}
```

```solidity title=""scrip/fdcExample/Base.s.sol""
function toUtf8HexString(
 string memory _string
) internal pure returns (string memory) {
 string memory encodedString = toHexString(
 abi.encodePacked(_string)
 );
 uint256 stringLength = bytes(encodedString).length;
 require(stringLength <= 64, ""String too long"");
 uint256 paddingLength = 64 - stringLength + 2;
 for (uint256 i = 0; i < paddingLength; i++) {
 encodedString = string.concat(encodedString, ""0"");
 }
 return encodedString;
}
```

We also define a helper function for formatting data into a JSON string.

```solidity title=""scrip/fdcExample/Base.s.sol""
function prepareAttestationRequest(
 string memory attestationType,
 string memory sourceId,
 string memory requestBody
) internal view returns (string[] memory, string memory) {
 // We read the API key from the .env file
 string memory apiKey = vm.envString(""VERIFIER_API_KEY"");

 // Preparing headers
 string[] memory headers = prepareHeaders(apiKey);
 // Preparing body
 string memory body = prepareBody(
 attestationType,
 sourceId,
 requestBody
 );

 console.log(
 ""headers: %s"",
 string.concat(""{"", headers[0], "", "", headers[1]),
 ""}\n""
 );
 console.log(""body: %s\n"", body);
 return (headers, body);
}

function prepareHeaders(
 string memory apiKey
) internal pure returns (string[] memory) {
 string[] memory headers = new string[](2);
 headers[0] = string.concat('""X-API-KEY"": ', apiKey);
 headers[1] = '""Content-Type"": ""application/json""';
 return headers;
}

function prepareBody(
 string memory attestationType,
 string memory sourceId,
 string memory body
) internal pure returns (string memory) {
 return
 string.concat(
 '{""attestationType"": ',
 '""',
 attestationType,
 '""',
 ', ""sourceId"": ',
 '""',
 sourceId,
 '""',
 ', ""requestBody"": ',
 body,
 ""}""
 );
}

```

In the example repository, these are once again included within the [Base](https://github.com/flare-foundation/flare-foundry-starter/blob/master/script/fdcExample/Base.s.sol) library file.

Thus, the part of the script that prepares the verifier request looks like:

```solidity title=""scrip/fdcExample/EVMTransaction.s.sol""
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.25;

import {console} from ""dependencies/forge-std-1.9.5/src/console.sol"";
import {Script} from ""dependencies/forge-std-1.9.5/src/Script.sol"";
import {Base} from ""./Base.s.sol"";
...

string constant attestationTypeName = ""EVMTransaction"";
string constant dirPath = ""data/"";

contract PrepareAttestationRequest is Script {
 using Surl for *;
 // Setting request data
 string public transactionHash =
 ""0x4e636c6590b22d8dcdade7ee3b5ae5572f42edb1878f09b3034b2f7c3362ef3c"";
 string public requiredConfirmations = ""1"";
 string public provideInput = ""true"";
 string public listEvents = ""true"";
 string public logIndices = ""[]"";
 string public sourceName = ""testETH""; // Bitcoin chain ID
 string public baseSourceName = ""eth""; // Part of verifier URL

 function prepareRequestBody(
 string memory transactionHash,
 string memory requiredConfirmations,
 string memory provideInput,
 string memory listEvents,
 string memory logIndices
 ) private pure returns (string memory) {
 return
 string.concat(
 '{""transactionHash"": ',
 '""',
 transactionHash,
 '""',
 ', ""requiredConfirmations"": ',
 '""',
 requiredConfirmations,
 '""',
 ', ""provideInput"": ',
 provideInput,
 ', ""listEvents"": ',
 listEvents,
 ', ""logIndices"": ',
 logIndices,
 ""}""
 );
 }

 function run() external {
 // Preparing request data
 string memory attestationType = toUtf8HexString(
 attestationTypeName
 );
 string memory sourceId = toUtf8HexString(sourceName);
 string memory requestBody = prepareRequestBody(
 transactionHash,
 requiredConfirmations,
 provideInput,
 listEvents,
 logIndices
 );

 (string[] memory headers, string memory body) =
 prepareAttestationRequest(attestationType, sourceId, requestBody);

 ...
 }
}

...
```

If you are accessing a different chain, replace the `baseSourceName` with an appropriate value, `flr` or `sgb`.

The code above differs slightly from the [starter example](https://github.com/flare-foundation/flare-foundry-starter).
But, if we remove the ellipses `...` signifying missing code, we can still run the script.

Because of the `console.log` commands it will produce JSON strings that represent valid requests; we can then pass this to the [interactive verifier](https://fdc-verifiers-testnet.flare.network/verifier/btc/api-doc#/EVMTransaction/BTCEVMTransactionVerifierController_prepareRequest) to check what the response will be.

We can run the script by calling the following commands in the console.

```bash
source .env
```

```bash
forge script script/fdcExample/EVMTransaction.s.sol:PrepareAttestationRequest --private-key $PRIVATE_KEY --rpc-url $COSTON2_RPC_URL --etherscan-api-key $FLARE_API_KEY --broadcast  --ffi
```

The prerequisite for this is that the `.env` file is not missing the `PRIVATE KEY` and `COSTON2_RPC_URL` values.
The script can also access other chains; that can be achieved by replacing the `--rpc-url` value with `COSTON_RPC_URL`, `FLARE_RPC_URL`, or `SONGBIRD_RPC_URL`.

## Post request to verifier

Before submitting address validation requests to the FDC protocol, we first need to prepare and send them to a verifier server.
This section walks through the request submission process using the `surl` package.
We place `using Surl for *;` at the start of our `PostRequest` contract, and then call its `post` method on the verifier URL.

```solidity title=""scrip/fdcExample/EVMTransaction.s.sol""
(, bytes memory data) = url.post(headers, body);
```

We construct the URL by appending to the verifier address `https://fdc-verifiers-testnet.flare.network/` the path `verifier/btc/EVMTransaction/prepareRequest`.
We can do so dynamically with the following code.

```solidity title=""scrip/fdcExample/EVMTransaction.s.sol""
string memory baseUrl = ""https://fdc-verifiers-testnet.flare.network/"";
string memory url = string.concat(
 baseUrl,
 ""verifier/"",
 baseSourceName,
 ""/"",
 attestationTypeName,
 ""/prepareRequest""
);
console.log(""url: %s"", url);
string memory requestBody = string.concat(
 '{""addressStr"": ""',
 addressStr,
 '""}'
);
```

Lastly, we parse the return data from the verifier server.
Using the Foundry `parseJson` shortcode, and a custom struct `AttestationResponse`, we decode the returned data and extract from it the ABI encoded request.

```solidity title=""scrip/fdcExample/Base.s.sol""
function parseAttestationRequest(
 bytes memory data
) internal pure returns (AttestationResponse memory) {
 string memory dataString = string(data);
 bytes memory dataJson = vm.parseJson(dataString);

 AttestationResponse memory response = abi.decode(
 dataJson,
 (AttestationResponse)
 );

 console.log(""response status: %s\n"", response.status);
 console.log(""response abiEncodedRequest: "");
 console.logBytes(response.abiEncodedRequest);
 console.log(""\n"");

 return response;
}
```

:::info
If everything went right, the `abiEncodedRequest` should look something like this.

```
0x
45564d5472616e73616374696f6e000000000000000000000000000000000000
7465737445544800000000000000000000000000000000000000000000000000
9d410778cc0b2b8f1b8eaa79cbd0eed5d3be7514dea070e2041ad00a4c6e88f8
0000000000000000000000000000000000000000000000000000000000000020
4e636c6590b22d8dcdade7ee3b5ae5572f42edb1878f09b3034b2f7c3362ef3c
0000000000000000000000000000000000000000000000000000000000000001
0000000000000000000000000000000000000000000000000000000000000001
0000000000000000000000000000000000000000000000000000000000000001
00000000000000000000000000000000000000000000000000000000000000a0
0000000000000000000000000000000000000000000000000000000000000000
```

Let's break it down line by line:

- **First line:** `toUtf8HexString(""EVMTransaction"")`
- **Second line:** `toUtf8HexString(""testETH"")`
- **Third line:** message integrity code (MIC), a hash of the whole response salted with a string `""Flare""`, ensures the integrity of the attestation
- **Remaining lines:** ABI encoded `EVMTransaction.RequestBody` Solidity struct
  :::

What this demonstrates is that, with some effort, the `abiEncodedRequest` can be constructed manually.

We write the `abiEncodedRequest` to a file (`data/EVMTransaction_abiEncodedRequest.txt`) to it in the next step.

```solidity title=""scrip/fdcExample/EVMTransaction.s.sol""
Base.writeToFile(
    dirPath,
    string.concat(attestationTypeName, ""_abiEncodedRequest""),
    StringsBase.toHexString(response.abiEncodedRequest),
    true
);
```

## Submit request to FDC

This step transitions from off-chain request preparation to on-chain interaction with the FDC protocol. Now, we submit the validated request to the blockchain using deployed smart contracts.

### Submit request

The entire submission process requires only five key steps:

```solidity title=""scrip/fdcExample/Base.s.sol""
function submitAttestationRequest(bytes memory abiEncodedRequest) internal {
    uint256 deployerPrivateKey = vm.envUint(""PRIVATE_KEY"");
    vm.startBroadcast(deployerPrivateKey);
    IFdcRequestFeeConfigurations fdcRequestFeeConfigurations = ContractRegistry
            .getFdcRequestFeeConfigurations();
    uint256 requestFee = fdcRequestFeeConfigurations.getRequestFee(
        abiEncodedRequest
    );
    console.log(""request fee: %s\n"", requestFee);
    vm.stopBroadcast();

    vm.startBroadcast(deployerPrivateKey);

    // address fdcHubAddress = 0x48aC463d7975828989331F4De43341627b9c5f1D;
    IFdcHub fdcHub = ContractRegistry.getFdcHub();
    console.log(""fcdHub address:"");
    console.log(address(fdcHub));
    console.log(""\n"");

    fdcHub.requestAttestation{value: requestFee}(abiEncodedRequest);
    vm.stopBroadcast();
}
```

### Step-by-Step Breakdown

1.  Load Private Key
    The private key is read from the `.env` file using Foundry's `envUint` function:

```solidity
       uint256 deployerPrivateKey = vm.envUint(""PRIVATE_KEY"");
```

2.  Obtain Request Fee
    We retrieve the required requestFee from the `FdcRequestFeeConfigurations` contract:

```solidity
        IFdcRequestFeeConfigurations fdcRequestFeeConfigurations = ContractRegistry
            .getFdcRequestFeeConfigurations();
        uint256 requestFee = fdcRequestFeeConfigurations.getRequestFee(
            response.abiEncodedRequest
        );

```

    This is done in a separate broadcast to ensure `requestFee` is available before submitting the request.

3. Access `FdcHub` Contract
   Using the `ContractRegistry` library (from `flare-periphery`), we fetch the `FdcHub` contract:

```solidity
   IFdcHub fdcHub = ContractRegistry.getFdcHub();
   console.log(""fcdHub address:"");
   console.log(address(fdcHub));
   console.log(""\n"");
```

4. Submit the Attestation Request
   We send the attestation request with the required fee:

```solidity
 fdcHub.requestAttestation{value: requestFee}(response.abiEncodedRequest);
```

5.  Calculate the Voting Round Number
    To determine the voting round in which the attestation request is processed, we query the `FlareSystemsManager` contract:

```solidity
       // Calculating roundId
       IFlareSystemsManager flareSystemsManager = ContractRegistry
           .getFlareSystemsManager();

       uint32 roundId = flareSystemsManager.getCurrentVotingEpochId();
       console.log(""roundId: %s\n"", Strings.toString(roundId));

```

This can be done within the existing broadcast or in a new one (as done in the demo repository for better code organization).

Again, we write the `roundId` to a file (`data/EVMTransaction_roundId.txt`).

## Wait for response

We wait for the round to finalize.
This takes no more than 145 seconds.

You can check if the request was submitted successfully on the [AttestationRequests](https://coston2-systems-explorer.flare.rocks/attestation-request) page on the Flare Systems Explorer website.
To check if the round has been finalized, go to [Finalizations](https://coston2-systems-explorer.flare.rocks/finalizations) page.

If you want to learn more about how the FDC protocol works, check [here](/fdc/overview).

## Prepare proof request

We prepare the proof request in a similar manner as in the step Prepare the request, by string concatenation.
We import two new variables from the `.env` file; the URL of a verifier server and the corresponding API key.

```solidity title=""scrip/fdcExample/EVMTransaction.s.sol""
string memory daLayerUrl = vm.envString(""COSTON2_DA_LAYER_URL"");
string memory apiKey = vm.envString(""X_API_KEY"");
```

Also, by repeatedly using the Foundry shortcode `vm.readLine`, we read the data, saved to a file in the previous step, to variables.

```solidity title=""scrip/fdcExample/EVMTransaction.s.sol""
string memory requestBytes = vm.readLine(
    string.concat(
        dirPath,
        attestationTypeName,
        ""_abiEncodedRequest"",
        "".txt""
    )
);
string memory votingRoundId = vm.readLine(
    string.concat(
        dirPath,
        attestationTypeName,
        ""_votingRoundId"",
        "".txt""
    )
);
```

The code is as follows.

```solidity title=""scrip/fdcExample/EVMTransaction.s.sol""
contract RetrieveDataAndProof is Script {
 using Surl for *;

 function run() external {
    string memory daLayerUrl = vm.envString(""COSTON2_DA_LAYER_URL"");
    string memory apiKey = vm.envString(""X_API_KEY"");

    string memory requestBytes = vm.readLine(
        string.concat(
            dirPath,
            attestationTypeName,
            ""_abiEncodedRequest"",
            "".txt""
        )
    );
    string memory votingRoundId = vm.readLine(
        string.concat(
            dirPath,
            attestationTypeName,
            ""_votingRoundId"",
            "".txt""
        )
    );

    console.log(""votingRoundId: %s\n"", votingRoundId);
    console.log(""requestBytes: %s\n"", requestBytes);

    string[] memory headers = Base.prepareHeaders(apiKey);
    string memory body = string.concat(
        '{""votingRoundId"":',
        votingRoundId,
        ',""requestBytes"":""',
        requestBytes,
        '""}'
    );
    console.log(""body: %s\n"", body);
    console.log(
        ""headers: %s"",
        string.concat(""{"", headers[0], "", "", headers[1]),
        ""}\n""
    );


 ...
 }
}
```

## Post proof request to DA Layer

We post the proof request to a chosen DA Layer provider server also with the same code as we did in the previous step.

```solidity title=""scrip/fdcExample/EVMTransaction.s.sol""
string memory url = string.concat(
 daLayerUrl,
 // ""api/v0/fdc/get-proof-round-id-bytes""
 ""api/v1/fdc/proof-by-request-round-raw""
);
console.log(""url: %s\n"", url);

(, bytes memory data) = Base.postAttestationRequest(url, headers, body);
```

Parsing the returned data requires the definition of an auxiliary `struct`.

{/* <!-- TODO rename after renaming --> */}

```solidity title=""scrip/fdcExample/Base.s.sol""
struct ParsableProof {
 bytes32 attestationType;
 bytes32[] proofs;
 bytes responseHex;
}
```

The field `attestationType` holds the UTF8 encoded hex string of the attestation type name, padded to 32 bytes.
Thus, it should match the value of the `attestationType` parameter in the Prepare the request step.
In our case, that value is `0x45564d5472616e73616374696f6e000000000000000000000000000000000000`.

The array `proofs` holds the Merkle proofs of our attestation request.

Lastly, `responseHex` is the ABI encoding of the chosen attestation type response struct.
In this case, it is the `IEVMTransaction.Response` struct.
We retrieve this data as follows.

```solidity title=""scrip/fdcExample/EVMTransaction.s.sol""
bytes memory dataJson = parseData(data);
ParsableProof memory proof = abi.decode(dataJson, (ParsableProof));

IEVMTransaction.Response memory proofResponse = abi.decode(
 proof.responseHex,
 (IEVMTransaction.Response)
);
```

## Verify proof

FDC optimizes on-chain storage costs by implementing a hybrid data verification system.
Instead of storing complete datasets on-chain, it stores only Merkle proofs, while maintaining the actual data through trusted off-chain providers.
This approach significantly reduces gas costs while preserving data integrity.

When requested, data providers supply the original data along with its corresponding Merkle proof.
The protocol verifies data authenticity by comparing the provided Merkle proof against the on-chain Merkle root.
A successful match confirms the data's integrity and authenticity within the FDC system.

While data verification is optional if you trust your data provider, FDC ensures transparency by making verification possible at any time.
This capability is crucial for maintaining system integrity and allowing users to independently verify data when needed, particularly in production environments.

FDC provides verification functionality through the `FdcVerification` contract.
To verify address validity, we first format our data using the `IEVMTransaction.Proof` struct, which contains both the Merkle proof and the response data.

```solidity title=""scrip/fdcExample/EVMTransaction.s.sol""
IEVMTransaction.Proof memory _proof = IEVMTransaction.Proof(
 proof.proofs,
 proofResponse
);
```

We then access the `FdcVerification` contract through the `ContractRegistry`, and feed it the proof.
If we proof is valid, the function `verifyEVMTransaction` will return `true`, otherwise `false`.
As before, we wrap the whole thing into a broadcast environment, using the `PRIVATE_KEY` variable from our `.env` file.

```solidity
uint256 deployerPrivateKey = vm.envUint(""PRIVATE_KEY"");
vm.startBroadcast(deployerPrivateKey);

bool isValid = ContractRegistry
 .getFdcVerification()
 .verifyEVMTransaction(proof);
console.log(""proof is valid: %s\n"", StringsBase.toString(isValid));

vm.stopBroadcast();
```

In actuality, we will only verify the proof within a deployed contract, which we will define in the next step.
What we will do here instead is, we will save the proof to a file so that it can be later loaded into a variable.
The code that does this is as follows.

```solidity title=""scrip/fdcExample/EVMTransaction.s.sol""
Base.writeToFile(
    dirPath,
    string.concat(attestationTypeName, ""_proof""),
    StringsBase.toHexString(abi.encode(_proof)),
    true
);
```

## Use the data

We will now define a simple contract, that will demonstrate how the data can be used onchain.
The contract will receive data and proof of an Ethereum transaction, and store all token transfers contained into an array of `TokenTransfer` structs.
It will do so only if the transaction is valid.

```solidity title=""src/fdcExample/EVMTransaction.sol""
struct TokenTransfer {
    address from;
    address to;
    uint256 value;
}
```

First, we define an interface that the contract will inherit from.
We do so, so that we may contact the contract later through a script.

```solidity title=""src/fdcExample/EVMTransaction.sol""
interface ITransferEventListener {
    function collectTransferEvents(
        IEVMTransaction.Proof calldata _transaction
    ) external;
}
```

The interface exposes the only function the script will call, `collectTransferEvents`.
We now define the contract as follows.

```solidity title=""src/fdcExample/EVMTransaction.sol""
contract TransferEventListener is ITransferEventListener {
    TokenTransfer[] public tokenTransfers;
    address public USDC_CONTRACT = 0x1c7D4B196Cb0C7B01d743Fbc6116a902379C7238; // USDC contract address on sepolia

    function isEVMTransactionProofValid(
        IEVMTransaction.Proof calldata transaction
    ) public view returns (bool) {
        // Use the library to get the verifier contract and verify that this transaction was proved by state connector
        IFdcVerification fdc = ContractRegistry.getFdcVerification();
        console.log(""transaction: %s\n"", FdcStrings.toJsonString(transaction));
        return true;
        //return fdc.verifyEVMTransaction(transaction);
    }

    function collectTransferEvents(
        IEVMTransaction.Proof calldata _transaction
    ) external {
        // 1. FDC Logic
        // Check that this EVMTransaction has indeed been confirmed by the FDC
        require(
            isEVMTransactionProofValid(_transaction),
            ""Invalid transaction proof""
        );

        // 2. Business logic
        // Go through all events
        for (
            uint256 i = 0;
            i < _transaction.data.responseBody.events.length;
            i++
        ) {
            // Get current event
            IEVMTransaction.Event memory _event = _transaction
                .data
                .responseBody
                .events[i];

            // Disregard events that are not from the USDC contract
            if (_event.emitterAddress != USDC_CONTRACT) {
                continue;
            }

            // Disregard non Transfer events
            if (
                _event.topics.length == 0 || // No topics
                // The topic0 doesn't match the Transfer event
                _event.topics[0] !=
                keccak256(abi.encodePacked(""Transfer(address,address,uint256)""))
            ) {
                continue;
            }

            // We now know that this is a Transfer event from the USDC contract - and therefore know how to decode topics and data
            // Topic 1 is the sender
            address sender = address(uint160(uint256(_event.topics[1])));
            // Topic 2 is the receiver
            address receiver = address(uint160(uint256(_event.topics[2])));
            // Data is the amount
            uint256 value = abi.decode(_event.data, (uint256));

            // Add the transfer to the list
            tokenTransfers.push(
                TokenTransfer({from: sender, to: receiver, value: value})
            );
        }
    }

    function getTokenTransfers()
        external
        view
        returns (TokenTransfer[] memory)
    {
        TokenTransfer[] memory result = new TokenTransfer[](
            tokenTransfers.length
        );
        for (uint256 i = 0; i < tokenTransfers.length; i++) {
            result[i] = tokenTransfers[i];
        }
        return result;
    }
}
```

We deploy the contract through a simple script.
The script creates a new `TransferEventListener` contract, and writes its address to a file (`data/EVMTransaction_listenerAddress.txt`).

```solidity title=""scrip/fdcExample/EVMTransaction.s.sol""
contract DeployContract is Script {
    function run() external {
        uint256 deployerPrivateKey = vm.envUint(""PRIVATE_KEY"");
        vm.startBroadcast(deployerPrivateKey);
        TransferEventListener listener = new TransferEventListener();
        address listenerAddress = address(listener);
        vm.stopBroadcast();

        Base.writeToFile(
            dirPath,
            string.concat(attestationTypeName, ""_listenerAddress""),
            StringsBase.toHexString(abi.encodePacked(listenerAddress)),
            true
        );
    }
}
```

We deploy the contract with the following console command.

```bash
forge script script/fdcExample/EVMTransaction.s.sol:DeployContract --private-key $PRIVATE_KEY --rpc-url $COSTON2_RPC_URL --etherscan-api-key $FLARE_API_KEY --broadcast --verify --ffi
```

Lastly, we define a script that interacts with the above contract.
It first reads the ABI encoded proof data, and the contract address, from files.
Then, it connects to the above contract at the saved address (this is why we require the interface).
With that, it is able to call the `getTokenTransfers` method of the contract.

```solidity title=""script/fdcExample/EVMTransaction.s.sol""
contract InteractWithContract is Script {
    function run() external {
        string memory addressString = vm.readLine(
            string.concat(
                dirPath,
                attestationTypeName,
                ""_listenerAddress"",
                "".txt""
            )
        );
        address listenerAddress = vm.parseAddress(addressString);
        string memory proofString = vm.readLine(
            string.concat(dirPath, attestationTypeName, ""_proof"", "".txt"")
        );
        bytes memory proofBytes = vm.parseBytes(proofString);
        IEVMTransaction.Proof memory proof = abi.decode(
            proofBytes,
            (IEVMTransaction.Proof)
        );
        uint256 deployerPrivateKey = vm.envUint(""PRIVATE_KEY"");
        vm.startBroadcast(deployerPrivateKey);
        ITransferEventListener listener = ITransferEventListener(
            listenerAddress
        );
        console.logAddress(address(listener));
        listener.collectTransferEvents(proof);
        vm.stopBroadcast();
    }
}
```

We run this script with the console command:

```bash
forge script script/fdcExample/EVMTransaction.s.sol:InteractWithContract --private-key $PRIVATE_KEY --rpc-url $COSTON2_RPC_URL --etherscan-api-key $FLARE_API_KEY --broadcast --ffi

```",2025-03-08 01:27:14
create-attestation-type.mdx,"title: Create Attestation Type
authors: [lukaavbreht, dineshpinto]
description: Learn how to create a new attestation type.
tags: [intermediate, fdc]
keywords: [intermediate, flare-data-connector, flare-network]
sidebar_position: 6
unlisted: true","import Remix from ""@site/src/components/remix"";
import CodeBlock from ""@theme/CodeBlock"";
import ITypeTemplate from ""!!raw-loader!/examples/developer-hub-solidity/ITypeTemplate.sol"";

This guide is for developers who want to extend FDC by creating a new attestation type. In this guide, you will learn how to:

- Setup a new attestation type definition in Solidity.

- Generate a attestation type verifier server in TypeScript with controllers and services.

- Create an onchain attestation verifier contract in Solidity.

## Prerequisites

Ensure you have the following tools installed:

- [yarn](https://yarnpkg.com/)
- [Docker](https://www.docker.com)

## Setup type definition

1. **Clone and setup repository:**

   ```bash
   git clone https://github.com/flare-foundation/VerifierServerGenerator.git
   yarn
   ```

2. **Create a definition file:** In the root of the cloned repo a template definition file (`ITypeTemplate.sol.example`) is provided. Rename the file to `ICustomType.sol` and the interface defined within the file to to `ICustomType`. You can use any name in place of `CustomType` upto 32 ASCII characters.

   ```bash
   mkdir contracts/interfaces/types
   cp ICustomType.sol contracts/interfaces/types
   ```

   <details>
     <summary>Definition file template</summary>
     <CodeBlock language=""solidity"" title=""ITypeTemplate.sol.example"">
       {ITypeTemplate}
     </CodeBlock>
   </details>

3. **Modify `@custom` props:**

   - `@custom:name`: Rename to `@custom:CustomType`.
   - `@custom:supported`: Indicate the data source, currently supported sources - `BTC`, `DOGE` ,`XRP`, `FLR`, `SGB`, `ETH` and `WEB2`. A single type can support multiple data sources.
   - `@custom:verification`: Add instructions on how to construct a response from the request.
   - `@custom:lut`: Leave as default, this will be used later.

4. **Define request and response structs:** Define the inputs to the `RequestBody` and `ResponseBody` structs. All fields should be commented with `@param fieldName` as in the template.

## Generate verifier server

1. **Generate verifier server template:**

   ```bash
   yarn generate server -t ICustomType
   ```

   :::warning[Overwriting files]

   Any changes made to generated files in `server/ICustomType` are overwritten if you call
   `generate server`.
   :::

2. **Define data sources:**

   - **Single data source:** Change the source in the constructor of `ICustomType.service.ts` to the one specified in the type definition.
     Modify the `verifyRequest` function to match the verification rules defined by your attestation type.

   - **Multiple data sources:** Each source needs its own service and controllers.

     1. **Create services for each source:** In `ICustomType.service.ts` for each source, create a new class, e.g. `<SourceID>ICustomTypeVerifierService`, that implements `verifyRequest` function for the source.

     2. **Create controllers for each source:** In `ICustomType.controller.ts` for each source, create a new class, e.g. `<SourceID>ICustomTypeVerifierController`, and set the type of verifierService to the one created for this type:

        `@ApiTags('ICustomType')` ‚Üí `@ApiTags('ICustomType', '<sourceID>')`

        `@Controller('ICustomType')` ‚Üí `@Controller('<sourceID>/ICustomType')`.

     3. **Add services and controllers to module:** In `ICustomType.module.ts`, add all new services and controllers to the respective arrays.

3. **Generate Dockerfile:** Run the following command to create a Dockerfile inside `server/ICustomType/` that prepares the server to be run inside a Docker container.

   ```bash
   yarn build
   ```

4. **Build server image:** Run the following to build an image for `ICustomType`

   ```bash
   docker build -t library/verifier-indexer-api-CustomType -f server/ICustomType/Dockerfile .
   ```

5. **Start server:** Run the following to start the server and expose port `<PORT>`

   ```bash
   docker run --rm --publish <PORT>:8000  library/verifier-indexer-api-CustomType
   ```

## Create verifier contract

:::warning[In production]

In production use, the verifier contract should validate the response with proof against the Merkle root stored on the [`Relay`](/network/fsp/solidity-reference/IRelay) contract.

:::

After completing the last steps a mock verification contract is generated with a `verifyCustomType` method that accepts an attestation response with Merkle proof (see the `Proof` struct in `ICustomType.sol`) and always confirms it.",2025-03-08 01:27:14
payment.mdx,"title: Payment
description: Information about a transaction on an external chain that is classified as a native currency payment.
keywords: [fdc, oracle, flare-data-connector, flare-network]
sidebar_position: 5","import StandardAddressHash from ""./_standard_address_hash.mdx"";
import StandardPaymentReference from ""./_standard_payment_reference.mdx"";
import TransactionSuccessStatus from ""./_transaction_success_status.mdx"";
import Finality from ""./_finality.mdx"";
import IPayment from ""../reference/IPayment.mdx"";

Information about a transaction on an external chain that is classified as a **native currency payment**.
Each supported blockchain specifies how a payment transaction should be formatted to be provable using this attestation type. These provable payments mimic traditional banking transactions where entity A sends a native currency to entity B, with an optional payment reference.

## Supported chains

- `BTC` (Bitcoin)
- `DOGE` (Dogecoin)
- `XRP` (XRP Ledger)
- Test networks: `testBTC` (Bitcoin Testnet v3), `testDOGE`, `testXRP`

## Request

| Field           | Solidity Type | Description                                                                                                                               |
| --------------- | ------------- | ----------------------------------------------------------------------------------------------------------------------------------------- |
| `transactionId` | `bytes32`     | Unique ID of the payment transaction.                                                                                                     |
| `inUtxo`        | `uint256`     | For UTXO-based chains, this is the index of the transaction input associated with the source address. Set to `0` for non-UTXO chains.     |
| `utxo`          | `uint256`     | For UTXO-based chains, this is the index of the transaction output associated with the receiving address. Set to `0` for non-UTXO chains. |

## Response

| Field                          | Solidity Type | Description                                                                                                                    |
| ------------------------------ | ------------- | ------------------------------------------------------------------------------------------------------------------------------ |
| `blockNumber`                  | `uint64`      | The block number in which the transaction is included.                                                                         |
| `blockTimestamp`               | `uint64`      | The timestamp of the block containing the transaction.                                                                         |
| `sourceAddressHash`            | `bytes32`     | Standardized address hash of the source address.                                                                               |
| `sourceAddressesRoot`          | `bytes32`     | The root of the Merkle tree of the source addresses.                                                                           |
| `receivingAddressHash`         | `bytes32`     | Standardized address hash of the receiving address. Returns a zero 32-byte string if the transaction status is not successful. |
| `intendedReceivingAddressHash` | `bytes32`     | Standardized address hash of the intended receiving address if the transaction failed.                                         |
| `spentAmount`                  | `int256`      | Amount (in minimal units) spent by the source address.                                                                         |
| `intendedSpentAmount`          | `int256`      | Intended amount (in minimal units) to be spent by the source address, relevant if the transaction status is unsuccessful.      |
| `receivedAmount`               | `int256`      | Amount (in minimal units) received by the receiving address.                                                                   |
| `intendedReceivedAmount`       | `int256`      | Intended amount (in minimal units) to be received by the receiving address if the transaction failed.                          |
| `standardPaymentReference`     | `bytes32`     | [Standard payment reference](#standard-payment-reference).                                                                     |
| `oneToOne`                     | `bool`        | Indicates if the transaction involves only one source and one receiver.                                                        |
| `status`                       | `uint8`       | [Transaction success status](#transaction-success-status).                                                                     |

:::warning[Standard Payment Reference]

If a transaction has no `standardPaymentReference`, it is set to default value, thus, zero value reference should be used with caution.

:::

## Verification Process

1. The transaction identified by `transactionId` is fetched from the relevant blockchain node or indexer.
2. If the transaction cannot be retrieved or is in a block with insufficient [confirmations](#finality), the attestation request is rejected.
3. Once the transaction data is fetched, a [payment summary](#payment-summary) is computed according to the chain-specific rules.
   - If the payment summary is successfully generated, the response is populated using this data.
   - If the summary cannot be computed, the attestation request is rejected.
4. The fields `blockNumber` and `blockTimestamp` are extracted from the block data if they are not directly available in the transaction data.
   - For **Bitcoin** and **Dogecoin**, the `blockTimestamp` is derived from the **mediantime** of the block.
   - For **XRPL**, the `blockTimestamp` is derived from the **close time** of the ledger, converted to UNIX time.

:::note[Lowest used timestamp]

For the `lowestUsedTimestamp` parameter, the **`blockTimestamp`** of the transaction is used.

:::

## Payment Summary

A **payment summary** consolidates all relevant data about a transaction that represents a payment. This is particularly focused on payments between one source account (address) and one target account.

- **UTXO Blockchains (e.g., BTC, DOGE)**: Payments can aggregate inputs from multiple addresses and distribute them to multiple outputs. The summary here is computed based on specified input and output indices that identify addresses of interest.
- **XRPL**: Supports various transaction types, but a payment summary is only fully calculated for transactions of type `Payment`.

### Structure

The summary includes the fields detailed in the table below.
The interpretation of certain fields may vary based on the blockchain.
Chain-specific explanations are provided in the sections that follow.

| Field                      | Description                                                                           |
| -------------------------- | ------------------------------------------------------------------------------------- |
| `transactionId`            | The unique identifier of the transaction.                                             |
| `transactionStatus`        | The [success status](#transaction-success-status) of the transaction.                 |
| `standardPaymentReference` | A reference defined in the [standard payment reference](#standard-payment-reference). |
| `oneToOne`                 | Indicates if the transaction involves a single sender and a single receiver.          |
| `sourceAddress`            | The originating address involved in the transaction.                                  |
| `sourceAddressesRoot`      | The root of the Merkle tree of the source addresses.                                  |
| `spentAmount`              | The total amount spent by the source address.                                         |
| `intendedSourceAmount`     | The expected amount intended to be sent from the source address.                      |
| `receivingAddress`         | The target address receiving the payment.                                             |
| `intendedReceivingAddress` | The expected target address intended to receive the payment.                          |
| `receivedAmount`           | The actual amount received by the receiving address.                                  |
| `intendedReceivingAmount`  | The expected amount intended to be received.                                          |

:::note

- **Standard Address Hashes**: [Standard address hashes](#standard-address-hash) can be derived from addresses.
- If `transactionStatus` is not `SUCCESS`, the `receivingAddress` is set to an empty string, and its hash defaults to a zeroed 32-byte string.
- **Standard Addresses Root** is the root of the Merkle tree build on double keccak256 hashes of the all source addresses of the transaction.

:::

### UTXO chains (Bitcoin and Dogecoin)

The payment summary for Bitcoin and Dogecoin is derived using specified indices for a transaction input and output.

- **Conditions**:
  - If the specified input or output does not exist, or lacks an address (e.g., outputs using `OP_RETURN`), no summary is generated.
  - Coinbase transactions are not summarized.
- **Data Sources**:
  - For Bitcoin, all transaction details are retrieved using the `getrawtransaction` endpoint (verbosity 2) and `getblock`. This requires a Bitcoin node version ‚â• 25.0.
  - For Dogecoin, since `getrawtransaction` with verbosity 2 is not supported, alternative methods must be used to access input transaction data.

| Field                      | Description                                                                                                                                     |
| -------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------- |
| `transactionId`            | The transaction ID (`txid`). For SegWit transactions, this differs from `hash`.                                                                 |
| `oneToOne`                 | `true` if only `sourceAddress` is present in inputs, and outputs include only `receivingAddress`, `sourceAddress` (for change), or `OP_RETURN`. |
| `sourceAddress`            | Address of the specified input.                                                                                                                 |
| `spentAmount`              | Total value of all inputs with `sourceAddress` minus total value of all outputs to `sourceAddress`.                                             |
| `intendedSourceAmount`     | Same as `spentAmount`.                                                                                                                          |
| `receivingAddress`         | Address of the specified output.                                                                                                                |
| `intendedReceivingAddress` | Always matches `receivingAddress`.                                                                                                              |
| `receivedAmount`           | Total value of outputs to `receivingAddress` minus total value of inputs from `receivingAddress`.                                               |
| `intendedReceivingAmount`  | Same as `receivedAmount`.                                                                                                                       |

### Account-based chains (XRPL)

The payment summary on XRPL is applicable only for transactions of type `Payment`.

- **Conditions**:
  - Only `Payment` transactions are summarized; other transaction types are ignored.
  - A successful payment has exactly one sender and at most one receiver. If unsuccessful, no receiver is recorded.
- **Data Sources**:
  - Transaction details are obtained via the [`tx`](https://xrpl.org/tx.html) method.
  - Changes made by the transaction are recorded in the `meta` field (or `metaData` if fetched via the `ledger` method) under `AffectedNodes`. Balance changes are found within `ModifiedNodes`, by comparing `FinalFields` and `PreviousFields`.

| Field                      | Description                                                                                                                                |
| -------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------ |
| `transactionId`            | Transaction hash found in the `hash` field.                                                                                                |
| `oneToOne`                 | Always `true`, as each `Payment` transaction has exactly one sender and at most one receiver.                                              |
| `sourceAddress`            | Address that sent the payment, reducing its balance.                                                                                       |
| `spentAmount`              | Amount by which `sourceAddress`'s balance was reduced.                                                                                     |
| `intendedSourceAmount`     | Calculated as `Amount + Fee`. If `transactionStatus` is `SUCCESS`, it matches `spentAmount`.                                               |
| `receivingAddress`         | Address that received the payment. If unsuccessful, this is an empty string.                                                               |
| `intendedReceivingAddress` | Address specified in the `Destination` field.                                                                                              |
| `receivedAmount`           | Amount by which the `receivingAddress`'s balance was increased. Can be zero if the transaction failed.                                     |
| `intendedReceivingAmount`  | Expected increase in `intendedReceivingAddress`'s balance if successful. Found in the `Amount` field. Matches `spentAmount` if successful. |

## Standard payment reference

<StandardPaymentReference />

## Transaction success status

<TransactionSuccessStatus />

## Standard address hash

<StandardAddressHash />

## Finality

<Finality />

## Contract interface

<IPayment />",2025-03-08 01:27:14
balance-decreasing-transaction.mdx,"title: BalanceDecreasingTransaction
description: Detects a transaction that either decreases the balance of a specified address.
keywords: [fdc, oracle, flare-data-connector, flare-network]
sidebar_position: 2","import Finality from ""./_finality.mdx"";
import StandardAddressHash from ""./_standard_address_hash.mdx"";
import TransactionSuccessStatus from ""./_transaction_success_status.mdx"";
import StandardPaymentReference from ""./_standard_payment_reference.mdx"";
import IBalanceDecreasingTransaction from ""../reference/IBalanceDecreasingTransaction.mdx"";

Information describing a transaction that either **decreases the balance** for a specified address.

A transaction is considered ‚Äúbalance decreasing‚Äù for the specified address if:

1. The balance **after the transaction** is lower than **before**.
2. The address is among the **signers** of the transaction (even if its balance is not reduced).

## Supported chains

- `BTC` (Bitcoin)
- `DOGE` (Dogecoin)
- `XRP` (XRP Ledger)
- Test networks: `testBTC` (Bitcoin Testnet v3), `testDOGE`, `testXRP`

## Request

| Field                    | Solidity Type | Description                                                     |
| ------------------------ | ------------- | --------------------------------------------------------------- |
| `transactionId`          | `bytes32`     | Unique ID of the transaction to be verified.                    |
| `sourceAddressIndicator` | `bytes32`     | Indicator of the address whose balance may have been decreased. |

## Response

| Field                      | Solidity Type | Description                                                            |
| -------------------------- | ------------- | ---------------------------------------------------------------------- |
| `blockNumber`              | `uint64`      | Block number containing the transaction.                               |
| `blockTimestamp`           | `uint64`      | Timestamp of the block containing the transaction.                     |
| `sourceAddressHash`        | `bytes32`     | Standard hash of the address indicated by `sourceAddressIndicator`.    |
| `spentAmount`              | `int256`      | Amount spent by the source address in minimal units (can be negative). |
| `standardPaymentReference` | `bytes32`     | Standardized payment reference of the transaction, if available.       |

:::warning[Standard Payment Reference]

If a transaction has no `standardPaymentReference`, it is set to default value, thus, zero value reference should be used with caution.

:::

## Verification process

1. The transaction identified by `transactionId` is fetched from the **source blockchain node** or a relevant indexer.
2. If the transaction cannot be fetched or is in a block with insufficient [confirmations](#finality), the attestation request is rejected.
3. Once the transaction is retrieved, the response fields are extracted if it qualifies as **balance decreasing** for the specified address.

The verification process is chain-specific and can be computed with a [balance decreasing summary](#balance-decreasing-summary), with details described below.

### UTXO chains (Bitcoin and Dogecoin)

- `sourceAddressIndicator`: Represents the index of the transaction input, formatted as a **0x-prefixed 32-byte string**.
  - If the specified input does not exist or lacks an associated address, the attestation request is rejected.
- `sourceAddress`: Address associated with the specified transaction input.
- `spentAmount`: Calculated as `Sum of all inputs with sourceAddress - Sum of all outputs with sourceAddress`. The value can be negative.
- `blockTimestamp`: The **mediantime** of the block.

### Account-based chains (XRPL)

- `sourceAddressIndicator`: The [standard address hash](#standard-address-hash) of the address in question.
  - If the indicated address is not among the transaction signers and its balance was not decreased, the attestation request is rejected.
- `spentAmount`: Difference between the balance of the address **after** and **before** the transaction. Can be negative.
- `blockTimestamp`: The **close_time** of the ledger, converted to Unix time.

:::note[Lowest used timestamp]

For the `lowestUsedTimestamp` parameter, the `blockTimestamp` of the transaction is used.

:::

## Balance decreasing summary

A balance-decreasing summary analyses a transaction that has decreased or could possibly decrease the balance of an account.

A balance-decreasing summary is calculated for a given transaction and source address indicator (`sourceAddressIndicator`).
The summary contains the fields as stated in the table below.
The interpretation of some fields is chain dependent.
Descriptions of these fields are left empty and are later explained for each specific blockchain.

For a given transaction and an address indicator, the balance-decreasing summary can only be calculate if the transaction is considered to be balance-decreasing for the indicated address
When implemented, the function that calculates the balance-decreasing summary
tries to calculate it.
If it is successful, it returns a success status and the summary itself.
If not, it returns an error status.

| Field                      | Description                                                |
| -------------------------- | ---------------------------------------------------------- |
| `transactionId`            | -                                                          |
| `transactionStatus`        | [Transaction success status](#transaction-success-status). |
| `sourceAddress`            | -                                                          |
| `spentAmount`              | -                                                          |
| `standardPaymentReference` | [Standard payment reference](#standard-payment-reference). |

The following are detailed descriptions of fields for each supported chain.

### Bitcoin and Dogecoin

For Bitcoin and Dogecoin, `sourceAddressIndicator` is the index of a transaction input (in hex zero padded on the left to 0x prefixed 32 bytes).
If the input with the given index does not exist or the indicated input does not have an address, no summary is made.
In particular, no summary is made for coinbase transactions.

| Field           | Description                                                                                                                        |
| --------------- | ---------------------------------------------------------------------------------------------------------------------------------- |
| `transactionId` | The transaction ID found in the field `txid`. For segwit transactions, this is not the same as _hash_.                             |
| `sourceAddress` | Address of the indicated input.                                                                                                    |
| `spentAmount`   | The sum of values of all inputs with `sourceAddress` minus the sum of values of all outputs with `sourceAddress`. Can be negative. |

### XRPL

For XRPL, `sourceAddressIndicator` is [standardAddressHash](#standard-address-hash) of the indicated address.
If the `sourceAddressIndicator` does not match any of the addresses who signed the transaction or whose balance was decreased by the transaction, the summary is not made.

| Field           |                                                                                                   |
| --------------- | ------------------------------------------------------------------------------------------------- |
| `transactionId` | Hash of the transaction found in the field `hash`.                                                |
| `sourceAddress` | Address whose [standardAddressHash](#standard-address-hash) matches the `sourceAddressIndicator`. |
| `spentAmount`   | The amount for which the balance of the `sourceAddress` has lowered. Can be negative.             |

## Standard payment reference

<StandardPaymentReference />

## Transaction success status

<TransactionSuccessStatus />

## Standard address hash

<StandardAddressHash />

## Finality

<Finality />

## Contract interface

<IBalanceDecreasingTransaction />",2025-03-08 01:27:14
json-api.mdx,"title: JsonApi
description: An attestation request that fetches data from the given url and then edits the information with a jq transformation.
keywords: [fdc, oracle, flare-data-connector, flare-network]
sidebar_position: 1","An attestation request that fetches data from the given url and then edits the information with a jq transformation.

## Supported sources

- `WEB2`
- test networks: `testWEB2`

## Request

| Field           | Solidity type | Description                                              |
| --------------- | ------------- | -------------------------------------------------------- |
| `url`           | `string`      | URL of the data source.                                  |
| `postprocessJq` | `string`      | JQ filter to postprocess the json received from the url. |
| `abi_signature` | `string`      | ABI signature of struct for encoding.                    |

## Response

| Field              | Solidity type | Description       |
| ------------------ | ------------- | ----------------- |
| `abi_encoded_data` | `bytes`       | ABI encoded data. |

## Lowest Used Timestamp

For `lowestUsedTimestamp`, `0xffffffffffffffff` ($2^{64}-1$ in hex) is used.

## Verification process

Query the URL with GET method.
If the query is unsuccessful or does not return a json, reject the request.

Apply the jq filter specified in the request to the received json.

ABI encode the filtered json with the abi_signature provided in the request and return it as abi_encoded_data.

`LowestUsedTimestamp` is unlimited.",2025-03-08 01:27:14
_transaction_success_status.mdx,,"Transactions on different blockchains have various success statuses.
Some blockchains may include transactions even if they failed to execute as intended.

| Status             | Code |
| ------------------ | ---- |
| `SUCCESS`          | 0    |
| `SENDER_FAILURE`   | 1    |
| `RECEIVER_FAILURE` | 2    |

**Bitcoin and Dogecoin**

It is not possible to include an unsuccessful transaction in a Bitcoin or Dogecoin block.
Hence, if a transaction is included on a confirmed block, its status is ""SUCCESS.""

**XRPL**

On XRPL, some transactions that failed (based on the reason for failure) can be included in a confirmed block.

- **`tesSUCCESS`**: Transaction successful.
- **`tec`-class codes**: Indicate reasons for failure, such as:
  - `tecDST_TAG_NEEDED`: Missing required destination tag.
  - `tecNO_DST`: Nonexistent or unfunded destination address.
  - `tecNO_PERMISSION`: Source address lacks permission to send funds.
",2025-03-08 01:27:14
_standard_payment_reference.mdx,,"A standard payment reference is defined as a 32-byte sequence that can be added to a payment transaction, in the same way that a payment reference is attached to a traditional banking transaction.

### Bitcoin and Dogecoin

- Uses `OP_RETURN` to store references.
- A transaction is considered to have a `standardPaymentReference` defined if it has:
  - Exactly one output UTXO with `OP_RETURN` script, and
  - The script is of the form `OP_RETURN <reference\>` or `6a<lengthOfReferenceInHex\><reference\> `in hex, where the length of the reference is 32 bytes.
- Then `0x<reference\>` is the `standardPaymentReference`.

### XRPL

- Uses the `memoData` field.
- A transaction has a `standardPaymentReference` if it has:
  - Exactly one [Memo](https://xrpl.org/transaction-common-fields.html#memos-field), and
  - The `memoData` of this field is a hex string that represents a byte sequence of exactly 32 bytes.
- This 32-byte sequence defines the `standardPaymentReference`.
",2025-03-08 01:27:14
evm-transaction.mdx,"title: EVMTransaction
description: Information about an EVM transaction, including details on associated events if specified.
keywords: [fdc, oracle, flare-data-connector, flare-network]
sidebar_position: 4","import IEVMTransaction from ""../reference/IEVMTransaction.mdx"";

Information about an Ethereum Virtual Machine (EVM) transaction, including details on associated events if specified.

## Supported chains

- `ETH` (Ethereum)
- `FLR` (Flare Mainnet)
- `SGB` (Songbird Canary-Network)
- Test networks: `testETH` (Ethereum Sepolia), `testFLR` (Flare Testnet Coston2), `testSGB` (Songbird Testnet Coston)

## Request

| Field                   | Solidity Type | Description                                                                                                                                                                                                                                                     |
| ----------------------- | ------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `transactionHash`       | `bytes32`     | The hash of the transaction.                                                                                                                                                                                                                                    |
| `requiredConfirmations` | `uint16`      | The number of confirmations required for the block containing the transaction to be considered final by the requestor.                                                                                                                                          |
| `provideInput`          | `bool`        | If set to `true`, the `input` data field of the transaction will be included in the response.                                                                                                                                                                   |
| `listEvents`            | `bool`        | If `true`, events specified by `logIndices` will be included in the response. If `false`, no events are included.                                                                                                                                               |
| `logIndices`            | `uint32[]`    | A list of event indices (`logIndex`) to be relayed if `listEvents` is `true`. Should be sorted by the requestor. Maximum of 50 indices allowed. An empty list indicates all events up to a maximum of 50. If `listEvents` is `false`, this field must be empty. |

:::note[Using Event Logs Correctly]

- Events (logs) are indexed at the **block level**, not at the transaction level.
- The contract using this attestation should define the order of event logs, and the requestor should ensure `logIndices` are sorted according to these specifications.

:::

## Response

The response fields align with EVM's [JSON-RPC API](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_gettransactionbyhash):

| Field              | Solidity Type | Description                                                                                           |
| ------------------ | ------------- | ----------------------------------------------------------------------------------------------------- |
| `blockNumber`      | `uint64`      | The block number in which the transaction is included.                                                |
| `timestamp`        | `uint64`      | The timestamp of the block in which the transaction is included.                                      |
| `sourceAddress`    | `address`     | The address (`from`) that signed the transaction.                                                     |
| `isDeployment`     | `bool`        | Indicates whether the transaction is a contract creation (`true`) or a regular transaction (`false`). |
| `receivingAddress` | `address`     | The address (`to`) receiving the transaction. Zero address if `isDeployment` is `true`.               |
| `value`            | `uint256`     | The value transferred in the transaction, in wei.                                                     |
| `input`            | `bytes`       | Transaction input data if `provideInput` is `true`; otherwise, returns `0x00`.                        |
| `status`           | `uint8`       | Transaction status: `1` for success, `0` for failure.                                                 |
| `events`           | `Event[]`     | An array of requested events if `listEvents` is `true`; otherwise, an empty array.                    |

### `Event` Struct

Each `Event` struct represents a log entry similar to EVM event logs:

| Field            | Solidity Type | Description                                                                                |
| ---------------- | ------------- | ------------------------------------------------------------------------------------------ |
| `logIndex`       | `uint32`      | The index of the event within the block.                                                   |
| `emitterAddress` | `address`     | The address of the contract that emitted the event.                                        |
| `topics`         | `bytes32[]`   | An array of up to four 32-byte strings representing indexed log arguments.                 |
| `data`           | `bytes`       | Non-indexed log data, concatenated as 32-byte strings. Must be at least 32 bytes long.     |
| `removed`        | `bool`        | `true` if the log was removed due to a chain reorganization; `false` if it is still valid. |

## Verification process

1. The function checks if the transaction with the given `transactionHash` is included in a block on the **main chain** with at least the specified `requiredConfirmations`.
2. If the block has insufficient confirmations or if the transaction is not found, the request is rejected.
3. If `listEvents` is enabled and an event specified by `logIndices` does not exist, the request is also rejected.
4. The specified data (transaction details, input data, and events) is retrieved and relayed based on the request parameters.

:::note[Event handling]

- Ensure `logIndices` are sorted as required by the consuming contract.
- If `logIndices` is not empty while `listEvents` is set to `false`, the request will be rejected.
- Events are capped at a maximum of **50 entries** to optimize performance.

:::

## Contract interface

<IEVMTransaction />",2025-03-08 01:27:14
_standard_address_hash.mdx,,"The **standard address hash** is defined as the `keccak256` hash of the standard address as a string:

```solidity
keccak256(standardAddress)
```

:::note[standard address]

If an address is case insensitive, the standard address is lowercase.
If an address is case sensitive, there is always only one (correct) form of the address.

:::

**Examples:**

| Chain              | Standard Address                             | Standard Address Hash                                                |
| ------------------ | -------------------------------------------- | -------------------------------------------------------------------- |
| Bitcoin (`Base58`) | `1FWQiwK27EnGXb6BiBMRLJvunJQZZPMcGd`         | `0x8f651b6990a4754c58fcb5c5a11f4d40f8ddfdeb0e4f67cdd06c27f8d7bcbe33` |
| Bitcoin (`Bech32`) | `bc1qrmvxmwgqfr5q4fvtvnxczwxwm966n53c4lxh4v` | `0xf75dc4b039ac72e037d67199bb92fa25db32b2210954df99637428473d47cedf` |
| Dogecoin           | `DL2H9FuaXsxivSs1sRtuJ8uryosyAj62XX`         | `0x51064c88c6b8e9d58b2abeae37a773bf89c9b279f8a05fa0ac0e81ebe13d2f4f` |
| XRPL               | `rDsbeomae4FXwgQTJp9Rs64Qg9vDiTCdBv`         | `0xa491aed10a1920ca31a85ff29e4bc410705d37d4dc9e690d4d500bcedfd8078f` |
",2025-03-08 01:27:14
_finality.mdx,,"Blockchains have varying confirmation depths to consider blocks as final.

| Chain    | `chainId` | Confirmations required | Confirmation time |
| -------- | --------- | ---------------------- | ----------------- |
| Bitcoin  | 0         | 6                      | ‚âà60 mins          |
| Dogecoin | 2         | 60                     | ‚âà60 mins          |
| XRPL     | 3         | 3                      | ‚âà12 seconds       |
",2025-03-08 01:27:14
address-validity.mdx,"title: AddressValidity
description: Assertion whether a given string represents a valid address on an external blockchain.
keywords: [fdc, oracle, flare-data-connector, flare-network]
sidebar_position: 1","import Addresses from ""./_addresses.mdx"";
import IAddressValidity from ""../reference/IAddressValidity.mdx"";

Assertion whether a given string represents a **valid address** on an external blockchain.

## Supported chains

- `BTC` (Bitcoin)
- `DOGE` (Dogecoin)
- `XRP` (XRP Ledger)
- Test networks: `testBTC` (Bitcoin Testnet v3), `testDOGE`, `testXRP`

## Request

| Field        | Solidity Type | Description                   |
| ------------ | ------------- | ----------------------------- |
| `addressStr` | `string`      | The address string to verify. |

## Response

| Field                 | Solidity Type | Description                                                                                     |
| --------------------- | ------------- | ----------------------------------------------------------------------------------------------- |
| `isValid`             | `bool`        | Indicates whether the provided address is valid.                                                |
| `standardAddress`     | `string`      | The standardized form of the validated address if `isValid`; otherwise, an empty string.        |
| `standardAddressHash` | `bytes32`     | The `keccak256` hash of the `standardAddress` if `isValid`; otherwise, a zero `bytes32` string. |

## Verification process

The address is verified against the validity criteria specific to the chain identified by `sourceId`. If the address meets all criteria:

1. `isValid` is set to `true`.
2. The `standardAddress` and its `standardAddressHash` are computed.

If the address is invalid:

- `isValid` is set to `false`.
- The `standardAddress` is empty and `standardAddressHash` is zero value.

:::note[Lowest used timestamp]

For the `lowestUsedTimestamp` parameter, the value `0xffffffffffffffff` (equivalent to $ 2^{64} - 1 $) in hexadecimal) is used as the default.

:::

## Address validity criteria

<Addresses />

## Contract interface

<IAddressValidity />",2025-03-08 01:27:14
referenced-payment-nonexistence.mdx,"title: ReferencedPaymentNonexistence
description: Assertion that a payment agreed to be completed by a certain deadline, has not been made.
keywords: [fdc, oracle, flare-data-connector, flare-network]
sidebar_position: 5","import StandardPaymentReference from ""./_standard_payment_reference.mdx"";
import Finality from ""./_finality.mdx"";
import IReferencedPaymentNonexistence from ""../reference/IReferencedPaymentNonexistence.mdx"";

Assertion that a specific payment, agreed upon to be completed by a certain deadline, has **not been made**. If confirmed, it shows that no transaction meeting the specified criteria (address, amount, reference) was found within the given block range.

This Information can be used, for example, to justify the liquidation of funds locked in a smart contract on Songbird if a payment is missed.

**Supported Chains**:

- `BTC` (Bitcoin)
- `DOGE` (Dogecoin)
- `XRP` (XRP Ledger)
- Test networks: `testBTC` (Bitcoin Testnet v3), `testDOGE`, `testXRP`

### Request

| Field                      | Solidity Type | Description                                                                   |
| -------------------------- | ------------- | ----------------------------------------------------------------------------- |
| `minimalBlockNumber`       | `uint64`      | The block number to start the search range.                                   |
| `deadlineBlockNumber`      | `uint64`      | The block number to include as the end of the search range.                   |
| `deadlineTimestamp`        | `uint64`      | The timestamp to include as the end of the search range.                      |
| `destinationAddressHash`   | `bytes32`     | The standard hash of the address where the payment was expected.              |
| `amount`                   | `uint256`     | The required payment amount in minimal units.                                 |
| `standardPaymentReference` | `bytes32`     | The standard payment reference associated with the payment. Must not be zero. |
| `checkSourceAddresses`     | `bool`        | If true, the source addresses root is checked.                                |
| `sourceAddressesRoot`      | `bytes32`     | The root of the Merkle tree of the source addresses.                          |

:::note

**Standard Addresses Root** is the root of the Merkle tree build on double keccak256 hashes of the all source addresses of the transaction.

:::

### Response

| Field                         | Solidity Type | Description                                                   |
| ----------------------------- | ------------- | ------------------------------------------------------------- |
| `minimalBlockTimestamp`       | `uint64`      | The timestamp of the block at `minimalBlockNumber`.           |
| `firstOverflowBlockNumber`    | `uint64`      | The block number immediately after the `deadlineBlockNumber`. |
| `firstOverflowBlockTimestamp` | `uint64`      | The timestamp of the `firstOverflowBlockNumber`.              |

- **`firstOverflowBlockNumber`**: This is the first block with a height greater than `deadlineBlockNumber` and a timestamp later than `deadlineTimestamp`.
- The search range includes blocks from `minimalBlockNumber` (inclusive) to `firstOverflowBlockNumber` (exclusive).

### Verification process

1. **Block Confirmation**:

   - If the `firstOverflowBlock` cannot be determined or lacks the required [number of confirmations](#finality), the request is rejected.
   - The request is also rejected if `firstOverflowBlockNumber` is less than or equal to `minimalBlockNumber`.

2. **Search Range**:

   - The search range includes blocks from `minimalBlockNumber` to `firstOverflowBlockNumber` (exclusive).
   - If the verifier does not have complete visibility of all blocks in this range, the request is rejected.

3. **Transaction Validation**:
   - The request is confirmed if **no transaction** meeting the specified criteria (address, source addresses root, amount, reference) is found within the specified block range.
   - The criteria and timestamp interpretation are specific to each chain.

The verification process is chain-specific, with details described below.

#### UTXO chains (Bitcoin and Dogecoin)

- **Transaction Criteria**:
  - The transaction **must not be a coinbase transaction**.
  - The transaction must include the specified [standard payment reference](#standard-payment-reference).
  - If `checkSourceAddresses` is set to true, the `sourceAddressesRoot` of the transaction must match the specified `sourceAddressesRoot`.
  - The sum of all output values sent to the specified address **minus** the sum of all input values from the same address must be **greater than the specified `amount`**.
    - Typically, the sum of input values for the specified address is zero.
- **Timestamp**: Uses the **mediantime** of the block.

#### Account-based chains (XRPL)

- **Transaction Criteria**:

  - The transaction must be of type **Payment**.
  - The transaction must include the specified [standard payment reference](#standard-payment-reference).
  - If `checkSourceAddresses` is set to true, the `sourceAddressesRoot` of the transaction must match the specified `sourceAddressesRoot`.
  - One of the following conditions must hold:
    - The transaction status is `SUCCESS` and the amount received by the specified address is greater than the specified `amount`.
    - The transaction status is `RECEIVER_FAILURE` and the specified address would have received an amount greater than the specified `amount` if the transaction had succeeded.

- **Timestamp**: Uses the **close_time** of the ledger, converted to UNIX time.

:::note[Lowest used timestamp]

For the `lowestUsedTimestamp` parameter, the value of `minimalBlockTimestamp` is used.

:::

## Standard payment reference

<StandardPaymentReference />

## Finality

<Finality />

## Contract interface

<IReferencedPaymentNonexistence />",2025-03-08 01:27:14
_addresses.mdx,,"### Bitcoin

An address on Bitcoin is derived from the locking script (`pkscript`).
Only standard locking scripts get assigned an address.
There are two formats of the Bitcoin addresses, `Base58` and `Bech32(m)`.
The format is determined based on the type of locking script.

#### `Base58`

Bitcoin's **Base58** format uses the following encoding dictionary:

```
123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz
```

##### Address Structure

Decoded addresses have the format:

```
<leadingByte><hash><checksum>
```

##### Components

- **`leadingByte`**:
  - On **mainnet**:
    - `00` for Pay-to-PubKey (p2pk) and Pay-to-PubKey-Hash (p2pkh)
    - `05` for Pay-to-Script-Hash (p2sh)
  - On **testnet**:
    - `6f` for p2pk and p2pkh
    - `c4` for p2sh
- **`hash`**: Represents either the public key, hash of the public key, or hash of a script.
- **`checksum`**: The first four bytes of the double SHA-256 hash of `<leadingByte><hash>`.

##### Validation Criteria

1. Address contains only characters from the Base58 dictionary.
2. Decoded hexadecimal form is exactly **25 bytes** long (address length varies between **26 to 34 characters**).
3. Starts with a valid `leadingByte`.
4. The checksum is valid and matches the first four bytes of the double SHA-256 hash.

##### Resources

- [Base58Check Encoding](https://en.bitcoin.it/wiki/Base58Check_encoding)
- [BIP-0013](https://en.bitcoin.it/wiki/BIP_0013)
- [BIP-0016](https://en.bitcoin.it/wiki/BIP_0016)

#### `Bech32(m)`

Bech32 is a newer address format using the character set:

```
qpzry9x8gf2tvdw0s3jn54khce6mua7l
```

##### Address Structure

A Bech32 address has the following components:

- **Human-Readable Part (HRP)**:
  - `bc` for **mainnet**
  - `tb` for **testnet**
- **Separator**: Always `1`
- **Data Part**:
  - The first character indicates the **witness version** (0-16).
  - The last six characters form a **checksum**.

The checksum differs based on the witness version:

- **Bech32** for witness version `0` ([BIP-0173](https://en.bitcoin.it/wiki/BIP_0173))
- **Bech32m** for witness versions `1` to `16` ([BIP-0350](https://en.bitcoin.it/wiki/BIP_0350))

##### Validation Criteria

1. Address contains only characters from the Bech32 dictionary.
2. All non-numeric characters must be either entirely uppercase or lowercase.
3. Starts with a valid HRP followed by the separator (`1`).
4. Length is between **14 to 74 characters**, with the length modulo 8 being **0, 3, or 5**.
   - For witness version `0`, length must be **42 or 62 characters**.
5. Checksum is validated based on the witness version.
6. Addresses with witness versions `2` and above are unsupported and invalid.

##### Resources

- [Bech32](https://en.bitcoin.it/wiki/Bech32)
- [SegWit](https://en.bitcoin.it/wiki/Segregated_Witness)
- [BIP-0141](https://en.bitcoin.it/wiki/BIP_0141)
- [BIP-0341](https://en.bitcoin.it/wiki/BIP_0341)
- [BIP-0350](https://en.bitcoin.it/wiki/BIP_0350)

### Dogecoin (`Base58`)

Dogecoin uses a **Base58** dictionary, identical to Bitcoin's:

```
123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz
```

#### Address Structure

Decoded addresses have the format:

```
<leadingByte><hash><checksum>
```

#### Components

- **`leadingByte`**:
  - On **mainnet**:
    - `1e` for p2pk and p2pkh
    - `16` for p2sh
  - On **testnet**:
    - `6f` for p2pk and p2pkh
    - `71` for p2sh
- **`hash`**: Represents either the public key, hash of the public key, or script hash.
- **`checksum`**: First four bytes of the double SHA-256 hash of `<leadingByte><hash>`.

#### Validation Criteria

1. Address contains only characters from the Base58 dictionary.
2. Length is **26 to 34 characters**. Decoded hex form is **25 bytes**.
3. Valid leading byte:
   - **Mainnet**: Starts with `D`, `A`, or `9`.
   - **Testnet**: Starts with `n`, `m`, or `2`.
4. The checksum is validated.

### XRPL (`Base58`)

The XRP Ledger uses a custom **Base58** dictionary:

```
rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz
```

#### Address Structure

Decoded to hexadecimal:

```
<leadingByte><publicKeyHash><checksum>
```

#### Components

- **`leadingByte`**:
  - On **mainnet**: `00` (addresses start with `r`).
- **`publicKeyHash`**: A **20-byte** hash of the public key.
- **`checksum`**: The first four bytes of the double SHA-256 hash of `<leadingByte><publicKeyHash>`.

#### Validation Criteria

1. Address contains only characters from the XRPL Base58 dictionary.
2. Length is **25 to 35 characters**. Decoded hex form is **25 bytes**.
3. Address starts with `r`.
4. The checksum is valid.

#### Resources

- [XRPL Base58 Encodings](https://xrpl.org/base58-encodings.html)
- [XRPL Addresses](https://xrpl.org/accounts.html#addresses)
",2025-03-08 01:27:14
confirmed-block-height-exists.mdx,"title: ConfirmedBlockHeightExists
description: Assertion whether a specified block number is confirmed.
keywords: [fdc, oracle, flare-data-connector, flare-network]
sidebar_position: 3","import Finality from ""./_finality.mdx"";
import IConfirmedBlockHeightExists from ""../reference/IConfirmedBlockHeightExists.mdx"";

Assertion whether a block with the specified `blockNumber` is **confirmed** with additional data to compute the **block production rate** within a given time window.

## Supported chains

- `BTC` (Bitcoin)
- `DOGE` (Dogecoin)
- `XRP` (XRP Ledger)
- Test networks: `testBTC` (Bitcoin Testnet v3), `testDOGE`, `testXRP`

## Request

| Field         | Solidity Type | Description                                                          |
| ------------- | ------------- | -------------------------------------------------------------------- |
| `blockNumber` | `uint64`      | The block number to confirm.                                         |
| `queryWindow` | `uint64`      | The time period (in seconds) to calculate the block production rate. |

## Response

| Field                             | Solidity Type | Description                                                                                              |
| --------------------------------- | ------------- | -------------------------------------------------------------------------------------------------------- |
| `blockTimestamp`                  | `uint64`      | The timestamp of the block at `blockNumber`.                                                             |
| `numberOfConfirmations`           | `uint64`      | The required number of confirmations for the block to be considered confirmed (chain-specific).          |
| `lowestQueryWindowBlockNumber`    | `uint64`      | The block number of the latest block with a timestamp strictly less than `blockTimestamp - queryWindow`. |
| `lowestQueryWindowBlockTimestamp` | `uint64`      | The timestamp of the block at `lowestQueryWindowBlockNumber`.                                            |

## Verification process

1. The function checks if the block with `blockNumber` is confirmed by at least the required `numberOfConfirmations` for the specified chain.
   - If the block does not meet this requirement, the request is rejected.
   - A block at the tip of the chain has exactly **1 confirmation**.
2. The lowestQueryWindowBlock` is identified, and its block number and timestamp are extracted.
3. The required confirmations are defined based on chain-specific [finality](#finality).
4. The returned `timestamp` is:
   - `mediantime` for Bitcoin and Dogecoin.
   - `close_time` for XRPL.

:::note[Lowest used timestamp]

For the `lowestUsedTimestamp` parameter, the value of `lowestQueryWindowBlockTimestamp` is used.

:::

## Finality

<Finality />

## Contract interface

<IConfirmedBlockHeightExists />",2025-03-08 01:27:14
IFdcHub.md,"title: IFdcHub
sidebar_position: 2
description: Primary interface for interacting with FDC.","Primary interface for interacting with FDC.

Sourced from `IFdcHub.sol` on [GitHub](https://github.com/flare-foundation/flare-smart-contracts-v2/blob/main/contracts/userInterfaces/IFdcHub.sol).

## Functions

### fdcInflationConfigurations

The FDC inflation configurations contract.

```solidity
function fdcInflationConfigurations(
) external view returns (
    contract IFdcInflationConfigurations
);
```

### fdcRequestFeeConfigurations

The FDC request fee configurations contract.

```solidity
function fdcRequestFeeConfigurations(
) external view returns (
    contract IFdcRequestFeeConfigurations
);
```

### requestAttestation

Method to request an attestation.

```solidity
function requestAttestation(
    bytes _data
) external payable;
```

#### Parameters

- `_data`: ABI encoded attestation request

### requestsOffsetSeconds

The offset (in seconds) for the requests to be processed during the current voting round.

```solidity
function requestsOffsetSeconds(
) external view returns (
    uint8
);
```

## Events

### AttestationRequest

```solidity
event AttestationRequest(
    bytes data,
    uint256 fee
)
```

### InflationRewardsOffered

Event emitted when inflation rewards are offered.

```solidity
event InflationRewardsOffered(
    uint24 rewardEpochId,
    struct IFdcInflationConfigurations.FdcConfiguration[] fdcConfigurations,
    uint256 amount
)
```

### RequestsOffsetSet

```solidity
event RequestsOffsetSet(
    uint8 requestsOffsetSeconds
)
```",2025-03-08 01:27:14
IFdcVerification.md,"title: IFdcVerification
sidebar_position: 3
description: Interface for verifying FDC requests.","Interface for verifying FDC requests.

Sourced from `IFdcVerification.sol` on [GitHub](https://github.com/flare-foundation/flare-smart-contracts-v2/blob/main/contracts/userInterfaces/IFdcVerification.sol).

## Functions

### verifyAddressValidity

```solidity
function verifyAddressValidity(
    struct IAddressValidity.Proof _proof
) external view returns (
    bool _proved
);
```

### verifyBalanceDecreasingTransaction

```solidity
function verifyBalanceDecreasingTransaction(
    struct IBalanceDecreasingTransaction.Proof _proof
) external view returns (
    bool _proved
);
```

### verifyConfirmedBlockHeightExists

```solidity
function verifyConfirmedBlockHeightExists(
    struct IConfirmedBlockHeightExists.Proof _proof
) external view returns (
    bool _proved
);
```

### verifyEVMTransaction

```solidity
function verifyEVMTransaction(
    struct IEVMTransaction.Proof _proof
) external view returns (
    bool _proved
);
```

### verifyPayment

```solidity
function verifyPayment(
    struct IPayment.Proof _proof
) external view returns (
    bool _proved
);
```

### verifyReferencedPaymentNonexistence

```solidity
function verifyReferencedPaymentNonexistence(
    struct IReferencedPaymentNonexistence.Proof _proof
) external view returns (
    bool _proved
);
```",2025-03-08 01:27:14
IEVMTransaction.mdx,"title: IEVMTransaction
sidebar_position: 9
description: Relay a transaction from an EVM chain.","Sourced from `IEVMTransaction.sol` on [GitHub](https://github.com/flare-foundation/flare-smart-contracts-v2/blob/main/contracts/userInterfaces/fdc/IEVMTransaction.sol).

```solidity
// SPDX-License-Identifier: MIT
pragma solidity >=0.7.6 <0.9;

/**
 * @custom:name IEVMTransaction
 * @custom:id 0x06
 * @custom:supported ETH, FLR, SGB
 * @author Flare
 * @notice A relay of a transaction from an EVM chain.
 * This type is only relevant for EVM-compatible chains.
 * @custom:verification If a transaction with the `transactionId` is in a block on the main branch with
 * at least `requiredConfirmations`, the specified data is relayed.
 * If an indicated event does not exist, the request is rejected.
 * @custom:lut `timestamp`
 * @custom:lutlimit `0x41eb00`, `0x41eb00`, `0x41eb00`
 */
interface IEVMTransaction {
    /**
     * @notice Toplevel request
     * @param attestationType ID of the attestation type.
     * @param sourceId ID of the data source.
     * @param messageIntegrityCode `MessageIntegrityCode` that is derived from the expected response.
     * @param requestBody Data defining the request. Type (struct) and interpretation is
     * determined by the `attestationType`.
     */
    struct Request {
        bytes32 attestationType;
        bytes32 sourceId;
        bytes32 messageIntegrityCode;
        RequestBody requestBody;
    }

    /**
     * @notice Toplevel response
     * @param attestationType Extracted from the request.
     * @param sourceId Extracted from the request.
     * @param votingRound The ID of the State Connector round in which the request was considered.
     * @param lowestUsedTimestamp The lowest timestamp used to generate the response.
     * @param requestBody Extracted from the request.
     * @param responseBody Data defining the response. The verification rules for the construction
     * of the response body and the type are defined per specific `attestationType`.
     */
    struct Response {
        bytes32 attestationType;
        bytes32 sourceId;
        uint64 votingRound;
        uint64 lowestUsedTimestamp;
        RequestBody requestBody;
        ResponseBody responseBody;
    }

    /**
     * @notice Toplevel proof
     * @param merkleProof Merkle proof corresponding to the attestation response.
     * @param data Attestation response.
     */
    struct Proof {
        bytes32[] merkleProof;
        Response data;
    }

    /**
     * @notice Request body for EVM transaction attestation type
     * @custom:below Note that events (logs) are indexed in block not in each transaction.
     * The contract that uses the attestation should specify the order of event logs as needed and the requestor should
     * sort `logIndices` with respect to the set specifications.
     * If possible, the contact should require one `logIndex`.
     * @param transactionHash Hash of the transaction(transactionHash).
     * @param requiredConfirmations The height at which a block is considered confirmed by the requestor.
     * @param provideInput If true, ""input"" field is included in the response.
     * @param listEvents If true, events indicated by `logIndices` are included in the response.
     * Otherwise, no events are included in the response.
     * @param logIndices If `listEvents` is `false`, this should be an empty list, otherwise,
     * the request is rejected. If `listEvents` is `true`, this is the list of indices (logIndex)
     * of the events to be relayed (sorted by the requestor). The array should contain at most 50 indices.
     * If empty, it indicates all events in order capped by 50.
     */
    struct RequestBody {
        bytes32 transactionHash;
        uint16 requiredConfirmations;
        bool provideInput;
        bool listEvents;
        uint32[] logIndices;
    }

    /**
     * @notice Response body for EVM transaction attestation type
     * @custom:below The fields are in line with transaction provided by EVM node.
     * @param blockNumber Number of the block in which the transaction is included.
     * @param timestamp Timestamp of the block in which the transaction is included.
     * @param sourceAddress The address (from) that signed the transaction.
     * @param isDeployment Indicate whether it is a contract creation transaction.
     * @param receivingAddress The address (to) of the receiver of the initial transaction.
     * Zero address if `isDeployment` is `true`.
     * @param value The value transferred by the initial transaction in wei.
     * @param input If `provideInput`, this is the data send along with the initial transaction.
     * Otherwise it is the default value `0x00`.
     * @param status Status of the transaction 1 - success, 0 - failure.
     * @param events If `listEvents` is `true`, an array of the requested events.
     * Sorted by the logIndex in the same order as `logIndices`. Otherwise, an empty array.
     */
    struct ResponseBody {
        uint64 blockNumber;
        uint64 timestamp;
        address sourceAddress;
        bool isDeployment;
        address receivingAddress;
        uint256 value;
        bytes input;
        uint8 status;
        Event[] events;
    }

    /**
     * @notice Event log record
     * @custom:above An `Event` is a struct with the following fields:
     * @custom:below The fields are in line with EVM event logs.
     * @param logIndex The consecutive number of the event in block.
     * @param emitterAddress The address of the contract that emitted the event.
     * @param topics An array of up to four 32-byte strings of indexed log arguments.
     * @param data Concatenated 32-byte strings of non-indexed log arguments. At least 32 bytes long.
     * @param removed It is `true` if the log was removed due to a chain reorganization
     * and `false` if it is a valid log.
     */
    struct Event {
        uint32 logIndex;
        address emitterAddress;
        bytes32[] topics;
        bytes data;
        bool removed;
    }
}
```",2025-03-08 01:27:14
IPayment.mdx,"title: IPayment
sidebar_position: 10
description: Relay a transaction in native currency.","Sourced from `IPayment.sol` on [GitHub](https://github.com/flare-foundation/flare-smart-contracts-v2/blob/main/contracts/userInterfaces/fdc/IPayment.sol).

```solidity
// SPDX-License-Identifier: MIT
pragma solidity >=0.7.6 <0.9;

/**
 * @custom:name IPayment
 * @custom:id 0x01
 * @custom:supported BTC, DOGE, XRP
 * @author Flare
 * @notice A relay of a transaction on an external chain that is considered a payment in a native currency.
 * Various blockchains support different types of native payments. For each blockchain, it is specified how a payment
 * transaction should be formed to be provable by this attestation type.
 * The provable payments emulate traditional banking payments from entity A to entity B in native currency with an
 * optional payment reference.
 * @custom:verification The transaction with `transactionId` is fetched from the API of the blockchain node or
 * relevant indexer.
 * If the transaction cannot be fetched or the transaction is in a block that does not have a sufficient
 * [number of confirmations](/specs/attestations/configs.md#finalityconfirmation), the attestation request is rejected.
 *
 * Once the transaction is received, the payment summary is computed according to the rules for the source chain.
 * If the summary is successfully calculated, the response is assembled from the summary.
 * `blockNumber` and `blockTimestamp` are retrieved from the block if they are not included in the transaction data.
 * For Bitcoin and Dogecoin, `blockTimestamp` is mediantime of the block.
 * For XRPL, `blockTimestamp` is close time of the ledger converted to UNIX time.
 *
 * If the summary is not successfully calculated, the attestation request is rejected.
 * @custom:lut `blockTimestamp`
 * @custom:lutlimit `0x127500`, `0x127500`, `0x127500`
 */
interface IPayment {
    /**
     * @notice Toplevel request
     * @param attestationType ID of the attestation type.
     * @param sourceId ID of the data source.
     * @param messageIntegrityCode `MessageIntegrityCode` that is derived from the expected response.
     * @param requestBody Data defining the request. Type (struct) and interpretation is determined
     * by the `attestationType`.
     */
    struct Request {
        bytes32 attestationType;
        bytes32 sourceId;
        bytes32 messageIntegrityCode;
        RequestBody requestBody;
    }

    /**
     * @notice Toplevel response
     * @param attestationType Extracted from the request.
     * @param sourceId Extracted from the request.
     * @param votingRound The ID of the State Connector round in which the request was considered.
     * @param lowestUsedTimestamp The lowest timestamp used to generate the response.
     * @param requestBody Extracted from the request.
     * @param responseBody Data defining the response. The verification rules for the construction
     * of the response body and the type are defined per specific `attestationType`.
     */
    struct Response {
        bytes32 attestationType;
        bytes32 sourceId;
        uint64 votingRound;
        uint64 lowestUsedTimestamp;
        RequestBody requestBody;
        ResponseBody responseBody;
    }

    /**
     * @notice Toplevel proof
     * @param merkleProof Merkle proof corresponding to the attestation response.
     * @param data Attestation response.
     */
    struct Proof {
        bytes32[] merkleProof;
        Response data;
    }

    /**
     * @notice Request body for Payment attestation type
     * @param transactionId ID of the payment transaction.
     * @param inUtxo For UTXO chains, this is the index of the transaction input with source address.
     * Always 0 for the non-utxo chains.
     * @param utxo For UTXO chains, this is the index of the transaction output with receiving address.
     * Always 0 for the non-utxo chains.
     */
    struct RequestBody {
        bytes32 transactionId;
        uint256 inUtxo;
        uint256 utxo;
    }

    /**
     * @notice Response body for Payment attestation type
     * @param blockNumber Number of the block in which the transaction is included.
     * @param blockTimestamp The timestamp of the block in which the transaction is included.
     * @param sourceAddressHash Standard address hash of the source address.
     * @param sourceAddressesRoot The root of the Merkle tree of the source addresses.
     * @param receivingAddressHash Standard address hash of the receiving address.
     * The zero 32-byte string if there is no receivingAddress (if `status` is not success).
     * @param intendedReceivingAddressHash Standard address hash of the intended receiving address.
     * Relevant if the transaction is unsuccessful.
     * @param spentAmount Amount in minimal units spent by the source address.
     * @param intendedSpentAmount Amount in minimal units to be spent by the source address.
     * Relevant if the transaction status is unsuccessful.
     * @param receivedAmount Amount in minimal units received by the receiving address.
     * @param intendedReceivedAmount Amount in minimal units intended to be received by the receiving address.
     * Relevant if the transaction is unsuccessful.
     * @param standardPaymentReference Standard payment reference of the transaction.
     * @param oneToOne Indicator whether only one source and one receiver are involved in the transaction.
     * @param status Success status of the transaction: 0 - success, 1 - failed by sender's fault,
     * 2 - failed by receiver's fault.
     */
    struct ResponseBody {
        uint64 blockNumber;
        uint64 blockTimestamp;
        bytes32 sourceAddressHash;
        bytes32 sourceAddressesRoot;
        bytes32 receivingAddressHash;
        bytes32 intendedReceivingAddressHash;
        int256 spentAmount;
        int256 intendedSpentAmount;
        int256 receivedAmount;
        int256 intendedReceivedAmount;
        bytes32 standardPaymentReference;
        bool oneToOne;
        uint8 status;
    }
}
```",2025-03-08 01:27:14
data-availability-api.mdx,"sidebar_label: Data Availability API
hide_title: true
description: OpenAPI specification for Data Availability API.
sidebar_position: 1","import OpenApiDoc from ""@site/src/components/OpenApiDoc/OpenApiDoc"";

<OpenApiDoc url=""openapi/data-availability-api.yaml"" />",2025-03-08 01:27:14
IReferencedPaymentNonexistence.mdx,"title: IReferencedPaymentNonexistence
sidebar_position: 11
description: Assert whether an agreed-upon payment has not been made.","Sourced from `IReferencedPaymentNonexistence.sol` on [GitHub](https://github.com/flare-foundation/flare-smart-contracts-v2/blob/main/contracts/userInterfaces/fdc/IReferencedPaymentNonexistence.sol).

```solidity
// SPDX-License-Identifier: MIT
pragma solidity >=0.7.6 <0.9;

/**
 * @custom:name IReferencedPaymentNonexistence
 * @custom:id 0x04
 * @custom:supported BTC, DOGE, XRP
 * @author Flare
 * @notice Assertion that an agreed-upon payment has not been made by a certain deadline.
 * A confirmed request shows that a transaction meeting certain criteria (address, amount, reference)
 * did not appear in the specified block range.
 *
 *
 * This type of attestation can be used to e.g. provide grounds to liquidate funds locked by a smart
 * contract on Flare when a payment is missed.
 *
 * @custom:verification If `firstOverflowBlock` cannot be determined or does not have a sufficient
 * number of confirmations, the attestation request is rejected.
 * If `firstOverflowBlockNumber` is higher or equal to `minimalBlockNumber`, the request is rejected.
 * The search range are blocks between heights including `minimalBlockNumber` and excluding `firstOverflowBlockNumber`.
 * If the verifier does not have a view of all blocks from `minimalBlockNumber` to `firstOverflowBlockNumber`,
 * the attestation request is rejected.
 *
 * The request is confirmed if no transaction meeting the specified criteria is found in the search range.
 * The criteria and timestamp are chain specific.
 * ### UTXO (Bitcoin and Dogecoin)
 *
 *
 * Criteria for the transaction:
 *
 *
 * - It is not coinbase transaction.
 * - The transaction has the specified standardPaymentReference.
 * - The sum of values of all outputs with the specified address minus the sum of values of all inputs with
 * the specified address is greater than `amount` (in practice the sum of all values of the inputs with the
 * specified address is zero).
 *
 *
 * Timestamp is `mediantime`.
 * ### XRPL
 *
 *
 *
 * Criteria for the transaction:
 * - The transaction is of type payment.
 * - The transaction has the specified standardPaymentReference,
 * - One of the following is true:
 *   - Transaction status is `SUCCESS` and the amount received by the specified destination address is
 * greater than the specified `value`.
 *   - Transaction status is `RECEIVER_FAILURE` and the specified destination address would receive an
 * amount greater than the specified `value` had the transaction been successful.
 *
 *
 * Timestamp is `close_time` converted to UNIX time.
 *
 * @custom:lut `minimalBlockTimestamp`
 * @custom:lutlimit `0x127500`, `0x127500`, `0x127500`
 */
interface IReferencedPaymentNonexistence {
    /**
     * @notice Toplevel request
     * @param attestationType ID of the attestation type.
     * @param sourceId ID of the data source.
     * @param messageIntegrityCode `MessageIntegrityCode` that is derived from the expected response as defined.
     * @param requestBody Data defining the request. Type and interpretation is determined by the `attestationType`.
     */
    struct Request {
        bytes32 attestationType;
        bytes32 sourceId;
        bytes32 messageIntegrityCode;
        RequestBody requestBody;
    }

    /**
     * @notice Toplevel response
     * @param attestationType Extracted from the request.
     * @param sourceId Extracted from the request.
     * @param votingRound The ID of the State Connector round in which the request was considered.
     * @param lowestUsedTimestamp The lowest timestamp used to generate the response.
     * @param requestBody Extracted from the request.
     * @param responseBody Data defining the response. The verification rules for the construction of the response
     * body and the type are defined per specific `attestationType`.
     */
    struct Response {
        bytes32 attestationType;
        bytes32 sourceId;
        uint64 votingRound;
        uint64 lowestUsedTimestamp;
        RequestBody requestBody;
        ResponseBody responseBody;
    }

    /**
     * @notice Toplevel proof
     * @param merkleProof Merkle proof corresponding to the attestation response.
     * @param data Attestation response.
     */
    struct Proof {
        bytes32[] merkleProof;
        Response data;
    }

    /**
     * @notice Request body for ReferencePaymentNonexistence attestation type
     * @param minimalBlockNumber The start block of the search range.
     * @param deadlineBlockNumber The blockNumber to be included in the search range.
     * @param deadlineTimestamp The timestamp to be included in the search range.
     * @param destinationAddressHash The standard address hash of the address to which the payment had to be done.
     * @param amount The requested amount in minimal units that had to be paid.
     * @param standardPaymentReference The requested standard payment reference.
     * @param checkSourceAddresses If true, the source address root is checked (only full match).
     * @param sourceAddressesRoot The root of the Merkle tree of the source addresses.
     * @custom:below The `standardPaymentReference` should not be zero (as a 32-byte sequence).
     */
    struct RequestBody {
        uint64 minimalBlockNumber;
        uint64 deadlineBlockNumber;
        uint64 deadlineTimestamp;
        bytes32 destinationAddressHash;
        uint256 amount;
        bytes32 standardPaymentReference;
        bool checkSourceAddresses;
        bytes32 sourceAddressesRoot;
    }

    /**
     * @notice Response body for ReferencePaymentNonexistence attestation type.
     * @param minimalBlockTimestamp The timestamp of the minimalBlock.
     * @param firstOverflowBlockNumber The height of the firstOverflowBlock.
     * @param firstOverflowBlockTimestamp The timestamp of the firstOverflowBlock.
     * @custom:below `firstOverflowBlock` is the first block that has block number higher than
     * `deadlineBlockNumber` and timestamp later than `deadlineTimestamp`.
     * The specified search range are blocks between heights including `minimalBlockNumber`
     * and excluding `firstOverflowBlockNumber`.
     */
    struct ResponseBody {
        uint64 minimalBlockTimestamp;
        uint64 firstOverflowBlockNumber;
        uint64 firstOverflowBlockTimestamp;
    }
}
```",2025-03-08 01:27:14
IBalanceDecreasingTransaction.mdx,"title: IBalanceDecreasingTransaction
sidebar_position: 7
description: Detect a transaction that decreases an address balance.","Sourced from `IBalanceDecreasingTransaction.sol` on [GitHub](https://github.com/flare-foundation/flare-smart-contracts-v2/blob/main/contracts/userInterfaces/fdc/IBalanceDecreasingTransaction.sol).

```solidity
// SPDX-License-Identifier: MIT
pragma solidity >=0.7.6 <0.9;

/**
 * @custom:name IBalanceDecreasingTransaction
 * @custom:id 0x02
 * @custom:supported BTC, DOGE, XRP
 * @author Flare
 * @notice A detection of a transaction that either decreases the balance for some address or is
 * signed by the source address.
 * Such an attestation could prove a violation of an agreement and therefore provides grounds to liquidate
 * some funds locked by a smart contract on Flare.
 *
 * A transaction is considered ‚Äúbalance decreasing‚Äù for the address, if the balance after the
 * transaction is lower than before or the address is among the signers of the transaction
 * (even if its balance is greater than before the transaction).
 * @custom:verification The transaction with `transactionId` is fetched from the API of the
 * source blockchain node or relevant indexer.
 * If the transaction cannot be fetched or the transaction is in a block that does not have a
 * sufficient number of confirmations, the attestation request is rejected.
 *
 * Once the transaction is received, the response fields are extracted if the transaction is balance
 * decreasing for the indicated address.
 * Some of the request and response fields are chain specific as described below.
 * The fields can be computed with the help of a balance decreasing summary.
 *
 * ### UTXO (Bitcoin and Dogecoin)
 *
 * - `sourceAddressIndicator` is the the index of the transaction input in hex padded to a 0x prefixed 32-byte string.
 * If the indicated input does not exist or the indicated input does not have the address,
 * the attestation request is rejected.
 * The `sourceAddress` is the address of the indicated transaction input.
 * - `spentAmount` is the sum of values of all inputs with sourceAddress minus the sum of
 * all outputs with `sourceAddress`.
 * Can be negative.
 * - `blockTimestamp` is the mediantime of a block.
 *
 * ### XRPL
 *
 * - `sourceAddressIndicator` is the standard address hash of the address whose balance has been decreased.
 * If the address indicated by `sourceAddressIndicator` is not among the signers of the transaction and the balance
 * of the address was not lowered in the transaction, the attestation request is rejected.
 *
 * - `spentAmount` is the difference between the balance of the indicated address after and before the transaction.
 * Can be negative.
 * - `blockTimestamp` is the close_time of a ledger converted to unix time.
 *
 * @custom:lut `blockTimestamp`
 * @custom:lutlimit `0x127500`, `0x127500`, `0x127500`
 */
interface IBalanceDecreasingTransaction {
    /**
     * @notice Toplevel request
     * @param attestationType ID of the attestation type.
     * @param sourceId ID of the data source.
     * @param messageIntegrityCode `MessageIntegrityCode` that is derived from the expected response.
     * @param requestBody Data defining the request. Type and interpretation is determined by the `attestationType`.
     */
    struct Request {
        bytes32 attestationType;
        bytes32 sourceId;
        bytes32 messageIntegrityCode;
        RequestBody requestBody;
    }

    /**
     * @notice Toplevel response
     * @param attestationType Extracted from the request.
     * @param sourceId Extracted from the request.
     * @param votingRound The ID of the State Connector round in which the request was considered.
     * This is a security measure to prevent a collision of attestation hashes.
     * @param lowestUsedTimestamp The lowest timestamp used to generate the response.
     * @param requestBody Extracted from the request.
     * @param responseBody Data defining the response. The verification rules for the construction of the
     * response body and the type are defined per specific `attestationType`.
     */
    struct Response {
        bytes32 attestationType;
        bytes32 sourceId;
        uint64 votingRound;
        uint64 lowestUsedTimestamp;
        RequestBody requestBody;
        ResponseBody responseBody;
    }

    /**
     * @notice Toplevel proof
     * @param merkleProof Merkle proof corresponding to the attestation response.
     * @param data Attestation response.
     */
    struct Proof {
        bytes32[] merkleProof;
        Response data;
    }

    /**
     * @notice Request body for IBalanceDecreasingTransaction attestation type
     * @param transactionId ID of the payment transaction.
     * @param sourceAddressIndicator The indicator of the address whose balance has been decreased.
     */
    struct RequestBody {
        bytes32 transactionId;
        bytes32 sourceAddressIndicator;
    }

    /**
     * @notice Response body for IBalanceDecreasingTransaction attestation type.
     * @param blockNumber The number of the block in which the transaction is included.
     * @param blockTimestamp The timestamp of the block in which the transaction is included.
     * @param sourceAddressHash Standard address hash of the address indicated by the `sourceAddressIndicator`.
     * @param spentAmount Amount spent by the source address in minimal units.
     * @param standardPaymentReference Standard payment reference of the transaction.
     */
    struct ResponseBody {
        uint64 blockNumber;
        uint64 blockTimestamp;
        bytes32 sourceAddressHash;
        int256 spentAmount;
        bytes32 standardPaymentReference;
    }
}
```",2025-03-08 01:27:14
IFdcRequestFeeConfigurations.md,"title: IFdcRequestFeeConfigurations
sidebar_position: 4
description: Interface for managing FDC request fee configuration.","Interface for managing FDC request fee configuration.

Sourced from `IFdcRequestFeeConfigurations.sol` on [GitHub](https://github.com/flare-foundation/flare-smart-contracts-v2/blob/main/contracts/userInterfaces/IFdcRequestFeeConfigurations.sol).

## Functions

### getRequestFee

Method to get the base fee for an attestation request. It reverts if the request is not supported.

```solidity
function getRequestFee(
    bytes _data
) external view returns (
    uint256
);
```

#### Parameters

- `_data`: ABI encoded attestation request

## Events

### TypeAndSourceFeeRemoved

```solidity
event TypeAndSourceFeeRemoved(
    bytes32 attestationType,
    bytes32 source
)
```

### TypeAndSourceFeeSet

```solidity
event TypeAndSourceFeeSet(
    bytes32 attestationType,
    bytes32 source,
    uint256 fee
)
```",2025-03-08 01:27:14
IConfirmedBlockHeightExists.mdx,"title: IConfirmedBlockHeightExists
sidebar_position: 8
description: Assert that a block number is confirmed.","Sourced from `IConfirmedBlockHeightExists.sol` on [GitHub](https://github.com/flare-foundation/flare-smart-contracts-v2/blob/main/contracts/userInterfaces/fdc/IConfirmedBlockHeightExists.sol).

```solidity
// SPDX-License-Identifier: MIT
pragma solidity >=0.7.6 <0.9;

/**
 * @custom:name IConfirmedBlockHeightExists
 * @custom:id 0x02
 * @custom:supported BTC, DOGE, XRP
 * @author Flare
 * @notice An assertion that a block with `blockNumber` is confirmed.
 * It also provides data to compute the block production rate in the given time range.
 * @custom:verification It is checked that the block with `blockNumber` is confirmed by at
 * least `numberOfConfirmations`.
 * If it is not, the request is rejected. We note a block on the tip of the chain is confirmed by 1 block.
 * Then `lowestQueryWindowBlock` is determined and its number and timestamp are extracted.
 *
 *
 * Current confirmation heights consensus:
 *
 *
 * | `Chain` | `chainId` | `numberOfConfirmations` | `timestamp ` |
 * | ------- | --------- | ----------------------- | ------------ |
 * | `BTC`   | 0         | 6                       | mediantime   |
 * | `DOGE`  | 2         | 60                      | mediantime   |
 * | `XRP`   | 3         | 3                       | close_time   |
 *
 *
 * @custom:lut `lowestQueryWindowBlockTimestamp`
 * @custom:lutlimit `0x127500`, `0x127500`, `0x127500`
 */
interface IConfirmedBlockHeightExists {
    /**
     * @notice Toplevel request
     * @param attestationType ID of the attestation type.
     * @param sourceId ID of the data source.
     * @param messageIntegrityCode `MessageIntegrityCode` that is derived from the expected response as defined.
     * @param requestBody Data defining the request. Type and interpretation is determined by the `attestationType`.
     */
    struct Request {
        bytes32 attestationType;
        bytes32 sourceId;
        bytes32 messageIntegrityCode;
        RequestBody requestBody;
    }

    /**
     * @notice Toplevel response
     * @param attestationType Extracted from the request.
     * @param sourceId Extracted from the request.
     * @param votingRound The ID of the State Connector round in which the request was considered.
     * @param lowestUsedTimestamp The lowest timestamp used to generate the response.
     * @param requestBody Extracted from the request.
     * @param responseBody Data defining the response. The verification rules for the construction of the
     * response body and the type are defined per specific `attestationType`.
     */
    struct Response {
        bytes32 attestationType;
        bytes32 sourceId;
        uint64 votingRound;
        uint64 lowestUsedTimestamp;
        RequestBody requestBody;
        ResponseBody responseBody;
    }

    /**
     * @notice Toplevel proof
     * @param merkleProof Merkle proof corresponding to the attestation response.
     * @param data Attestation response.
     */
    struct Proof {
        bytes32[] merkleProof;
        Response data;
    }

    /**
     * @notice Request body for ConfirmedBlockHeightExistsType attestation type
     * @param blockNumber The number of the block the request wants a confirmation of.
     * @param queryWindow The length of the period in which the block production rate is to be computed.
     */
    struct RequestBody {
        uint64 blockNumber;
        uint64 queryWindow;
    }

    /**
     * @notice Response body for ConfirmedBlockHeightExistsType attestation type
     * @custom:below `blockNumber`, `lowestQueryWindowBlockNumber`, `blockTimestamp`, `lowestQueryWindowBlockTimestamp`
     * can be used to compute the average block production time in the specified block range.
     * @param blockTimestamp The timestamp of the block with `blockNumber`.
     * @param numberOfConfirmations The depth at which a block is considered confirmed depending on the chain.
     * All attestation providers must agree on this number.
     * @param lowestQueryWindowBlockNumber The block number of the latest block that has a timestamp strictly smaller
     * than `blockTimestamp` - `queryWindow`.
     * @param lowestQueryWindowBlockTimestamp The timestamp of the block at height `lowestQueryWindowBlockNumber`.
     */
    struct ResponseBody {
        uint64 blockTimestamp;
        uint64 numberOfConfirmations;
        uint64 lowestQueryWindowBlockNumber;
        uint64 lowestQueryWindowBlockTimestamp;
    }
}
```",2025-03-08 01:27:14
IFdcInflationConfigurations.md,"title: IFdcInflationConfigurations
sidebar_position: 5
description: Interface for managing FDC inflation configuration.","Interface for managing FDC inflation configuration.

Sourced from `IFdcInflationConfigurations.sol` on [GitHub](https://github.com/flare-foundation/flare-smart-contracts-v2/blob/main/contracts/userInterfaces/IFdcInflationConfigurations.sol).

## Functions

### getFdcConfiguration

Returns the FDC configuration at `_index`.

```solidity
function getFdcConfiguration(
    uint256 _index
) external view returns (
    struct IFdcInflationConfigurations.FdcConfiguration
);
```

#### Parameters

- `_index`: The index of the FDC configuration.

### getFdcConfigurations

Returns the FDC configurations.

```solidity
function getFdcConfigurations(
) external view returns (
    struct IFdcInflationConfigurations.FdcConfiguration[]
);
```

## Structures

### FdcConfiguration

The FDC configuration struct.

```solidity
struct FdcConfiguration {
  bytes32 attestationType;
  bytes32 source;
  uint24 inflationShare;
  uint8 minRequestsThreshold;
  uint224 mode;
}
```",2025-03-08 01:27:14
IAddressValidity.mdx,"title: IAddressValidity
sidebar_position: 6
description: Assert whether a string represents a valid address.","Sourced from `IAddressValidity.sol` on [GitHub](https://github.com/flare-foundation/flare-smart-contracts-v2/blob/main/contracts/userInterfaces/fdc/IAddressValidity.sol).

```solidity
// SPDX-License-Identifier: MIT
pragma solidity >=0.7.6 <0.9;

/**
 * @custom:name IAddressValidity
 * @custom:id 0x05
 * @custom:supported BTC, DOGE, XRP
 * @author Flare
 * @notice An assertion whether a string represents a valid address on an external chain.
 * @custom:verification The address is checked against all validity criteria of the chain with `sourceId`.
 * Indicator of validity is provided.
 * If the address is valid, its standard form and standard hash are computed.
 * Validity criteria for each supported chain:
 * - [BTC](/specs/attestations/external-chains/address-validity/BTC.md)
 * - [DOGE](/specs/attestations/external-chains/address-validity/DOGE.md)
 * - [XRPL](/specs/attestations/external-chains/address-validity/XRPL.md)
 * @custom:lut `0xffffffffffffffff` ($2^{64}-1$ in hex)
 * @custom:lutlimit `0xffffffffffffffff`, `0xffffffffffffffff`, `0xffffffffffffffff`
 */
interface IAddressValidity {
    /**
     * @notice Toplevel request
     * @param attestationType ID of the attestation type.
     * @param sourceId Id of the data source.
     * @param messageIntegrityCode `MessageIntegrityCode` that is derived from the expected response.
     * @param requestBody Data defining the request. Type and interpretation is determined by the `attestationType`.
     */
    struct Request {
        bytes32 attestationType;
        bytes32 sourceId;
        bytes32 messageIntegrityCode;
        RequestBody requestBody;
    }

    /**
     * @notice Toplevel response
     * @param attestationType Extracted from the request.
     * @param sourceId Extracted from the request.
     * @param votingRound The ID of the State Connector round in which the request was considered.
     * @param lowestUsedTimestamp The lowest timestamp used to generate the response.
     * @param requestBody Extracted from the request.
     * @param responseBody Data defining the response. The verification rules for the construction of the
     * response body and the type are defined per specific `attestationType`.
     */
    struct Response {
        bytes32 attestationType;
        bytes32 sourceId;
        uint64 votingRound;
        uint64 lowestUsedTimestamp;
        RequestBody requestBody;
        ResponseBody responseBody;
    }

    /**
     * @notice Toplevel proof
     * @param merkleProof Merkle proof corresponding to the attestation response.
     * @param data Attestation response.
     */
    struct Proof {
        bytes32[] merkleProof;
        Response data;
    }

    /**
     * @notice Request body for IAddressValidity attestation type
     * @param addressStr Address to be verified.
     */
    struct RequestBody {
        string addressStr;
    }

    /**
     * @notice Response body for IAddressValidity attestation type
     * @param isValid Boolean indicator of the address validity.
     * @param standardAddress If `isValid`, standard form of the validated address. Otherwise an empty string.
     * @param standardAddressHash If `isValid`, standard address hash of the validated address.
     * Otherwise a zero bytes32 string.
     */
    struct ResponseBody {
        bool isValid;
        string standardAddress;
        bytes32 standardAddressHash;
    }
}
```",2025-03-08 01:27:14
